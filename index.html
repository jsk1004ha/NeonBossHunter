<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>NEON BOSS HUNTER — Bullet Hell + Action</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0a0f1f;
    --panel:#0f1630;
    --txt:#e6f3ff;
    --accent:#49f3ff;
    --accent2:#ff71ff;
    --danger:#ff3b5c;
    --ok:#5bff8c;
    --warn:#ffd24a;
    --neonShadow: 0 0 10px var(--accent), 0 0 20px var(--accent2);
    --font-clean: 'Orbitron', monospace;
  }
  body{margin:0;background:radial-gradient(1200px 600px at 50% 30%,#101836 0%,#0a0f1f 50%,#050811 100%);color:var(--txt);font-family:var(--font-clean);overscroll-behavior:none;}
  #uiLayer{position:fixed;inset:0;pointer-events:none;}
  canvas{display:block;margin:40px auto 0;max-width:100vw;max-height:calc(100vh - 40px);touch-action:none;image-rendering: pixelated;}
  .topbar{position:fixed;left:0;right:0;top:0;display:flex;justify-content:center;gap:12px;padding:8px 12px;pointer-events:auto;background:rgba(16,24,48,.9);backdrop-filter: blur(6px);border-bottom:1px solid rgba(120,160,255,.25);z-index:1000}
  .pill{background:rgba(16,24,48,.7);backdrop-filter: blur(6px);border:1px solid rgba(80,140,255,.25);border-radius:2px;padding:6px 12px;box-shadow: var(--neonShadow);display:flex;align-items:center;gap:8px;}
  .btn{pointer-events:auto;cursor:pointer;user-select:none}
  .btn:hover{filter:brightness(1.1)}
  .menu{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(3,8,16,.75), rgba(3,8,16,.9));backdrop-filter: blur(6px);pointer-events:auto}
  .card{width:min(980px,92vw);max-height:86vh;overflow:auto;background:var(--panel);border:1px solid rgba(120,160,255,.25);border-radius:4px;padding:18px 18px 22px;box-shadow:0 10px 40px rgba(0,0,0,.45), 0 0 30px rgba(120,160,255,.15);}
  h1{margin:0 0 10px 0;font-size:28px;font-weight:900;text-shadow:0 0 20px var(--accent);}
  h2{margin:12px 0 8px 0;font-size:20px;font-weight:700;}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:12px}
  .weapon{border:1px solid rgba(120,160,255,.3);border-radius:2px;padding:12px;background:rgba(12,18,40,.8);display:flex;flex-direction:column;gap:8px}
  .weapon.sel{outline:2px solid var(--accent);box-shadow:0 0 20px rgba(73,243,255,.35) inset}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .chip{border:1px solid rgba(120,160,255,.25);background:rgba(12,18,40,.7);border-radius:2px;padding:4px 10px}
  .kbd{font-family:ui-monospace,Menlo,Consolas,monospace;border:1px solid rgba(255,255,255,.2);background:#0b1226;border-radius:2px;padding:2px 6px}
  .floating{position:fixed;right:12px;bottom:12px;display:flex;flex-direction:column;gap:8px}
  .floating .btn{border:1px solid rgba(120,160,255,.25);background:rgba(12,18,40,.8);border-radius:2px;padding:10px 12px}
  .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);backdrop-filter: blur(2px);pointer-events:auto}
  .modal .card{width:min(720px,92vw)}
  .hpbar{position:fixed;left:50%;transform:translateX(-50%);top:60px;width:min(880px,92vw);height:16px;background:rgba(20,28,55,.8);border-radius:2px;border:1px solid rgba(120,160,255,.3);overflow:hidden}
  .hpfill{height:100%;background:linear-gradient(90deg,#ff4d7e,#ffd24a);box-shadow:0 0 12px rgba(255,77,126,.6) inset}
  .stageNote{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);font-size:28px;padding:10px 16px;background:rgba(0,0,0,.35);border:1px solid rgba(120,160,255,.3);border-radius:2px;display:none;font-weight:700;text-shadow:0 0 15px var(--accent);}
  /* 모바일 조이스틱 */
  .stick{position:fixed;bottom:18px;width:140px;height:140px;border-radius:50%;border:1px solid rgba(120,160,255,.25);background:rgba(12,18,40,.55);backdrop-filter: blur(4px);pointer-events:auto;touch-action:none}
  .stick .knob{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:72px;height:72px;border-radius:50%;background:rgba(73,243,255,.35);border:2px solid rgba(73,243,255,.65);box-shadow:0 0 16px rgba(73,243,255,.5) inset}
  #stickMove{left:18px}
  #stickAim{right:18px}
  .attackBtn{position:fixed;right:22px;bottom:172px;width:92px;height:92px;border-radius:2px;border:2px solid rgba(255,113,255,.7);background:rgba(255,113,255,.2);backdrop-filter: blur(2px);pointer-events:auto;display:flex;align-items:center;justify-content:center;font-weight:700}
  .lvlup{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.6)}
  .cards{display:grid;grid-template-columns:repeat(3,1fr);gap:14px;width:min(980px,92vw)}
  .cardOpt{border:1px solid rgba(120,160,255,.35);background:rgba(10,18,40,.95);padding:16px;border-radius:2px;cursor:pointer}
  .cardOpt:hover{box-shadow:0 0 18px rgba(73,243,255,.25) inset}
  .hint{opacity:.8;font-size:12px}
  .tiny{font-size:11px;opacity:.8}
  .hidden{display:none !important}
</style>
</style>
</head>
<body>
<canvas id="game" width="1280" height="720"></canvas>
<div id="uiLayer" aria-hidden="true"></div>

<!-- 상단 HP/패널 -->
<div class="hpbar" id="bossHp" style="display:none">
  <div id="bossName" style="position:absolute;left:10px;top:50%;transform:translateY(-50%);font-size:12px;font-weight:bold;"></div>
  <div class="hpfill" id="bossHpFill" style="width:100%"></div>
</div>
<div class="topbar">
  <div class="pill">❤️ <span id="playerHpLabel">3</span></div>
  <div class="pill">스테이지 <span id="stageLabel">1-1</span></div>
  <div class="pill">코어 <span id="coreLabel">0</span></div>
  <div class="pill btn" id="btnSettings">설정</div>
  <div class="pill btn" id="btnDebug">디버그</div>
</div>

<!-- 시작 메뉴: 무기 선택 -->
<div class="menu" id="menuStart">
  <div class="card">
    <h1>NEON BOSS HUNTER</h1>
    <div class="tiny">탑다운 탄막+액션 • PC/모바일 • 네온 테마 • 단일 HTML</div>
    <h2>무기 선택</h2>
    <div class="grid" id="weaponGrid"></div>
    <div class="row" style="margin-top:12px">
      <span class="chip">조작: WASD 이동, 마우스 조준/사격 • 모바일 듀얼 조이스틱</span>
    </div>
    <div style="margin-top:12px" class="row">
      <div class="btn pill" id="btnStart">게임 시작</div>
      <div class="pill">최고 기록: <span id="bestLabel">-</span></div>
    </div>
  </div>
</div>

<!-- 레벨업 카드 -->
<div class="lvlup" id="lvlup">
  <div class="cards" id="cardHolder"></div>
</div>

<!-- 설정 모달 -->
<div class="modal" id="modalSettings">
  <div class="card">
    <h2>설정</h2>
    <div class="grid">
      <div class="weapon">
        <b>키 리맵</b>
        <div class="tiny">변경할 키 항목을 눌러 새 키를 입력하세요.</div>
        <div id="keyList"></div>
      </div>
      <div class="weapon">
        <b>그래픽 설정</b>
        <label>그래픽 모드:</label>
        <select id="optGraphicsMode">
          <option value="fancy">화려함 (모든 효과)</option>
          <option value="simple">단순함 (기본 효과)</option>
          <option value="performance">최적화 (최소 효과)</option>
        </select>
        <div class="tiny">화려함: 모든 파티클과 시각 효과, 단순함: 기본 효과만, 최적화: 성능 우선</div><br/>
        
        <label>색약 보조:</label>
        <select id="optColorBlindMode">
          <option value="none">없음</option>
          <option value="protanopia">적색맹 (Protanopia)</option>
          <option value="deuteranopia">녹색맹 (Deuteranopia)</option>
          <option value="tritanopia">청색맹 (Tritanopia)</option>
          <option value="high_contrast">고대비 모드</option>
        </select>
        <div class="tiny">색상 구분이 어려운 경우 대체 색상으로 표시합니다</div>
      </div>
      <div class="weapon">
        <b>기타 옵션</b>
        <label><input type="checkbox" id="optShowHitbox"> 히트박스 표시</label><br/>
        <label><input type="checkbox" id="optShowFps"> FPS 표시</label><br/>
        <label><input type="checkbox" id="optVibrate"> 모바일 진동(Hit/피격)</label>
      </div>
      <div class="weapon">
        <b>저장</b>
        <div>로컬 저장에는 최고 기록, 설정, 해금이 포함됩니다.</div>
        <div class="row" style="margin-top:8px">
          <div class="btn pill" id="btnResetSave">저장 초기화</div>
          <div class="btn pill" id="btnCloseSettings">닫기</div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- 스테이지 안내 -->
<div class="stageNote" id="stageNote">STAGE 1</div>

<!-- 모바일 조이스틱/버튼 -->
<div id="stickMove" class="stick hidden"><div class="knob"></div></div>
<div id="stickAim" class="stick hidden"><div class="knob"></div></div>
<div id="btnAttack" class="attackBtn hidden">공격</div>

<!-- 플로팅 버튼 -->
<div class="floating">
  <div class="btn" id="btnPause">⏸ 일시정지</div>
</div>

<script>
/**
 * NEON BOSS HUNTER — 단일 파일 완성본
 * 스펙:
 * - 1280x720 Canvas, 탑다운, PC+모바일
 * - 무기: 레이저/산탄/로켓/기관총(원거리), 검/대검/망치(근접)
 * - 레벨업 카드 3중 택1 (공격력/연사/탄속/사거리/특수 등)
 * - 스테이지 방식, 보스 1명씩. 각 2~3 페이즈
 * - 색약 보조, 히트박스/FPS 토글, 키 리맵, 진동(옵션), 로컬 저장
 * - 히트스톱 100ms, 피격 후 무적 1초, 플레이어 체력 3, 무기별 이동속도 상이
 */

(() => {
  // ===== 유틸 =====
  const TAU = Math.PI*2;
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const rand = (a,b)=>Math.random()*(b-a)+a;
  const chance = (p)=>Math.random()<p;
  const now = ()=>performance.now();
  const dist2 = (ax,ay,bx,by)=>{let dx=ax-bx, dy=ay-by;return dx*dx+dy*dy;}
  const angleTo = (ax,ay,bx,by)=>Math.atan2(by-ay,bx-ax);
  const vec2 = (a)=>({x:Math.cos(a),y:Math.sin(a)});
  const vibrate = (ms)=>{try{ if(settings.vibrate && navigator.vibrate) navigator.vibrate(ms);}catch{}}

  // ===== 저장 =====
  const SAVE_KEY='neon_boss_hunter_v1';
  
  // ===========================================
  // 디버그 모드 활성화 방법:
  // debugMode: false를 debugMode: true로 변경
  // 효과:
  // - 플레이어가 무적이 되어 모든 데미지를 무시합니다
  // - 디버그 캐논 무기가 무기 선택창에 나타납니다
  // - 디버그 캐논: 극도로 강력한 데미지 (1000), 무한 관통, 초고속 연사
  // ===========================================
  
  const defaultSave = {
    bestTimeSec:null,
    bestStage:0,
    settings:{
      colorBlind:false, showHitbox:false, showFps:false, vibrate:true,
      debugMode:false, // 디버그 모드 - 무적 (코드에서만 변경 가능)
      graphicsMode:'fancy', // 'fancy', 'simple', 'performance'
      colorBlindMode:'none', // 'none', 'protanopia', 'deuteranopia', 'tritanopia', 'high_contrast'
      keys:{up:'KeyW',down:'KeyS',left:'KeyA',right:'KeyD',fire:'MouseLeft',dash:'ShiftLeft',pause:'Escape'}
    },
    unlockedWeapons:{ LASER:true, SHOTGUN:true, ROCKET:true, MINIGUN:true, PLASMA:true, BOOMERANG:true, SMG:true, SNIPER:true, DEBUG_CANNON:true }
  };
  let save = loadSave();

  function loadSave(){
    try{
      const s = JSON.parse(localStorage.getItem(SAVE_KEY));
      if(!s) return structuredClone(defaultSave);
      // 합치기(신규 필드 보정)
      return deepMerge(structuredClone(defaultSave), s);
    }catch{ return structuredClone(defaultSave); }
  }
  function deepMerge(a,b){
    for(const k in b){
      if(b[k] && typeof b[k]==='object' && !Array.isArray(b[k])){
        a[k] = deepMerge(a[k] ?? {}, b[k]);
      }else a[k]=b[k];
    }
    return a;
  }
  function saveNow(){
    localStorage.setItem(SAVE_KEY, JSON.stringify(save));
    refreshUIFromSave();
  }

  // ===== 설정 전역 =====
  let settings = save.settings;
  function refreshUIFromSave(){
    // 기존 설정들
    document.getElementById('optShowHitbox').checked = settings.showHitbox;
    document.getElementById('optShowFps').checked = settings.showFps;
    document.getElementById('optVibrate').checked = settings.vibrate;
    
    // 새로운 그래픽 및 색약 보조 설정
    document.getElementById('optGraphicsMode').value = settings.graphicsMode || 'fancy';
    document.getElementById('optColorBlindMode').value = settings.colorBlindMode || 'none';
    
    document.getElementById('bestLabel').textContent = save.bestTimeSec ? `${save.bestTimeSec.toFixed(1)}s (Stage ${save.bestStage})` : '-';
  }

  // ===== 색약 보조 및 그래픽 모드 함수들 =====
  function getColorBlindSafeColor(originalColor, colorType = 'bullet') {
    if (settings.colorBlindMode === 'none') return originalColor;
    
    // 색상별 색약 보조 매핑
    const colorMaps = {
      'protanopia': {
        '#ff71ff': '#4da6ff', // 마젠타 -> 파랑
        '#49f3ff': '#ffff66', // 시아안 -> 노랑
        '#ffd24a': '#66ff66', // 노랑 -> 밝은 초록
        '#ff3b5c': '#0080ff', // 빨강 -> 파랑
        '#8B00FF': '#0066cc', // 보라 -> 진한 파랑
        '#4B0082': '#003399'  // 남색 -> 더 진한 파랑
      },
      'deuteranopia': {
        '#ff71ff': '#ff9933', // 마젠타 -> 주황
        '#49f3ff': '#3366ff', // 시아안 -> 파랑
        '#ffd24a': '#ffff00', // 노랑 -> 순수 노랑
        '#ff3b5c': '#ff6600', // 빨강 -> 주황
        '#8B00FF': '#6600cc', // 보라 -> 진한 보라
        '#4B0082': '#330099'  // 남색 -> 진한 보라
      },
      'tritanopia': {
        '#ff71ff': '#ff3366', // 마젠타 -> 분홍
        '#49f3ff': '#66ffcc', // 시아안 -> 밝은 초록
        '#ffd24a': '#ff9900', // 노랑 -> 주황
        '#ff3b5c': '#cc0033', // 빨강 -> 진한 빨강
        '#8B00FF': '#990066', // 보라 -> 진한 분홍
        '#4B0082': '#660033'  // 남색 -> 진한 자주
      },
      'high_contrast': {
        '#ff71ff': '#ffffff', // 흰색
        '#49f3ff': '#ffff00', // 노랑
        '#ffd24a': '#ff0000', // 빨강
        '#ff3b5c': '#00ff00', // 초록
        '#8B00FF': '#ffffff', // 흰색
        '#4B0082': '#ff00ff', // 마젠타
        '#ffaa00': '#00ffff', // 시아안
        '#ff4444': '#ffffff'  // 흰색
      }
    };
    
    const map = colorMaps[settings.colorBlindMode];
    return map && map[originalColor] ? map[originalColor] : originalColor;
  }
  
  function shouldShowEffect(effectType) {
    if (settings.graphicsMode === 'performance') {
      // 성능 모드: 최소한의 효과만
      return ['basic_bullet', 'basic_explosion'].includes(effectType);
    } else if (settings.graphicsMode === 'simple') {
      // 단순 모드: 기본 효과들
      return !['advanced_particles', 'complex_shadows', 'distortion_effects'].includes(effectType);
    }
    // 화려함 모드: 모든 효과
    return true;
  }
  
  function getEffectIntensity() {
    switch(settings.graphicsMode) {
      case 'performance': return 0.3;
      case 'simple': return 0.6;
      default: return 1.0; // fancy
    }
  }

  // ===== 캔버스/스케일 =====
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');
  let W=cvs.width, H=cvs.height;
  function fitCanvas(){
    // CSS로만 반응형 — 내부 해상도 고정(1280x720)
    // 모바일일 때 조이스틱 표시
    const isTouch = matchMedia('(pointer:coarse)').matches;
    toggleMobileUI(isTouch);
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

  // ===== 입력 =====
  const keyState = new Set();
  const mouse = {x:W/2,y:H/2,down:false};
  let aimDir = 0; // 마우스/우측 스틱 각도

  // 키 매핑
  function isKey(code, action){
    const map = settings.keys;
    const target = map[action];
    if(code===target) return true;
    // 특별 처리: MouseLeft
    if(action==='fire' && code==='MouseLeft' && mouse.down) return true;
    return false;
  }

  addEventListener('keydown', e=>{
    keyState.add(e.code);
    if(isKey(e.code,'pause')) { togglePause(); e.preventDefault(); }
  });
  addEventListener('keyup', e=>{ keyState.delete(e.code); });
  cvs.addEventListener('mousedown', e=>{ mouse.down=true; });
  addEventListener('mouseup', e=>{ mouse.down=false; });
  cvs.addEventListener('mousemove', e=>{
    const rect=cvs.getBoundingClientRect();
    mouse.x = (e.clientX-rect.left)*W/rect.width;
    mouse.y = (e.clientY-rect.top)*H/rect.height;
    if(player) aimDir = angleTo(player.x,player.y,mouse.x,mouse.y);
  });

  // ===== 모바일 조이스틱 =====
  const stickMove = setupStick('stickMove');
  const stickAim  = setupStick('stickAim');
  const btnAttack = document.getElementById('btnAttack');
  let mobileAttack=false;

  btnAttack.addEventListener('touchstart', e=>{ e.preventDefault(); mobileAttack=true;});
  btnAttack.addEventListener('touchend', e=>{ e.preventDefault(); mobileAttack=false;});

  function setupStick(id){
    const el = document.getElementById(id);
    const knob = el.querySelector('.knob');
    const state = {active:false, vx:0, vy:0, angle:0, mag:0};
    let base={x:0,y:0};
    function setKnob(dx,dy){
      const r=55; // half range
      const m = Math.hypot(dx,dy);
      const cl = m>r ? r/m : 1;
      knob.style.left = (50 + (dx*cl)/1.4)+'%';
      knob.style.top  = (50 + (dy*cl)/1.4)+'%';
    }
    function onStart(cx,cy){
      state.active=true;
      base={x:cx,y:cy};
    }
    function onMove(cx,cy){
      if(!state.active) return;
      const dx=cx-base.x, dy=cy-base.y;
      const m=Math.hypot(dx,dy);
      state.mag = clamp(m/70,0,1);
      state.angle = Math.atan2(dy,dx);
      state.vx = Math.cos(state.angle)*state.mag;
      state.vy = Math.sin(state.angle)*state.mag;
      setKnob(dx,dy);
    }
    function onEnd(){
      state.active=false; state.vx=state.vy=state.mag=0;
      knob.style.left='50%'; knob.style.top='50%';
    }
    el.addEventListener('touchstart', e=>{
      e.preventDefault();
      const t=e.changedTouches[0];
      onStart(t.clientX,t.clientY);
    }, {passive:false});
    el.addEventListener('touchmove', e=>{
      e.preventDefault();
      const t=e.changedTouches[0];
      onMove(t.clientX,t.clientY);
    }, {passive:false});
    el.addEventListener('touchend', e=>{ e.preventDefault(); onEnd(); }, {passive:false});
    return state;
  }
  function toggleMobileUI(show){
    document.getElementById('stickMove').classList.toggle('hidden', !show);
    document.getElementById('stickAim').classList.toggle('hidden', !show);
    document.getElementById('btnAttack').classList.toggle('hidden', !show);
  }

  // ===== 게임 상태 =====
  const STATE = { MENU:0, PLAY:1, PAUSE:2, LEVELUP:3, STAGECLEAR:4, GAMEOVER:5 };
  let gameState = STATE.MENU;
  let stageIndex = 0; // 0..(bosses.length-1)
  let stageStartTime=0;
  let totalTime=0;
  let cores=0;
  let portal = null;

  // ===== 플레이어/무기 =====
  let player=null;
  const weapons = [
    {id:'LASER', name:'레이저', desc:'관통 지속빔, 과열 게이지', type:'ranged', move:1.00},
    {id:'SHOTGUN', name:'산탄', desc:'확산 다중탄, 근접 고효율', type:'ranged', move:1.00},
    {id:'ROCKET', name:'로켓', desc:'폭발 범위 피해/넉백', type:'ranged', move:0.95},
    {id:'MINIGUN', name:'기관총', desc:'고연사 저반동, 과열', type:'ranged', move:1.05},
    {id:'PLASMA', name:'플라즈마', desc:'충전식 고위력 관통탄', type:'ranged', move:0.90},
    {id:'BOOMERANG', name:'부메랑', desc:'되돌아오는 곡선 투사체', type:'ranged', move:1.05},
    {id:'SMG', name:'기관단총', desc:'초고속 연사, 기동성 특화', type:'ranged', move:1.25},
    {id:'SNIPER', name:'저격총', desc:'장거리 고위력, 정밀 사격', type:'ranged', move:0.75},
    {id:'DEBUG_CANNON', name:'🔧 디버그 캐논', desc:'[DEV] 무한 관통 초고위력 레이저', type:'ranged', move:1.50, debug:true}
  ];
  let chosenWeapon = 'LASER';

  // 업그레이드 가능한 스탯
  const playerUp = {
    dmg:1, rof:1, projSpeed:1, range:1, survivability:1, special: {}
  };

  // ===== 보스 데이터(스테이지식: 각 보스 1명) =====
  // 각 보스는 phases: [{pattern(time), hpRatioStart, hpRatioEnd}]
  const BOSSES = [
    {
      id:'RING_SENTINEL',
      name:'링 센티넬',
      color:'#49f3ff',
      baseHP:1000, // 2~5분 밸런스: 실제 전투는 난이도/무기 업글에 따라 변동
      phases:[
        { name:'Opening Rings',  until:0.66,  script:'rings' },
        { name:'Spiral+Target',  until:0.33,  script:'spiral_target' },
        { name:'Laser Sweep',    until:0.00,  script:'laser_sweep' }
      ]
    },
    {
      id:'HYDRA_CORE',
      name:'하이드라 코어',
      color:'#ff71ff',
      baseHP:1300,
      phases:[
        { name:'Orbit Orbs',     until:0.5,   script:'orbits' },
        { name:'Spawn Drones',   until:0.2,   script:'drones' },
        { name:'Frenzy Spiral',  until:0.0,   script:'frenzy' }
      ]
    },
    {
      id:'TITAN_FORGE',
      name:'타이탄 포지',
      color:'#ffd24a',
      baseHP:1600,
      phases:[
        { name:'Meteor Hammers', until:0.6,   script:'meteors' },
        { name:'Hammer Barrage', until:0.3,   script:'hammer_barrage' },
        { name:'Desperation',    until:0.0,   script:'desperate' }
      ]
    },
    {
      id:'VOID_REAPER',
      name:'보이드 리퍼',
      color:'#8B00FF',
      baseHP:2000,
      phases:[
        { name:'Shadow Walls',   until:0.65,  script:'shadow_walls' },
        { name:'Space Distortion', until:0.30, script:'space_distortion' },
        { name:'Dimensional Collapse', until:0.0, script:'dimensional_collapse' }
      ]
    }
  ];

  // ===== 엔티티 풀 =====
  const bullets=[]; const bulletPool=[];
  const parts=[]; const partPool=[];
  const orbs=[];  // 경험치 코어

  function spawnBullet(b){
    const o = bulletPool.pop() || {};
    
    // 색약 보조 색상 적용
    const safeColor = getColorBlindSafeColor(b.color || '#ffffff', 'bullet');
    
    Object.assign(o,b,{alive:true,ttl:b.ttl??6,color:safeColor});
    bullets.push(o);

    // 이펙트 강화: 보스 탄환 발사 시 파티클 효과 추가 (그래픽 모드 고려)
    if (b.hostile && shouldShowEffect('bullet_spawn')) {
      const intensity = getEffectIntensity();
      const particleCount = Math.floor(2 * intensity);
      
      for(let i=0; i<particleCount; i++) {
        spawnPart({
          x: b.x, y: b.y,
          ttl: rand(0.1, 0.3) * intensity,
          color: safeColor,
          sz: rand(2, 4) * intensity,
          vx: (b.vx || 0) * 0.1 + rand(-30, 30),
          vy: (b.vy || 0) * 0.1 + rand(-30, 30)
        });
      }
    }

    return o;
  }
  function spawnPart(p){
    // 그래픽 모드에 따른 파티클 제한
    if(settings.graphicsMode === 'performance' && Math.random() > 0.3) {
      return null; // 70% 파티클 제거
    } else if(settings.graphicsMode === 'simple' && Math.random() > 0.6) {
      return null; // 40% 파티클 제거
    }
    
    const o = partPool.pop() || {};
    const safeColor = getColorBlindSafeColor(p.color || '#ffffff', 'particle');
    const intensity = getEffectIntensity();
    
    Object.assign(o, p, {
      alive: true,
      ttl: (p.ttl ?? 0.6) * intensity,
      color: safeColor,
      sz: (p.sz || 3) * intensity
    });
    parts.push(o);
    return o;
  }
  function spawnOrb(x,y,amt=1){
    orbs.push({x,y,vx:rand(-50,50),vy:rand(-50,50),r:5,amt,alive:true,ttl:10});
  }

  function clearEntities() {
    bullets.length = 0;
    bulletPool.length = 0;
    parts.length = 0;
    partPool.length = 0;
    orbs.length = 0;
  }

  // ===== 플레이어/보스 클래스 =====
  class Player{
    constructor(){
      this.x=W*0.5; this.y=H*0.75;
      this.r=12; this.hp=3; this.hpMax=3; this.ifr=0;
      this.moveSpd=220; // base, weapon별 계수 적용
      this.fireCd=0; this.meleeCd=0; this.dashCd=0; this.overheat=0;
      this.weapon=chosenWeapon;
      this.aim=0;
      this.alive=true;
      // 플라즈마 캐논용
      this.chargeTime=0;
      this.isCharging=false;
      // 저격총 탄창 시스템
      this.sniperAmmo=5;
      this.sniperMaxAmmo=5;
      this.sniperReloading=false;
      this.sniperReloadTime=0;
      this.sniperMaxReloadTime=7.5;
      // 로켓 탄창 시스템
      this.rocketAmmo=4;
      this.rocketMaxAmmo=4;
      this.rocketReloading=false;
      this.rocketReloadTime=0;
      this.rocketMaxReloadTime=10.0; // 느린 재장전
      // 대쉬 시스템
      this.isDashPreviewing=false;
      this.dashPreviewX=0;
      this.dashPreviewY=0;
      this.dashDistance=120;
      this.dashCooldown=2.0;
    }
    speed(){
      const w=weapons.find(w=>w.id===this.weapon);
      return this.moveSpd*(w?.move||1);
    }
    update(dt){
      if(!this.alive) return;
      
      // 대쉬 쿨다운 감소
      this.dashCd = Math.max(0, this.dashCd - dt);
      
      // 저격총 재장전 처리
      if(this.sniperReloading) {
        this.sniperReloadTime -= dt;
        if(this.sniperReloadTime <= 0) {
          this.sniperReloading = false;
          this.sniperAmmo = this.sniperMaxAmmo;
        }
      }
      
      // 로켓 재장전 처리
      if(this.rocketReloading) {
        this.rocketReloadTime -= dt;
        if(this.rocketReloadTime <= 0) {
          this.rocketReloading = false;
          this.rocketAmmo = this.rocketMaxAmmo;
        }
      }
      
      // 대쉬 입력 처리 (Left Shift)
      const isDashPressed = keyState.has('ShiftLeft');
      
      if(isDashPressed && this.dashCd === 0) {
        // 대쉬 미리보기 - 지속적으로 현재 위치와 조준 방향 기준으로 업데이트
        this.isDashPreviewing = true;
        const dashAngle = this.aim;
        this.dashPreviewX = clamp(this.x + Math.cos(dashAngle) * this.dashDistance, 20, W-20);
        this.dashPreviewY = clamp(this.y + Math.sin(dashAngle) * this.dashDistance, 20, H-20);
      } else if(!isDashPressed && this.isDashPreviewing) {
        // 대쉬 실행
        this.x = this.dashPreviewX;
        this.y = this.dashPreviewY;
        this.dashCd = this.dashCooldown;
        this.isDashPreviewing = false;
        this.ifr = 0.3; // 대쉬 후 짧은 무적 시간
        
        // 대쉬 이펙트
        for(let i=0; i<12; i++) {
          spawnPart({
            x: this.x + rand(-15, 15),
            y: this.y + rand(-15, 15),
            ttl: 0.4,
            color: '#00ff88',
            sz: rand(3, 8)
          });
        }
      } else if(!isDashPressed) {
        // Shift를 누르지 않으면 미리보기 해제
        this.isDashPreviewing = false;
      }
      
      // 이동 입력
      let ix=0, iy=0;
      // 모바일 우선
      if(stickMove.mag>0.01){ ix+=stickMove.vx; iy+=stickMove.vy; }
      else {
        if(keyState.has(settings.keys.left)) ix-=1;
        if(keyState.has(settings.keys.right)) ix+=1;
        if(keyState.has(settings.keys.up)) iy-=1;
        if(keyState.has(settings.keys.down)) iy+=1;
      }
      const n = Math.hypot(ix,iy);
      if(n>0){ ix/=n; iy/=n; }
      const s=this.speed();
      this.x=clamp(this.x+ix*s*dt, 20, W-20);
      this.y=clamp(this.y+iy*s*dt, 20, H-20);

      // 조준 각
      if(stickAim.mag>0.01){
        this.aim = stickAim.angle;
      }else{
        this.aim = aimDir;
      }

      // 무적 프레임
      this.ifr = Math.max(0,this.ifr-dt);

      // 사격/공격
      this.fireCd=Math.max(0,this.fireCd-dt);

      const wantsFire = mouse.down || stickAim.mag>0.2 || keyState.has(settings.keys.fire);

      handleWeaponFire(this, dt, wantsFire);
    }
    draw(g){
      // 대쉬 미리보기 그리기
      if(this.isDashPreviewing) {
        g.save();
        g.globalAlpha = 0.6;
        g.strokeStyle = '#00ff88';
        g.setLineDash([5, 5]);
        g.lineWidth = 2;
        g.beginPath();
        g.moveTo(this.x, this.y);
        g.lineTo(this.dashPreviewX, this.dashPreviewY);
        g.stroke();
        g.setLineDash([]);
        
        // 목표 위치 표시
        g.fillStyle = '#00ff8866';
        g.beginPath();
        g.arc(this.dashPreviewX, this.dashPreviewY, this.r, 0, TAU);
        g.fill();
        g.strokeStyle = '#00ff88';
        g.lineWidth = 2;
        g.stroke();
        g.restore();
      }
      
      // 플레이어 — 픽셀 아트 스타일
      if(this.ifr > 0 && Math.floor(now() / 100) % 2) return; // 피격 시 깜빡임
      drawPixelPlayer(this.x, this.y, this.r, this.aim);
      
      if(settings.showHitbox){
        g.save();
        g.strokeStyle='#ffffff66'; g.setLineDash([3,3]);
        g.beginPath(); g.arc(this.x, this.y, this.r, 0, TAU); g.stroke(); g.setLineDash([]);
        g.restore();
      }
    }
    hit(dmg){
      // 디버그 모드에서는 무적
      if(settings.debugMode) {
        console.log('DEBUG MODE: Damage ignored -', dmg);
        return;
      }
      
      if(this.ifr>0 || !this.alive) return;
      this.hp = Math.max(0, Math.floor(this.hp - dmg)); this.ifr=1.0;
      vibrate(40);
      hitstop(100);
      for(let i=0;i<15;i++) spawnPart({x:this.x+rand(-10,10),y:this.y+rand(-10,10),ttl:rand(0.3,0.6),color:'#ff3b5c',sz:rand(4,9)});
      if(this.hp<=0){ this.alive=false; gameOver(); }
      document.getElementById('playerHpLabel').textContent = Math.floor(this.hp);
    }
  }

  class Boss{
    constructor(cfg){
      this.cfg=cfg;
      this.x=W*0.5; this.y=H*0.28;
      this.r=42;
      this.hpMax=cfg.baseHP*(1+stageIndex*0.2);
      this.hp=this.hpMax;
      this.phaseIndex=0;
      this.timer=0;
      this.laserTimer=0;
      this.alive=true;
      this.color=cfg.color;
      this.script = cfg.phases[0].script;
      this.moveSpeed = 80;
      this.moveTimer = 0;
      this.moveTargetX = this.x;
      this.moveTargetY = this.y;
    }
    get hpRatio(){ return this.hp/this.hpMax; }
    update(dt){
      if(!this.alive) return;
      this.timer+=dt;

      // 보스 이동
      this.moveTimer -= dt;
      if (this.moveTimer <= 0) {
        this.moveTimer = rand(2, 4); // 2-4초마다 방향 변경
        this.moveTargetX = W * 0.5 + rand(-200, 200);
        this.moveTargetY = H * 0.28 + rand(-100, 100);
      }

      const moveAngle = angleTo(this.x, this.y, this.moveTargetX, this.moveTargetY);
      const distToTarget = dist2(this.x, this.y, this.moveTargetX, this.moveTargetY);

      if (distToTarget > 25*25) {
          this.x += Math.cos(moveAngle) * this.moveSpeed * dt;
          this.y += Math.sin(moveAngle) * this.moveSpeed * dt;
      }

      // 페이즈 진행
      const p = this.cfg.phases[this.phaseIndex];
      if(this.hpRatio <= p.until){
        if(this.phaseIndex < this.cfg.phases.length-1){
          this.phaseIndex++;
          this.script = this.cfg.phases[this.phaseIndex].script;
          this.timer=0;
          stageNote(`${this.cfg.name} — ${this.cfg.phases[this.phaseIndex].name}`);
        }
      }
      // 패턴 실행
      bossScripts[this.script]?.(this, dt);
    }
    draw(g){
      // 보스 — 픽셀 아트 스타일
      drawPixelBoss(this.x, this.y, this.r, this.color, this.phaseIndex);
      
      if(settings.showHitbox){
        g.save();
        g.strokeStyle='#fff5'; g.setLineDash([4,4]); 
        g.beginPath(); g.arc(this.x, this.y, this.r, 0, TAU); g.stroke(); g.setLineDash([]);
        g.restore();
      }
    }
    take(dmg){
      this.hp-=dmg;
      spawnPart({x:this.x+rand(-this.r,this.r),y:this.y+rand(-this.r,this.r),ttl:0.25,color:this.color,sz:rand(5,10)});
      if(this.hp<=0 && this.alive){
        this.alive=false;
        // 대폭발 + 코어 드랍
        for(let i=0;i<60;i++) spawnPart({x:this.x+rand(-40,40),y:this.y+rand(-40,40),ttl:rand(0.5,1.2),color:this.color,sz:rand(8,16)});
        for(let i=0;i<20;i++) spawnOrb(this.x+rand(-30,30),this.y+rand(-30,30), rand(2,4));
        
        // 체력 회복
        player.hp = Math.min(player.hpMax, Math.floor(player.hp + player.hpMax * 0.5)); // 50% 체력 회복 (정수로)
        
        // 직접 업그레이드 화면 표시
        setTimeout(() => {
          presentUpgradeChoices();
        }, 500);
      }
    }
  }

  // ===== 보스 패턴 스크립트 =====
  const bossScripts = {
    // 링 센티넬 Phase 1 - 확장된 링 패턴
    rings(b,dt){
      if(!b._ring){ b._ring={cd:0, step:0, pattern:0, subTimer:0}; }
      const R=b._ring; R.cd-=dt; R.subTimer+=dt;
      
      // 패턴 로테이션 (4가지 패턴)
      if(R.subTimer > 6) { R.pattern = (R.pattern + 1) % 4; R.subTimer = 0; }
      
      if(R.cd<=0){
        R.cd = 1.2 + R.pattern * 0.2; // 패턴별 타이밍 조절
        const col = settings.colorBlind? '#00e5ff' : '#49f3ff';
        
        if(R.pattern === 0) { // 기본 동심원 - 강화
          const N=28; const speed=150;
          for(let i=0;i<N;i++){
            const a=i/N*TAU + (R.step%2?0:TAU/N/2);
            spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, r:8, dmg:1, color:col, hostile:true});
          }
          // 추가 내부 링
          const N2=16; const speed2=80;
          for(let i=0;i<N2;i++){
            const a=i/N2*TAU + R.step*0.1;
            spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*speed2, vy:Math.sin(a)*speed2, r:6, dmg:1, color:'#00e5ff', hostile:true});
          }
        } else if(R.pattern === 1) { // 펄스 링 - 강화
          const N=36; const speed=110 + Math.sin(R.step*0.5)*50;
          for(let i=0;i<N;i++){
            const a=i/N*TAU + R.step*0.1;
            spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, r:7, dmg:1, color:'#ff71ff', hostile:true});
          }
          // 지연 펄스
          setTimeout(()=>{
            if(!boss || !boss.alive) return;
            for(let i=0;i<N;i++){
              const a=i/N*TAU + R.step*0.1 + TAU/N/2;
              spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*(speed+30), vy:Math.sin(a)*(speed+30), r:5, dmg:1, color:'#ff3b5c', hostile:true});
            }
          }, 300);
        } else if(R.pattern === 2) { // 교차 링 - 강화
          for(let ring=0; ring<3; ring++){
            const N=24; const speed=140 + ring*25;
            for(let i=0;i<N;i++){
              const a=i/N*TAU + ring*TAU/N/3 + R.step*0.15;
              const colors = ['#49f3ff', '#ffd24a', '#ff71ff'];
              spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, r:7, dmg:1, color:colors[ring], hostile:true});
            }
          }
        } else { // 가변 밀도 링 - 강화
          const N=20 + Math.floor(Math.sin(R.step*0.3)*16); const speed=130;
          for(let i=0;i<N;i++){
            const a=i/N*TAU + R.step*0.08;
            const size = 6 + Math.sin(i*0.5 + R.step)*2;
            spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, r:size, dmg:1, color:'#ff3b5c', hostile:true});
          }
          // 반대 방향 회전
          for(let i=0;i<N/2;i++){
            const a=i/(N/2)*TAU - R.step*0.12;
            spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*speed*0.7, vy:Math.sin(a)*speed*0.7, r:5, dmg:1, color:'#00e5ff', hostile:true});
          }
        }
        R.step++;
      }
      
      // 추가 패턴: 추적 미사일 - 수량 감소
      if(Math.floor(b.timer*2)%8===0 && chance(0.04)){
        const a = angleTo(b.x,b.y, player.x,player.y) + rand(-0.3,0.3);
        for(let i=0;i<2;i++){
          setTimeout(()=>{
            if(!boss || !boss.alive) return;
            spawnBullet({x:b.x,y:b.y, homing:true, r:8, spd:200, dmg:1, color:'#ff71ff', hostile:true, ttl:4.0, turnRate: 2.2});
          }, i*200);
        }
      }
    },
    // 링 센티넬 Phase 2 - 스파이럴+타겟 다양화
    spiral_target(b,dt){
      if(!b._sp){ b._sp={a:0,cd:0,mode:0,modeTimer:0}; }
      const S=b._sp; S.a+=dt*2.5; S.cd-=dt; S.modeTimer+=dt;
      
      // 모드 변경 (3가지 모드)
      if(S.modeTimer > 5) { S.mode = (S.mode + 1) % 3; S.modeTimer = 0; }
      
      if(S.cd<=0){
        S.cd = 0.12 + S.mode * 0.03; // 발사 간격 증가 (0.06->0.12, 0.02->0.03)
        const speed=140 + S.mode * 20;
        const a=S.a;
        const col=settings.colorBlind? '#ffd24a' : '#ff71ff';
        
        if(S.mode === 0) { // 2-way 스파이럴 - 간격 증가
          for(let arm=0; arm<2; arm++){
            const baseAngle = a + arm*TAU/2;
            spawnBullet({x:b.x,y:b.y, vx:Math.cos(baseAngle)*speed, vy:Math.sin(baseAngle)*speed, r:7, dmg:1, color:col, hostile:true});
            // 추가 분기 - 개수 감소
            for(let sub=-1; sub<=1; sub+=2){
              if(Math.random() < 0.6) { // 60% 확률로만 생성
                spawnBullet({x:b.x,y:b.y, vx:Math.cos(baseAngle+sub*0.3)*speed*0.7, vy:Math.sin(baseAngle+sub*0.3)*speed*0.7, r:4, dmg:1, color:'#00e5ff', hostile:true});
              }
            }
          }
        } else if(S.mode === 1) { // 4-way 스파이럴 - 중간탄 제거
          for(let i=0;i<4;i++){
            const aa = a + i*TAU/4;
            spawnBullet({x:b.x,y:b.y, vx:Math.cos(aa)*speed, vy:Math.sin(aa)*speed, r:7, dmg:1, color:'#49f3ff', hostile:true});
            // 중간 각도 추가 - 확률적 생성
            if(Math.random() < 0.4) { // 40% 확률로만 생성
              const midAngle = aa + TAU/8;
              spawnBullet({x:b.x,y:b.y, vx:Math.cos(midAngle)*speed*0.5, vy:Math.sin(midAngle)*speed*0.5, r:4, dmg:1, color:'#ff3b5c', hostile:true});
            }
          }
        } else { // 6-way 가변속도 - 반대방향 탄 감소
          for(let i=0;i<6;i++){
            const aa = a + i*TAU/6;
            const spd = speed + Math.sin(a + i)*40;
            spawnBullet({x:b.x,y:b.y, vx:Math.cos(aa)*spd, vy:Math.sin(aa)*spd, r:7, dmg:1, color:'#ffd24a', hostile:true});
          }
          // 반대 방향 3-way - 개수 감소
          if(Math.random() < 0.5) { // 50% 확률로만 생성
            for(let i=0;i<2;i++){ // 3개에서 2개로 감소
              const aa = -a + i*TAU/2;
              spawnBullet({x:b.x,y:b.y, vx:Math.cos(aa)*speed*0.6, vy:Math.sin(aa)*speed*0.6, r:5, dmg:1, color:'#ff71ff', hostile:true});
            }
          }
        }
      }
      
      // 추가: 바운싱 탄 - 빈도 감소
      if(Math.floor(b.timer*3)%12===0 && chance(0.03)){ // 주기 증가 (9->12), 확률 감소 (0.06->0.03)
        const base=angleTo(b.x,b.y, player.x,player.y);
        for(let i=-2;i<=2;i++){ // 범위 감소 (-3~3 -> -2~2)
          const aa=base+i*0.3; // 각도 간격 증가 (0.2->0.3)
          spawnBullet({x:b.x,y:b.y, vx:Math.cos(aa)*180, vy:Math.sin(aa)*180, r:7, dmg:1, color:'#ff3b5c', hostile:true, bounce:3}); // 속도 감소 (200->180), 바운스 감소 (4->3)
        }
      }
    },
    // 링 센티넬 Phase 3 - 레이저 패턴 강화
    laser_sweep(b,dt){
      if(!b._lz){ b._lz={cd:0, step:0, warm:0, multiMode:0}; }
      const L=b._lz; L.cd-=dt;
      
      if(L.cd<=0){
        L.cd = 5.0 - L.step * 0.15; // 레이저 간격 증가 (3.8->5.0, 0.2->0.15)
        L.step++;
        L.multiMode = L.step % 3; // 3가지 레이저 패턴
        
        if(L.multiMode === 0) { // 단일 추적 레이저
          const target = angleTo(b.x,b.y, player.x,player.y) + rand(-0.3,0.3); // 정확도 약간 감소
          L.warm = 1.2; L.target = target; // 예고 시간 증가
          setTimeout(()=>{
            if(!boss || !boss.alive) return;
            const len=1200, w=10; // 길이와 폭 감소 (1400->1200, 12->10)
            for(let t=0;t<25;t++){ // 레이저 세그먼트 감소 (30->25)
              const d = (t/25)*len;
              spawnBullet({x:b.x+Math.cos(target)*d, y:b.y+Math.sin(target)*d, vx:0,vy:0, r:w, dmg:2, color:'#ff3b5c', hostile:true, ttl:0.1, laser:true}); // ttl 감소
            }
          }, 1200);
        } else if(L.multiMode === 1) { // 2-way 레이저 (3-way에서 감소)
          for(let i=-0.5;i<=0.5;i+=1){ // 3개에서 2개로 감소
            const target = angleTo(b.x,b.y, player.x,player.y) + i*0.8; // 각도 간격 증가
            L.warm = 1.4; // 예고 시간 증가
            setTimeout(()=>{
              if(!boss || !boss.alive) return;
              const len=1000, w=8; // 길이와 폭 감소 (1200->1000, 10->8)
              for(let t=0;t<20;t++){ // 세그먼트 감소 (25->20)
                const d = (t/20)*len;
                spawnBullet({x:b.x+Math.cos(target)*d, y:b.y+Math.sin(target)*d, vx:0,vy:0, r:w, dmg:1.5, color:'#ffd24a', hostile:true, ttl:0.08, laser:true});
              }
            }, 1400);
          }
        } else { // 회전 레이저 - 회전 수 감소
          const baseAngle = angleTo(b.x,b.y, player.x,player.y);
          L.warm = 1.8; // 예고 시간 증가
          for(let rot=0; rot<3; rot++){ // 5개에서 3개로 감소
            setTimeout(()=>{
              if(!boss || !boss.alive) return;
              const target = baseAngle + rot*0.5; // 각도 간격 증가
              const len=1100, w=6; // 길이와 폭 감소 (1300->1100, 8->6)
              for(let t=0;t<28;t++){
                const d = (t/28)*len;
                spawnBullet({x:b.x+Math.cos(target)*d, y:b.y+Math.sin(target)*d, vx:0,vy:0, r:w, dmg:1, color:'#49f3ff', hostile:true, ttl:0.08, laser:true});
              }
            }, 1500 + rot*200);
          }
        }
      }
      if(L.warm>0) L.warm-=dt;
      
      // 추가: 레이저 간격에 소형 탄막
      if(L.warm <= 0 && chance(0.02)){
        const N=8; const speed=100;
        for(let i=0;i<N;i++){
          const a = i/N*TAU + b.timer;
          spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, r:3, dmg:1, color:'#ff71ff', hostile:true});
        }
      }
    },
    // 하이드라 코어 Phase 1 - 오비트 패턴 강화
    orbits(b,dt){
      if(!b._orb){ b._orb={t:0, pattern:0, switchTimer:0}; }
      b._orb.t+=dt; b._orb.switchTimer+=dt;
      
      // 패턴 변경 (4가지)
      if(b._orb.switchTimer > 7) { b._orb.pattern = (b._orb.pattern + 1) % 4; b._orb.switchTimer = 0; }
      
      const patterns = [
        {N:6, speed:120, rad:90, fireRate:0.02}, // 기본
        {N:8, speed:100, rad:70, fireRate:0.03}, // 밀집
        {N:4, speed:160, rad:110, fireRate:0.015}, // 빠른 4개
        {N:10, speed:80, rad:60, fireRate:0.04} // 느린 다수
      ];
      
      const p = patterns[b._orb.pattern];
      
      for(let i=0;i<p.N;i++){
        const a = b._orb.t*1.2 + i/p.N*TAU;
        const px=b.x+Math.cos(a)*p.rad, py=b.y+Math.sin(a)*p.rad;
        
        if(Math.floor((b._orb.t+i*0.3)*5)%5===0 && chance(p.fireRate)){
          const aim=angleTo(px,py, player.x,player.y);
          const colors = ['#49f3ff', '#ff71ff', '#ffd24a', '#ff3b5c'];
          spawnBullet({x:px,y:py,vx:Math.cos(aim)*p.speed,vy:Math.sin(aim)*p.speed,r:4,dmg:1,color:colors[b._orb.pattern],hostile:true});
        }
      }
      
      // 추가: 중앙에서 펄스 링
      if(Math.floor(b._orb.t*2)%6===0 && chance(0.05)){
        const N=12; const speed=90;
        for(let i=0;i<N;i++){
          const a = i/N*TAU + b._orb.t*0.5;
          spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, r:3, dmg:1, color:'#ff71ff', hostile:true});
        }
      }
    },
    // 하이드라 코어 Phase 2 - 드론 시스템 확장
    drones(b,dt){
      if(!b._dr){ b._dr={cd:0, list:[], formation:0, formationTimer:0}; }
      const D=b._dr; D.cd-=dt; D.formationTimer+=dt;
      
      // 포메이션 변경 (3가지)
      if(D.formationTimer > 8) { D.formation = (D.formation + 1) % 3; D.formationTimer = 0; }
      
      if(D.cd<=0 && D.list.length<6){
        D.cd = 2.8 - D.formation * 0.3;
        let newDrone;
        
        if(D.formation === 0) { // 랜덤 배치
          newDrone = {x:b.x+rand(-120,120), y:b.y+rand(-60,60), hp:8, t:0, type:'basic'};
        } else if(D.formation === 1) { // 원형 배치
          const angle = D.list.length * TAU/6;
          newDrone = {x:b.x+Math.cos(angle)*100, y:b.y+Math.sin(angle)*80, hp:6, t:0, type:'orbiter'};
        } else { // 라인 배치
          newDrone = {x:b.x + (D.list.length-2.5)*40, y:b.y-80, hp:10, t:0, type:'heavy'};
        }
        D.list.push(newDrone);
      }
      
      for(const d of D.list){
        if(!d.alive && d.hp<=0) continue;
        d.t+=dt;
        
        // 드론 타입별 행동
        if(d.type === 'basic') {
          d.x += Math.cos(d.t*2)*30*dt;
          d.y += Math.sin(d.t*2.2)*20*dt;
        } else if(d.type === 'orbiter') {
          const angle = d.t*1.5 + D.list.indexOf(d)*TAU/6;
          d.x = b.x + Math.cos(angle)*100;
          d.y = b.y + Math.sin(angle)*80;
        } else { // heavy
          d.x += Math.sin(d.t*1.5)*15*dt;
          d.y += Math.cos(d.t*1.8)*10*dt;
        }
        
        // 공격 패턴
        const fireChance = d.type === 'heavy' ? 0.08 : 0.05;
        if(Math.floor(d.t*5)%5===0 && chance(fireChance)){
          const a=angleTo(d.x,d.y, player.x,player.y);
          if(d.type === 'heavy') {
            // 3-way 공격
            for(let i=-1;i<=1;i++){
              const aa = a + i*0.2;
              spawnBullet({x:d.x,y:d.y,vx:Math.cos(aa)*220,vy:Math.sin(aa)*220,r:5,dmg:1,color:'#ffd24a',hostile:true});
            }
          } else {
            spawnBullet({x:d.x,y:d.y,vx:Math.cos(a)*200,vy:Math.sin(a)*200,r:4,dmg:1,color:'#ff71ff',hostile:true});
          }
        }
        
        // 피격 처리
        for(const k of bullets){
          if(!k.alive||k.hostile) continue;
          if(dist2(d.x,d.y,k.x,k.y) < (8+k.r)*(8+k.r)){
            d.hp-=k.dmg||1; k.alive=false;
            spawnPart({x:d.x,y:d.y,ttl:0.2,color:'#ff71ff',sz:6});
            if(d.hp<=0){ d.alive=false; spawnOrb(d.x,d.y, rand(2,4)); }
          }
        }
      }
      D.list = D.list.filter(d=>d.alive!==false);
    },
    // 하이드라 코어 Phase 3 - 광란 패턴 업그레이드
    frenzy(b,dt){
      if(!b._fz){ b._fz={cd:0,a:0,intensity:1,burstTimer:0}; }
      const F=b._fz; F.cd-=dt; F.a+=dt*4; F.burstTimer+=dt;
      
      // 강도 증가
      F.intensity = 1 + Math.floor(F.burstTimer/5) * 0.5;
      
      if(F.cd<=0){
        F.cd = 0.05 / F.intensity;
        const speed=180 + F.intensity*20;
        const a=F.a;
        const col=settings.colorBlind? '#ffd24a' : '#ff71ff';
        
        // 기본 3-way
        for(let i=0;i<3;i++){
          const aa=a+i*(TAU/3);
          spawnBullet({x:b.x,y:b.y,vx:Math.cos(aa)*speed,vy:Math.sin(aa)*speed,r:4,dmg:1,color:col,hostile:true});
        }
        
        // 강도에 따른 추가 패턴
        if(F.intensity >= 2) {
          // 6-way 추가
          for(let i=0;i<6;i++){
            const aa=a+i*(TAU/6)+TAU/12;
            spawnBullet({x:b.x,y:b.y,vx:Math.cos(aa)*speed*0.7,vy:Math.sin(aa)*speed*0.7,r:3,dmg:1,color:'#49f3ff',hostile:true});
          }
        }
        
        if(F.intensity >= 3) {
          // 추적 탄환 추가 - 발생 확률 감소
          if(chance(0.05)){
            spawnBullet({x:b.x,y:b.y, homing:true, r:6, spd:120, dmg:1, color:'#ff3b5c',hostile:true, ttl:8});
          }
        }
      }
      
      // 버스트 공격
      if(Math.floor(F.burstTimer)%4===0 && chance(0.03)){
        for(let ring=0;ring<2;ring++){
          const N=20; const speed=100+ring*50;
          for(let i=0;i<N;i++){
            const aa = i/N*TAU + ring*TAU/N/2;
            spawnBullet({x:b.x,y:b.y,vx:Math.cos(aa)*speed,vy:Math.sin(aa)*speed,r:4,dmg:1,color:'#ffd24a',hostile:true});
          }
        }
      }
    },
    // 타이탄 포지 Phase 2 - 해머 연타 패턴 (난이도 증가)
    hammer_barrage(b,dt){
      if(!b._hm){ b._hm={cd:1.0, pattern:0, comboTimer:0, targetX:W*0.5, targetY:H*0.6}; } // 초기 딜레이 감소
      const HM=b._hm; HM.cd-=dt; HM.comboTimer+=dt;
      
      // 패턴 변경 (3가지) - 더 빠른 변경
      if(HM.comboTimer > 6) { HM.pattern = (HM.pattern + 1) % 3; HM.comboTimer = 0; }
      
      if(HM.cd<=0){
        HM.cd = 1.2 + HM.pattern * 0.2; // 패턴별 간격 감소 (1.8->1.2)
        
        if(HM.pattern === 0) { // 직선 해머 스트라이크 - 강화
          // 플레이어를 향해 해머 발사
          const angle = angleTo(b.x, b.y, player.x, player.y);
          for(let i=0; i<5; i++) { // 3발 -> 5발
            setTimeout(() => {
              if(boss && boss.alive) {
                const spread = (i-2) * 0.15; // 5발 확산
                spawnBullet({
                  x: b.x + Math.cos(angle) * 30,
                  y: b.y + Math.sin(angle) * 30,
                  vx: Math.cos(angle + spread) * 320, // 속도 증가 (250->320)
                  vy: Math.sin(angle + spread) * 320,
                  r: 8, // 크기 증가 (7->8)
                  dmg: 1.5, // 데미지 증가
                  color: '#ffd24a',
                  hostile: true,
                  ttl: 2.5
                });
              }
            }, i * 120); // 딜레이 감소 (200->120)
          }
        } else if(HM.pattern === 1) { // 교차 해머 - 강화
          // X자 패턴으로 8방향 발사 (4->8)
          for(let i=0; i<8; i++) {
            const angle = (i * TAU/8); // 8방향
            spawnBullet({
              x: b.x,
              y: b.y,
              vx: Math.cos(angle) * 280, // 속도 증가 (200->280)
              vy: Math.sin(angle) * 280,
              r: 9, // 크기 증가 (8->9)
              dmg: 2, // 데미지 증가 (1.5->2)
              color: '#ff9b3b',
              hostile: true,
              ttl: 3.0
            });
          }
        } else { // 망치 폭격 - 강화
          // 랜덤 위치에 망치들이 떨어짐
          for(let i=0; i<6; i++) { // 개수 증가 (4->6)
            setTimeout(() => {
              if(boss && boss.alive) {
                const targetX = rand(100, W-100); // 범위 확대
                const targetY = rand(H*0.4, H-100);
                
                // 경고 표시 파티클
                for(let j=0; j<8; j++) { // 경고 파티클 증가
                  spawnPart({
                    x: targetX + rand(-25, 25),
                    y: targetY + rand(-25, 25),
                    ttl: 0.8, // 경고 시간 감소 (1.0->0.8)
                    color: '#ff3b5c',
                    sz: rand(4, 8)
                  });
                }
                
                // 0.8초 후 망치 투하
                setTimeout(() => {
                  if(boss && boss.alive) {
                    spawnBullet({
                      x: targetX,
                      y: targetY - 50,
                      vx: 0,
                      vy: 450, // 속도 증가 (350->450)
                      r: 12, // 크기 증가 (10->12)
                      dmg: 3, // 데미지 증가 (2->3)
                      color: '#ffd24a',
                      hostile: true,
                      ttl: 2.0
                    });
                  }
                }, 800); // 경고 시간 감소
              }
            }, i * 200); // 간격 감소 (300->200)
          }
        }
      }
      
      // 추가: 작은 파편 흩뿌리기 - 빈도 증가
      if(Math.floor(HM.comboTimer*2)%6===0 && chance(0.08)){ // 빈도 증가 (%10->%6, 0.03->0.08)
        const N=10; const speed=120; // 개수, 속도 증가 (6->10, 80->120)
        for(let i=0;i<N;i++){
          const a = i/N*TAU + Math.random()*0.4;
          spawnBullet({
            x: b.x + rand(-25, 25),
            y: b.y + rand(-25, 25),
            vx: Math.cos(a) * speed,
            vy: Math.sin(a) * speed,
            r: 4, // 크기 증가 (3->4)
            dmg: 1, // 데미지 증가 (0.5->1)
            color: '#ffaa44',
            hostile: true,
            ttl: 1.5
          });
        }
      }
    },
    // 타이탄 포지 Phase 2 - 메테오 패턴 강화
    meteors(b,dt){
      if(!b._mt){ b._mt={cd:0, pattern:0, salvoTimer:0}; }
      const M=b._mt; M.cd-=dt; M.salvoTimer+=dt;
      
      // 패턴 변경 (3가지)
      if(M.salvoTimer > 8) { M.pattern = (M.pattern + 1) % 3; M.salvoTimer = 0; }
      
      if(M.cd<=0){
        if(M.pattern === 0) { // 단발 추적
          M.cd = 1.0;
          const x = rand(40,W-40), y=-20;
          const a = angleTo(x,y, player.x+rand(-80,80), player.y);
          spawnBullet({x,y, vx:Math.cos(a)*260, vy:Math.sin(a)*260, r:9, dmg:2, color:'#ff9b3b',hostile:true});
        } else if(M.pattern === 1) { // 3연발
          M.cd = 1.8;
          for(let i=0;i<3;i++){
            setTimeout(()=>{
              if(!boss || !boss.alive) return;
              const x = rand(40,W-40), y=-20;
              const a = angleTo(x,y, player.x+rand(-60,60), player.y);
              spawnBullet({x,y, vx:Math.cos(a)*240, vy:Math.sin(a)*240, r:8, dmg:1.5, color:'#ffd24a',hostile:true});
            }, i*400);
          }
        } else { // 광역 폭격
          M.cd = 2.5;
          for(let i=0;i<6;i++){
            setTimeout(()=>{
              if(!boss || !boss.alive) return;
              const x = rand(60,W-60), y=-20;
              const targetX = rand(100,W-100), targetY = rand(200,H-100);
              const a = angleTo(x,y, targetX, targetY);
              spawnBullet({x,y, vx:Math.cos(a)*220, vy:Math.sin(a)*220, r:7, dmg:1, color:'#ff71ff',hostile:true});
            }, i*200);
          }
        }
      }
      
      // 추가: 용암 분출 (위에서 내려오는 탄막)
      if(chance(0.01)){
        const N=8;
        for(let i=0;i<N;i++){
          const x = rand(50,W-50);
          spawnBullet({x, y:-10, vx:rand(-30,30), vy:150, r:5, dmg:1, color:'#ff3b5c', hostile:true});
        }
      }
    },
    // 타이탄 포지 Phase 3 - 절망 패턴 완전체 (난이도 대폭 증가)
    desperate(b,dt){
      if(!b._dp){ 
        b._dp={
          t:0, 
          chaos:1, 
          lastBurst:0, 
          meteorTimer:0, 
          waveTimer:0,
          laserTimer:0,
          intensity:1
        }; 
      }
      const D=b._dp; 
      D.t+=dt; 
      D.chaos = Math.min(3, 1 + D.t*0.15); // 혼돈 수치 증가 속도 증가
      D.intensity = 1 + D.t * 0.2; // 강도 증가

      // 1. 메테오 레인 - 대폭 강화
      D.meteorTimer -= dt;
      if(D.meteorTimer <= 0){
        D.meteorTimer = Math.max(0.3, 1.2 - D.chaos*0.2); // 간격 대폭 감소
        
        // 동시에 여러 위치에 메테오
        const meteorCount = Math.floor(2 + D.chaos * 2); // 2~8개
        for(let i=0; i<meteorCount; i++){
          const px = rand(80, W-80);
          const py = rand(H*0.3, H-80);
          
          // 경고 이펙트 강화
          for(let j=0; j<12; j++){
            spawnPart({
              x: px + rand(-30, 30),
              y: py + rand(-30, 30),
              ttl: 0.6, // 경고 시간 감소
              color: '#ff3b5c',
              sz: rand(6, 12)
            });
          }
          
          setTimeout(()=>{
            if(boss && boss.alive){
              spawnBullet({
                x: px, y: py-60,
                vx: rand(-50, 50), vy: 400 + D.chaos*50, // 속도 증가
                r: 8 + D.chaos, dmg: 2 + D.chaos*0.5, // 크기, 데미지 증가
                color: '#ffd24a',
                hostile: true,
                ttl: 3.0
              });
            }
          }, 600);
        }
      }

      // 2. 스파이럴 웨이브 - 적당히 조정
      D.waveTimer -= dt;
      if(D.waveTimer <= 0){
        D.waveTimer = Math.max(0.4, 1.2 - D.chaos*0.2); // 간격 조정 (0.2->0.4, 0.8->1.2)
        
        const N = Math.floor(16 + D.chaos*4); // 탄환 수 감소 (24+8 -> 16+4)
        const layers = Math.floor(1 + D.chaos*0.3); // 레이어 수 감소 (0.5->0.3)
        
        for(let layer=0; layer<layers; layer++){
          for(let i=0; i<N; i++){
            const a = i/N*TAU + D.t*(1+layer*0.5) + layer*TAU/N/2;
            const speed = 120 + D.chaos*20 + layer*15; // 속도 감소 (140+30 -> 120+20, 20->15)
            const size = 5 + layer*1.5; // 크기 감소
            
            spawnBullet({
              x: b.x + Math.cos(a)*30,
              y: b.y + Math.sin(a)*30,
              vx: Math.cos(a)*speed,
              vy: Math.sin(a)*speed,
              r: size,
              dmg: 1 + layer*0.3, // 데미지 감소
              color: layer === 0 ? '#ff71ff' : '#ffd24a',
              hostile: true,
              ttl: 4.0
            });
          }
        }
      }

      // 3. 회전 탄환 - 적당히 조정 (기존 충격파 대신)
      if(Math.floor(D.t*3)%4===0 && chance(0.05 * D.chaos)){ // 빈도 감소 (4->3)
        const N=12 + D.chaos*2; const speed=180+D.chaos*30; // 개수 감소 (20+4 -> 12+2)
        for(let i=0;i<N;i++){
          const a = i/N*TAU + D.t*0.8;
          spawnBullet({
            x: b.x,
            y: b.y,
            vx: Math.cos(a)*speed,
            vy: Math.sin(a)*speed,
            r: 6 + D.chaos*0.3, // 크기 감소
            dmg: 1.2 + D.chaos*0.2, // 데미지 감소
            color: '#ffd24a',
            hostile: true,
            ttl: 3.5
          });
        }
      }

      // 4. 새로운 패턴: 혼돈 버스트 - 적당히 조정
      if(D.t - D.lastBurst > Math.max(3, 5 - D.chaos*0.4)){ // 간격 조정 (2->3, 4->5)
        D.lastBurst = D.t;
        
        // 동시 다발 공격 조정
        const N=32 + D.chaos*8; const speed=140; // 개수 감소 (48+16 -> 32+8)
        for(let i=0;i<N;i++){
          const a = i/N*TAU + Math.random()*0.4;
          setTimeout(()=>{
            if(boss && boss.alive){
              spawnBullet({
                x: b.x + rand(-30, 30), // 범위 감소
                y: b.y + rand(-30, 30),
                vx: Math.cos(a)*speed,
                vy: Math.sin(a)*speed,
                r: 5 + Math.random()*2, // 크기 감소
                dmg: 1.2,
                color: Math.random() > 0.5 ? '#ff71ff' : '#ff3b5c',
                hostile: true,
                ttl: 3.0
              });
            }
          }, Math.random()*1000); // 시간 간격 조정
        }
        
        // 추가: 레이저 스위프
        D.laserTimer = 2.0;
      }

      // 5. 레이저 스위프 (새로운 공격)
      if(D.laserTimer > 0){
        D.laserTimer -= dt;
        const progress = (2.0 - D.laserTimer) / 2.0;
        const angle = progress * TAU * 2; // 2바퀴 회전
        
        // 회전하는 레이저 빔
        for(let i=0; i<3; i++){ // 3개의 레이저
          const a = angle + i*TAU/3;
          for(let d=40; d<300; d+=15){
            const px = b.x + Math.cos(a)*d;
            const py = b.y + Math.sin(a)*d;
            if(px > 0 && px < W && py > 0 && py < H){
              spawnBullet({
                x: px, y: py,
                vx: 0, vy: 0,
                r: 8,
                dmg: 2,
                color: '#49f3ff',
                hostile: true,
                ttl: 0.1,
                laser: true
              });
            }
          }
        }
      }

      // 6. 추가 패턴: 추적 미사일
      if(Math.floor(D.t*1.5)%8===0 && chance(0.06 * D.chaos)){
        const homingCount = Math.floor(2 + D.chaos);
        for(let i=0;i<homingCount;i++){
          setTimeout(()=>{
            if(boss && boss.alive){
              spawnBullet({
                x: b.x + rand(-30, 30),
                y: b.y + rand(-30, 30),
                homing: true,
                r: 8,
                spd: 160 + i*20,
                dmg: 2,
                color: '#ff3b5c',
                hostile: true,
                ttl: 8,
                turnRate: 3.0
              });
            }
          }, i*200);
        }
      }
    },
    
    // ===== VOID_REAPER 패턴들 =====
    
    // Phase 1: Shadow Walls - 대쉬 필수 활용 패턴
    shadow_walls(b,dt){
      if(!b._sw){ 
        b._sw={
          cd:0, 
          wallTimer:0, 
          wallPattern:0, 
          walls:[], 
          warningTime:2.0
        }; 
      }
      const SW=b._sw; 
      SW.cd-=dt; 
      SW.wallTimer-=dt;
      
      // 기존 벽들 업데이트
      for(let i=SW.walls.length-1; i>=0; i--){
        const wall = SW.walls[i];
        wall.lifetime -= dt;
        
        if(wall.phase === 'warning'){
          // 경고 단계
          if(wall.lifetime <= 0){
            wall.phase = 'moving';
            wall.lifetime = 4.0; // 이동 시간
          }
        } else if(wall.phase === 'moving'){
          // 이동 단계
          wall.x += wall.vx * dt;
          wall.y += wall.vy * dt;
          
          // 플레이어와 충돌 검사 (대쉬 중이 아닐 때만)
          if(player && !player.isDashPreviewing && player.ifr <= 0){
            // 벽의 실제 충돌 영역 계산
            const wallHalfWidth = wall.width / 2;
            const wallHalfHeight = wall.height / 2;
            
            // 플레이어가 벽 안에 있는지 체크 (틈 제외)
            if(player.x > wall.x - wallHalfWidth && 
               player.x < wall.x + wallHalfWidth &&
               player.y > wall.y - wallHalfHeight && 
               player.y < wall.y + wallHalfHeight){
              
              // 틈 위치에 있는지 확인
              let inGap = false;
              for(const gap of wall.gaps){
                if(player.x > gap.x - gap.width/2 && 
                   player.x < gap.x + gap.width/2 &&
                   player.y > gap.y - gap.height/2 && 
                   player.y < gap.y + gap.height/2){
                  inGap = true;
                  break;
                }
              }
              
              if(!inGap){
                player.hit(3); // 높은 데미지
              }
            }
          }
          
          if(wall.lifetime <= 0){
            SW.walls.splice(i, 1);
          }
        }
      }
      
      // 새로운 벽 생성
      if(SW.cd <= 0){
        SW.cd = 3.5 - SW.wallPattern * 0.3; // 점점 빨라짐
        SW.wallPattern = (SW.wallPattern + 1) % 4;
        
        let newWall;
        const speed = 80 + SW.wallPattern * 20;
        
        if(SW.wallPattern === 0){ // 세로 벽 (좌→우)
          const startX = -50;
          const targetY = player.y + rand(-100, 100);
          newWall = {
            x: startX,
            y: targetY,
            width: 40,
            height: H * 0.8,
            vx: speed,
            vy: 0,
            gaps: [
              {x: startX, y: targetY + rand(-150, 150), width: 80, height: 120}
            ],
            phase: 'warning',
            lifetime: SW.warningTime,
            color: '#8B00FF'
          };
        } else if(SW.wallPattern === 1){ // 가로 벽 (위→아래)
          const startY = -50;
          const targetX = player.x + rand(-150, 150);
          newWall = {
            x: targetX,
            y: startY,
            width: W * 0.7,
            height: 40,
            vx: 0,
            vy: speed,
            gaps: [
              {x: targetX + rand(-200, 200), y: startY, width: 120, height: 80}
            ],
            phase: 'warning',
            lifetime: SW.warningTime,
            color: '#8B00FF'
          };
        } else if(SW.wallPattern === 2){ // 대각선 벽
          const startX = -50;
          const startY = -50;
          newWall = {
            x: startX,
            y: startY,
            width: Math.hypot(W, H) * 0.8,
            height: 50,
            vx: speed * 0.7,
            vy: speed * 0.7,
            gaps: [
              {x: startX + 200, y: startY + 200, width: 100, height: 100},
              {x: startX + 400, y: startY + 400, width: 100, height: 100}
            ],
            phase: 'warning',
            lifetime: SW.warningTime,
            color: '#8B00FF'
          };
        } else { // X자 교차 벽
          // 두 개의 대각선 벽 동시 생성
          newWall = {
            x: -50,
            y: H + 50,
            width: Math.hypot(W, H) * 0.8,
            height: 40,
            vx: speed * 0.7,
            vy: -speed * 0.7,
            gaps: [
              {x: W/2 - 100, y: H/2, width: 200, height: 100}
            ],
            phase: 'warning',
            lifetime: SW.warningTime,
            color: '#8B00FF'
          };
          
          // 두 번째 벽
          SW.walls.push({
            x: -50,
            y: -50,
            width: Math.hypot(W, H) * 0.8,
            height: 40,
            vx: speed * 0.7,
            vy: speed * 0.7,
            gaps: [
              {x: W/2 + 100, y: H/2, width: 200, height: 100}
            ],
            phase: 'warning',
            lifetime: SW.warningTime,
            color: '#8B00FF'
          });
        }
        
        SW.walls.push(newWall);
      }
      
      // 추가 패턴: 그림자 탄환
      if(Math.floor(b.timer*2)%8===0 && chance(0.08)){
        const N=12; const speed=140;
        for(let i=0;i<N;i++){
          const a = i/N*TAU + b.timer*0.5;
          spawnBullet({
            x: b.x + Math.cos(a)*60,
            y: b.y + Math.sin(a)*60,
            vx: Math.cos(a)*speed,
            vy: Math.sin(a)*speed,
            r: 5,
            dmg: 1,
            color: '#4B0082',
            hostile: true,
            ttl: 3.0
          });
        }
      }
    },
    
    // Phase 2: Space Distortion - 공간 왜곡 패턴
    space_distortion(b,dt){
      if(!b._sd){ 
        b._sd={
          cd:0, 
          teleportTimer:0, 
          distortionFields:[], 
          pattern:0,
          patternTimer:0
        }; 
      }
      const SD=b._sd; 
      SD.cd-=dt; 
      SD.teleportTimer-=dt; 
      SD.patternTimer+=dt;
      
      // 패턴 변경
      if(SD.patternTimer > 8) { 
        SD.pattern = (SD.pattern + 1) % 3; 
        SD.patternTimer = 0; 
      }
      
      // 왜곡 필드 업데이트
      for(let i=SD.distortionFields.length-1; i>=0; i--){
        const field = SD.distortionFields[i];
        field.lifetime -= dt;
        field.intensity = Math.sin(field.lifetime * 4) * 0.5 + 0.5;
        
        // 플레이어가 왜곡 필드 안에 있으면 탄환 궤도 왜곡
        if(dist2(player.x, player.y, field.x, field.y) < field.radius * field.radius){
          // 플레이어 이동 저해 효과
          if(player.moveSpd > 100) player.moveSpd = 100;
        }
        
        if(field.lifetime <= 0){
          SD.distortionFields.splice(i, 1);
        }
      }
      
      // 텔레포트 공격
      if(SD.teleportTimer <= 0){
        SD.teleportTimer = 4.0 - SD.pattern * 0.5;
        
        // 보스 텔레포트
        const oldX = b.x, oldY = b.y;
        
        // 텔레포트 이펙트 (사라짐)
        for(let i=0; i<20; i++){
          spawnPart({
            x: oldX + rand(-30, 30),
            y: oldY + rand(-30, 30),
            vx: rand(-100, 100),
            vy: rand(-100, 100),
            ttl: 0.5,
            color: '#8B00FF',
            sz: rand(4, 8)
          });
        }
        
        // 새 위치로 텔레포트
        if(SD.pattern === 0){
          // 플레이어 근처로
          const angle = rand(0, TAU);
          b.x = player.x + Math.cos(angle) * 200;
          b.y = player.y + Math.sin(angle) * 200;
        } else if(SD.pattern === 1){
          // 화면 모서리로
          const side = Math.floor(rand(0, 4));
          if(side === 0) { b.x = 100; b.y = rand(100, H-100); }
          else if(side === 1) { b.x = W-100; b.y = rand(100, H-100); }
          else if(side === 2) { b.x = rand(100, W-100); b.y = 100; }
          else { b.x = rand(100, W-100); b.y = H-100; }
        } else {
          // 랜덤 위치
          b.x = rand(150, W-150);
          b.y = rand(100, H*0.6);
        }
        
        // 경계 체크
        b.x = clamp(b.x, 80, W-80);
        b.y = clamp(b.y, 80, H-80);
        
        // 텔레포트 이펙트 (나타남)
        for(let i=0; i<20; i++){
          spawnPart({
            x: b.x + rand(-30, 30),
            y: b.y + rand(-30, 30),
            vx: rand(-100, 100),
            vy: rand(-100, 100),
            ttl: 0.5,
            color: '#8B00FF',
            sz: rand(4, 8)
          });
        }
        
        // 텔레포트 후 즉시 공격
        const attackType = Math.floor(rand(0, 3));
        if(attackType === 0){
          // 왜곡된 탄막
          const N=16; const speed=180;
          for(let i=0;i<N;i++){
            const a = i/N*TAU;
            setTimeout(()=>{
              if(boss && boss.alive){
                spawnBullet({
                  x: b.x + Math.cos(a)*40,
                  y: b.y + Math.sin(a)*40,
                  vx: Math.cos(a)*speed,
                  vy: Math.sin(a)*speed,
                  r: 6,
                  dmg: 1.5,
                  color: '#9932CC',
                  hostile: true,
                  ttl: 3.0,
                  distorted: true
                });
              }
            }, i*50);
          }
        } else if(attackType === 1){
          // 추적 보라색 구체
          for(let i=0;i<4;i++){
            setTimeout(()=>{
              if(boss && boss.alive){
                spawnBullet({
                  x: b.x,
                  y: b.y,
                  homing: true,
                  r: 8,
                  spd: 150,
                  dmg: 2,
                  color: '#8B00FF',
                  hostile: true,
                  ttl: 6,
                  turnRate: 2.5
                });
              }
            }, i*300);
          }
        } else {
          // 왜곡 필드 생성
          SD.distortionFields.push({
            x: b.x,
            y: b.y,
            radius: 120,
            intensity: 1,
            lifetime: 6.0,
            color: '#8B00FF'
          });
        }
      }
      
      // 지속적인 공간 왜곡 탄환
      if(SD.cd <= 0){
        SD.cd = 0.4 + SD.pattern * 0.1;
        
        const aim = angleTo(b.x, b.y, player.x, player.y);
        const spread = 0.3;
        
        for(let i=-1; i<=1; i++){
          const a = aim + i*spread;
          spawnBullet({
            x: b.x + Math.cos(a)*25,
            y: b.y + Math.sin(a)*25,
            vx: Math.cos(a)*200,
            vy: Math.sin(a)*200,
            r: 5,
            dmg: 1,
            color: '#9370DB',
            hostile: true,
            ttl: 4.0
          });
        }
      }
    },
    
    // Phase 3: Dimensional Collapse - 차원 붕괴 최종 패턴
    dimensional_collapse(b,dt){
      if(!b._dc){ 
        b._dc={
          t:0, 
          chaos:1, 
          blackholes:[], 
          rifts:[],
          voidTimer:0,
          collapseTimer:0,
          intensity:1
        }; 
      }
      const DC=b._dc; 
      DC.t+=dt; 
      DC.chaos = Math.min(4, 1 + DC.t*0.2);
      DC.intensity = 1 + DC.t * 0.15;
      DC.voidTimer -= dt;
      DC.collapseTimer -= dt;
      
      // 1. 블랙홀 시스템
      if(DC.voidTimer <= 0){
        DC.voidTimer = Math.max(2, 5 - DC.chaos*0.5);
        
        // 새 블랙홀 생성
        if(DC.blackholes.length < 3 + DC.chaos){
          const blackhole = {
            x: rand(120, W-120),
            y: rand(120, H-120),
            radius: 80 + rand(0, 40),
            pullStrength: 200 + DC.chaos*50,
            lifetime: 8 + rand(0, 4),
            growthRate: 10
          };
          DC.blackholes.push(blackhole);
          
          // 블랙홀 생성 이펙트
          for(let i=0; i<30; i++){
            spawnPart({
              x: blackhole.x + rand(-50, 50),
              y: blackhole.y + rand(-50, 50),
              vx: rand(-150, 150),
              vy: rand(-150, 150),
              ttl: 1.0,
              color: '#000000',
              sz: rand(3, 7)
            });
          }
        }
      }
      
      // 블랙홀 업데이트
      for(let i=DC.blackholes.length-1; i>=0; i--){
        const bh = DC.blackholes[i];
        bh.lifetime -= dt;
        bh.radius += bh.growthRate * dt;
        
        // 플레이어를 블랙홀로 끌어당김
        const distToPlayer = Math.hypot(bh.x - player.x, bh.y - player.y);
        if(distToPlayer < bh.radius*2){
          const pullAngle = angleTo(player.x, player.y, bh.x, bh.y);
          const pullForce = bh.pullStrength / Math.max(1, distToPlayer*0.01);
          
          // 대쉬 중이 아닐 때만 끌어당김
          if(!player.isDashPreviewing){
            player.x += Math.cos(pullAngle) * pullForce * dt * 0.3;
            player.y += Math.sin(pullAngle) * pullForce * dt * 0.3;
          }
          
          // 너무 가까우면 데미지
          if(distToPlayer < bh.radius*0.5){
            player.hit(2);
          }
        }
        
        // 탄환들도 블랙홀로 끌어당김
        for(const bullet of bullets){
          if(!bullet.hostile) continue;
          const distToBH = Math.hypot(bh.x - bullet.x, bh.y - bullet.y);
          if(distToBH < bh.radius*1.5){
            const pullAngle = angleTo(bullet.x, bullet.y, bh.x, bh.y);
            const pullForce = 100 / Math.max(1, distToBH*0.01);
            bullet.vx += Math.cos(pullAngle) * pullForce * dt;
            bullet.vy += Math.sin(pullAngle) * pullForce * dt;
          }
        }
        
        if(bh.lifetime <= 0){
          // 블랙홀 폭발
          for(let j=0; j<50; j++){
            const a = rand(0, TAU);
            const dist = rand(0, bh.radius);
            spawnBullet({
              x: bh.x + Math.cos(a)*dist,
              y: bh.y + Math.sin(a)*dist,
              vx: Math.cos(a)*(200 + rand(0, 100)),
              vy: Math.sin(a)*(200 + rand(0, 100)),
              r: 6,
              dmg: 2,
              color: '#8B00FF',
              hostile: true,
              ttl: 4.0
            });
          }
          DC.blackholes.splice(i, 1);
        }
      }
      
      // 2. 차원 균열 시스템
      if(DC.collapseTimer <= 0){
        DC.collapseTimer = Math.max(1.5, 4 - DC.chaos*0.3);
        
        // 차원 균열 생성
        const riftCount = Math.floor(1 + DC.chaos*0.5);
        for(let i=0; i<riftCount; i++){
          const rift = {
            x: rand(80, W-80),
            y: rand(80, H-80),
            length: 150 + rand(0, 100),
            angle: rand(0, TAU),
            width: 20,
            lifetime: 3 + rand(0, 2),
            phase: 'opening'
          };
          DC.rifts.push(rift);
          
          // 균열에서 탄환 발사 (탄환 수 감소)
          setTimeout(()=>{
            if(boss && boss.alive){
              const bulletCount = 4 + Math.floor(DC.chaos*0.5); // 8+DC.chaos*2 -> 4+DC.chaos*0.5로 대폭 감소
              for(let j=0; j<bulletCount; j++){
                const spreadAngle = rift.angle + (j/(bulletCount-1) - 0.5) * Math.PI * 0.5; // 퍼짐도 감소
                spawnBullet({
                  x: rift.x + Math.cos(rift.angle)*(j-bulletCount/2)*15,
                  y: rift.y + Math.sin(rift.angle)*(j-bulletCount/2)*15,
                  vx: Math.cos(spreadAngle)*250, // 속도 감소
                  vy: Math.sin(spreadAngle)*250,
                  r: 6,
                  dmg: 2.0,
                  color: '#4B0082',
                  hostile: true,
                  ttl: 4.0
                });
              }
            }
          }, 1000);
        }
      }
      
      // 균열 업데이트
      for(let i=DC.rifts.length-1; i>=0; i--){
        const rift = DC.rifts[i];
        rift.lifetime -= dt;
        
        if(rift.lifetime <= 0){
          DC.rifts.splice(i, 1);
        }
      }
      
      // 3. 시공간 붕괴 - 전체 화면 패턴 (더욱 안전하게 조정)
      if(Math.floor(DC.t*0.2)%20===0 && chance(0.03 * DC.chaos)){ // 더 낮은 빈도: 0.3->0.2, 15->20, 0.05->0.03
        // 화면 전체에 무작위 탄환 폭발 (더 적게)
        for(let i=0; i<4 + Math.floor(DC.chaos*1); i++){ // 8+DC.chaos*2 -> 4+DC.chaos*1로 추가 감소
          setTimeout(()=>{
            if(boss && boss.alive){
              // 플레이어 주변 안전지대 확보 (반경 80px)
              let x, y, attempts = 0;
              do {
                x = rand(100, W-100); // 경계에서 더 멀리
                y = rand(100, H-100);
                attempts++;
              } while(Math.hypot(x - player.x, y - player.y) < 80 && attempts < 10);
              
              // 폭발 탄환들 (수 더 감소, 속도 감소)
              for(let j=0; j<3; j++){ // 4->3으로 추가 감소
                const a = j/3*TAU;
                spawnBullet({
                  x: x,
                  y: y,
                  vx: Math.cos(a)*150, // 속도 더 감소: 200->150
                  vy: Math.sin(a)*150,
                  r: 3, // 크기 더 감소: 4->3
                  dmg: 1.0, // 데미지 더 감소: 1.2->1.0
                  color: '#8B00FF',
                  hostile: true,
                  ttl: 2.0 // TTL 더 감소: 2.5->2.0
                });
              }
            }
          }, i*200); // 딜레이 더 증가: 150->200
        }
      }
      
      // 4. 보스 중심 스파이럴 (지속적) - 탄환 수 감소
      if(Math.floor(DC.t*2)%4===0 && chance(0.15)){ // 빈도 조정: 3->2, 3->4, 0.2->0.15
        const N=12; const speed=140 + DC.chaos*15; // 탄환 수 감소: 20->12, 속도 감소
        for(let i=0;i<N;i++){
          const a = i/N*TAU + DC.t*2;
          spawnBullet({
            x: b.x + Math.cos(a)*50,
            y: b.y + Math.sin(a)*50,
            vx: Math.cos(a)*speed,
            vy: Math.sin(a)*speed,
            r: 6,
            dmg: 2,
            color: '#9932CC',
            hostile: true,
            ttl: 4.0
          });
        }
      }
    }
  };

  // ===== 무기 구현 =====
  function handleWeaponFire(p, dt, wantsFire){
    const bw = p.weapon;
    
    // 플라즈마 캐논은 별도 처리 (fireCd 체크 우회)
    if(bw==='PLASMA'){
      if(wantsFire && !p.isCharging && p.fireCd <= 0) {
        p.isCharging = true;
        p.chargeTime = 0;
      }
      
      if(p.isCharging) {
        p.chargeTime += dt * 1.5; // Charge speed increased by 1.5x
        p.chargeTime = Math.min(6.0, p.chargeTime); // 최대 6초 충전 (2배 증가)
        
        // 충전 이펙트
        const chargeIntensity = p.chargeTime / 6.0;
        if(Math.random() < chargeIntensity * 0.8) {
          spawnPart({
            x: p.x + rand(-15, 15),
            y: p.y + rand(-15, 15),
            ttl: 0.2,
            color: `hsl(${180 + chargeIntensity * 60}, 100%, ${50 + chargeIntensity * 30}%)`,
            sz: rand(2, 4 + chargeIntensity * 3)
          });
        }
      }
      
      if(!wantsFire && p.isCharging) {
        // 발사!
        const chargeRatio = p.chargeTime / 4.0;
        const size = 6 + chargeRatio * 8; // 6~14
        const damage = (5.0 + chargeRatio * 10.0) * playerUp.dmg * 0.8; // 0.8배로 너프: 4.0~12.0배
        const speed = 500 * playerUp.projSpeed;
        const penetration = Math.floor(chargeRatio * 4); // 0~4 관통
        
        spawnBullet({
          x: p.x + Math.cos(p.aim) * 20,
          y: p.y + Math.sin(p.aim) * 20,
          vx: Math.cos(p.aim) * speed,
          vy: Math.sin(p.aim) * speed,
          r: size,
          dmg: damage,
          color: `hsl(${180 + chargeRatio * 60}, 100%, ${60 + chargeRatio * 20}%)`,
          hostile: false,
          ttl: 2.5,
          penetration: penetration,
          plasma: true
        });
        
        // 발사 이펙트
        for(let i=0; i<15; i++) {
          spawnPart({
            x: p.x,
            y: p.y,
            vx: Math.cos(p.aim + rand(-0.4, 0.4)) * rand(50, 200),
            vy: Math.sin(p.aim + rand(-0.4, 0.4)) * rand(50, 200),
            ttl: rand(0.3, 0.8),
            color: `hsl(${180 + chargeRatio * 60}, 100%, ${60 + chargeRatio * 20}%)`,
            sz: rand(3, 6)
          });
        }
        
        p.isCharging = false;
        p.chargeTime = 0;
        p.fireCd = 0.4 / playerUp.rof;
      }
      return; // 플라즈마는 여기서 종료
    }
    
    // 원거리 공용: 사격 (플라즈마 제외)
    if(wantsFire && p.fireCd<=0){
      if(bw==='LASER'){
        // 지속빔: 짧게 펄스 형태(성능상)
        const len=900, seg=22, dmg=1.4*playerUp.dmg; // Damage buffed from 0.8 to 1.4
        for(let i=0;i<seg;i++){
          const d=i/seg*len;
          const px = p.x + Math.cos(p.aim)*d;
          const py = p.y + Math.sin(p.aim)*d;
          const b = spawnBullet({x:px,y:py,vx:0,vy:0,r:6,dmg,color:'#49f3ff',hostile:false,ttl:0.08}); // TTL up
        }
        p.fireCd = 0.15/ playerUp.rof; // Cooldown up
        // 픽셀 스타일 레이저 이펙트
        for(let i=0;i<4;i++) spawnPart({x:p.x+Math.cos(p.aim)*20+rand(-3,3),y:p.y+Math.sin(p.aim)*20+rand(-3,3),ttl:0.1,color:'#49f3ff',sz:rand(3,6)});
      }
      else if(bw==='SHOTGUN'){
        const K=12, spread=0.22; // 탄환 수 2배 증가: 6->12
        const spd=380*playerUp.projSpeed, dmg=2.4*playerUp.dmg; // Damage buffed from 1.8 to 2.4
        for(let i=0;i<K;i++){
          const a=p.aim + rand(-spread,spread);
          spawnBullet({x:p.x+Math.cos(a)*16,y:p.y+Math.sin(a)*16,vx:Math.cos(a)*spd,vy:Math.sin(a)*spd,r:4,dmg,color:'#ff71ff',hostile:false,ttl:1.3}); // TTL increased for range buff
        }
        p.fireCd=0.55/ playerUp.rof; // Cooldown up
        // 픽셀 스타일 산탄 발사 이펙트
        for(let i=0;i<6;i++) spawnPart({x:p.x+Math.cos(p.aim)*12+rand(-4,4),y:p.y+Math.sin(p.aim)*12+rand(-4,4),ttl:0.15,color:'#ff71ff',sz:rand(2,5)});
      }
      else if(bw==='ROCKET'){
        // 로켓 재장전 중인지 확인
        if(p.rocketReloading) {
          return; // 재장전 중이면 발사 불가
        }
        
        // 로켓 탄창 시스템
        if(p.rocketAmmo <= 0) {
          // 탄창이 비어있으면 긴 재장전 시작
          p.rocketReloading = true;
          p.rocketReloadTime = p.rocketMaxReloadTime;
          return; // 이번 프레임에는 발사하지 않음
        }
        
        // 탄약 소모
        p.rocketAmmo--;
        
        // 마지막 탄환을 쏜 경우 자동으로 재장전 시작
        if(p.rocketAmmo <= 0) {
          p.rocketReloading = true;
          p.rocketReloadTime = p.rocketMaxReloadTime;
        }
        
        // 빠른 연사 속도 (1.5초 간격)
        p.fireCd = 1.5 / playerUp.rof;
        
        const a=p.aim, spd=300*playerUp.projSpeed; // Speed up
        spawnBullet({x:p.x+Math.cos(a)*18,y:p.y+Math.sin(a)*18,vx:Math.cos(a)*spd,vy:Math.sin(a)*spd,r:6,dmg:22.5*playerUp.dmg,color:'#ffd24a',hostile:false,ttl:2.4, explode:true}); // 3배 데미지: 7.5 * 3 = 22.5
        // 픽셀 스타일 로켓 발사 이펙트
        for(let i=0;i<8;i++) spawnPart({x:p.x+Math.cos(p.aim+Math.PI)*15+rand(-2,2),y:p.y+Math.sin(p.aim+Math.PI)*15+rand(-2,2),ttl:0.2,color:'#ffd24a',sz:rand(3,6)});
      }
      else if(bw==='MINIGUN'){
        p.fireCd = 0.08 / playerUp.rof;
        const a = p.aim + rand(-0.05,0.05);
        const spd = 800*playerUp.projSpeed;
        const dmg = 10*playerUp.dmg;
        const range = 1.3*playerUp.range; // 사거리 1.3배 증가
        spawnBullet({x:p.x,y:p.y,vx:Math.cos(a)*spd*1.1,vy:Math.sin(a)*spd*1.1,r:5,dmg:dmg*0.2,ttl:0.5*range,color:'#ffd24a',hostile:false}); // Damage nerfed from 0.25 to 0.15
      }
      else if(bw==='BOOMERANG'){
        p.fireCd = 1.2 / playerUp.rof;
        const speed = 400 * playerUp.projSpeed;
        const damage = 1.2 * playerUp.dmg; // 데미지 너프: 2.0 -> 1.2
        
        spawnBullet({
          x: p.x + Math.cos(p.aim) * 15,
          y: p.y + Math.sin(p.aim) * 15,
          vx: Math.cos(p.aim) * speed,
          vy: Math.sin(p.aim) * speed,
          r: 8,
          dmg: damage,
          color: '#00ff88',
          hostile: false,
          ttl: 4.0,
          boomerang: true,
          originX: p.x,
          originY: p.y,
          launched: now(),
          spinAngle: 0
        });
        
        // 부메랑 발사 이펙트
        for(let i=0; i<8; i++) {
          spawnPart({
            x: p.x,
            y: p.y,
            vx: Math.cos(p.aim + i*TAU/8) * 80,
            vy: Math.sin(p.aim + i*TAU/8) * 80,
            ttl: 0.4,
            color: '#00ff88',
            sz: rand(3, 5)
          });
        }
      }
      else if(bw==='SMG'){
        p.fireCd = 0.05 / playerUp.rof; // 매우 빠른 연사 (0.05초 간격)
        const a = p.aim + rand(-0.15, 0.15); // 심한 탄퍼짐 (0.08 -> 0.15)
        const spd = 650 * playerUp.projSpeed; // 빠른 탄속
        const dmg = 6 * playerUp.dmg; // 낮은 기본 데미지
        const range = 1.2 * playerUp.range; // 사거리 2배 증가 (0.6 -> 1.2)
        
        spawnBullet({
          x: p.x + Math.cos(a) * 10,
          y: p.y + Math.sin(a) * 10,
          vx: Math.cos(a) * spd,
          vy: Math.sin(a) * spd,
          r: 3, // 작은 탄환
          dmg: dmg * 0.35, // 최종 데미지: 매우 낮음
          ttl: 0.4 * range, // 사거리 2배 증가
          color: '#ffaa00',
          hostile: false
        });
        
        // SMG 발사 이펙트 (간단함)
        for(let i=0; i<2; i++) {
          spawnPart({
            x: p.x + Math.cos(p.aim) * 8 + rand(-2, 2),
            y: p.y + Math.sin(p.aim) * 8 + rand(-2, 2),
            ttl: 0.1,
            color: '#ffaa00',
            sz: rand(2, 4)
          });
        }
      }
      else if(bw==='SNIPER'){
        // 저격총 재장전 중인지 확인
        if(p.sniperReloading) {
          return; // 재장전 중이면 발사 불가
        }
        
        // 저격총 탄창 시스템
        if(p.sniperAmmo <= 0) {
          // 탄창이 비어있으면 긴 재장전 시작
          p.sniperReloading = true;
          p.sniperReloadTime = p.sniperMaxReloadTime;
          return; // 이번 프레임에는 발사하지 않음
        }
        
        // 탄약 소모
        p.sniperAmmo--;
        
        // 마지막 총알을 쏜 경우 자동으로 재장전 시작
        if(p.sniperAmmo <= 0) {
          p.sniperReloading = true;
          p.sniperReloadTime = p.sniperMaxReloadTime;
        }
        
        // 일반 발사 속도 (탄창 내 발사)
        p.fireCd = 1.8 / playerUp.rof; // 빠른 연사 (1.8초 간격으로 감소)
        const a = p.aim; // 정확한 조준
        const spd = 1200 * playerUp.projSpeed; // 매우 빠른 탄속
        const dmg = 65 * playerUp.dmg; // 1.3배 버프: 50->65
        const range = 2.5 * playerUp.range; // 긴 사정거리
        
        spawnBullet({
          x: p.x + Math.cos(a) * 25,
          y: p.y + Math.sin(a) * 25,
          vx: Math.cos(a) * spd,
          vy: Math.sin(a) * spd,
          r: 4,
          dmg: dmg * 0.8, // 최종 데미지: 52 (65*0.8, 1.3배 버프 적용)
          ttl: 1.5 * range, // 긴 사정거리
          color: '#ff4444',
          hostile: false,
          penetration: 2 // 관통력 추가
        });
        
        // 저격총 발사 이펙트 (강력함)
        for(let i=0; i<15; i++) {
          spawnPart({
            x: p.x + Math.cos(p.aim + Math.PI) * 20 + rand(-5, 5),
            y: p.y + Math.sin(p.aim + Math.PI) * 20 + rand(-5, 5),
            ttl: 0.3,
            color: '#ff4444',
            sz: rand(4, 8)
          });
        }
      }
      else if(bw==='DEBUG_CANNON'){
        // 디버그 캐논 - 극도로 강력한 무기
        p.fireCd = 0.02 / playerUp.rof; // 극도로 빠른 연사 (0.02초 간격)
        const a = p.aim; // 정확한 조준
        const spd = 2000 * playerUp.projSpeed; // 극도로 빠른 탄속
        const dmg = 20 * playerUp.dmg; // 극도로 높은 데미지 (보스 원킬 수준)
        const range = 5.0 * playerUp.range; // 극도로 긴 사정거리
        
        // 3발의 강력한 레이저 동시 발사
        for(let i = -1; i <= 1; i++) {
          const spread = i * 0.1; // 약간의 확산
          const adjustedAngle = a + spread;
          
          spawnBullet({
            x: p.x + Math.cos(adjustedAngle) * 30,
            y: p.y + Math.sin(adjustedAngle) * 30,
            vx: Math.cos(adjustedAngle) * spd,
            vy: Math.sin(adjustedAngle) * spd,
            r: 8, // 큰 탄환
            dmg: dmg * 2.0, // 극도로 높은 데미지 (500*2=1000)
            ttl: 3.0 * range, // 매우 긴 사정거리
            color: '#ff0000', // 빨간색 (위험한 느낌)
            hostile: false,
            penetration: 999, // 무한 관통
            debug: true // 디버그 탄환 표시
          });
        }
        
        // 강력한 디버그 발사 이펙트
        for(let i=0; i<25; i++) {
          spawnPart({
            x: p.x + Math.cos(p.aim) * 25 + rand(-10, 10),
            y: p.y + Math.sin(p.aim) * 25 + rand(-10, 10),
            vx: Math.cos(p.aim + rand(-0.3, 0.3)) * rand(100, 300),
            vy: Math.sin(p.aim + rand(-0.3, 0.3)) * rand(100, 300),
            ttl: rand(0.4, 0.8),
            color: '#ff0000',
            sz: rand(6, 12)
          });
        }
        
        // 후방 폭발 이펙트
        for(let i=0; i<15; i++) {
          spawnPart({
            x: p.x + Math.cos(p.aim + Math.PI) * 30 + rand(-15, 15),
            y: p.y + Math.sin(p.aim + Math.PI) * 30 + rand(-15, 15),
            vx: Math.cos(p.aim + Math.PI + rand(-0.5, 0.5)) * rand(150, 400),
            vy: Math.sin(p.aim + Math.PI + rand(-0.5, 0.5)) * rand(150, 400),
            ttl: rand(0.5, 1.0),
            color: '#ffaa00',
            sz: rand(8, 16)
          });
        }
      }
    }
  }

  // ===== 게임 루프 =====
  let lastT=now();
  let accFps=0, fps=0, fpsTick=0;

  let boss=null;

  function startRun(){
    // 초기화
    clearEntities();
    gameState=STATE.PLAY;
    stageIndex=0;
    totalTime=0;
    stageStartTime=0;
    cores=0;
    playerUp.dmg=1; playerUp.rof=1; playerUp.projSpeed=1; playerUp.range=1; playerUp.survivability=1; playerUp.special={};
    player = new Player();
    boss = new Boss(BOSSES[stageIndex]);
    stageStartTime=now();
    document.getElementById('bossHp').style.display='block';
    document.getElementById('playerHpLabel').textContent = Math.floor(player.hp);
    updateHpBar();
    hideStartMenu();
    loop();
  }

  function nextStage(){
    stageIndex++;
    if(stageIndex>=BOSSES.length){
      // 전 스테이지 클리어
      stageClearAll();
      return;
    }
    gameState = STATE.PLAY;
    portal = null;
    stageNote(`STAGE ${stageIndex+1}`);
    boss = new Boss(BOSSES[stageIndex]);
    updateHpBar();
  }

  function loop(){
    if(gameState===STATE.PLAY || gameState===STATE.STAGECLEAR){
      const t=now(); let dt=(t-lastT)/1000; lastT=t;
      dt=Math.min(0.033,dt);
      totalTime = (t-stageStartTime)/1000;

      update(dt);
      draw();

      requestAnimationFrame(loop);
    }else{
      // 일시정지 등 상태에서 타임스탬프 업데이트
      lastT=now();
    }
  }

  function update(dt){
    // 입력 이동/공격
    player?.update(dt);

    // 적탄 업데이트/충돌
    for(const b of bullets){
      if(!b.alive) continue;
      if(b.ring){ // 충격파형
        b.r += b.vr*dt;
        b.ttl -= dt;
      }else if(b.boomerang && !b.hostile){ // 부메랑
        const elapsed = (now() - b.launched) / 1000;
        b.spinAngle += dt * 15; // 회전 애니메이션
        
        if(elapsed < 1.5) {
          // 나가는 단계
          b.x += b.vx * dt;
          b.y += b.vy * dt;
        } else {
          // 돌아오는 단계
          const returnAngle = angleTo(b.x, b.y, b.originX, b.originY);
          const returnSpeed = 300 + (elapsed - 1.5) * 200; // 점점 빨라짐
          b.vx = Math.cos(returnAngle) * returnSpeed;
          b.vy = Math.sin(returnAngle) * returnSpeed;
          b.x += b.vx * dt;
          b.y += b.vy * dt;
          
          // 플레이어에게 복귀했는지 체크
          if(player && dist2(b.x, b.y, player.x, player.y) < 900) { // 30픽셀 반경
            b.alive = false;
            // 복귀 이펙트
            for(let i=0; i<6; i++) {
              spawnPart({
                x: b.x,
                y: b.y,
                vx: rand(-80, 80),
                vy: rand(-80, 80),
                ttl: 0.3,
                color: '#00ff88',
                sz: rand(2, 4)
              });
            }
          }
        }
        b.ttl -= dt;
      }else if(b.homing){
        const distToPlayer = Math.hypot(b.x - player.x, b.y - player.y);
        // 플레이어와 150픽셀 이내로 가까워지거나 이미 직진모드면 직진 모드 유지
        if(!b.straightMode && distToPlayer <= 150) {
          b.straightMode = true; // 직진모드 플래그 설정
        }
        
        if(!b.straightMode) {
          const a = angleTo(b.x,b.y, player.x,player.y);
          const currentAngle = Math.atan2(b.vy, b.vx);
          const turnRate = b.turnRate || 3.5;
          let angleDiff = a - currentAngle;
          // 각도 차이를 -π ~ π 범위로 정규화
          while(angleDiff > Math.PI) angleDiff -= 2*Math.PI;
          while(angleDiff < -Math.PI) angleDiff += 2*Math.PI;
          const newAngle = currentAngle + Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), turnRate * dt);
          b.vx = Math.cos(newAngle)*b.spd; 
          b.vy = Math.sin(newAngle)*b.spd;
        }
        // 직진 모드거나 가까우면 현재 방향 유지
        b.x+=b.vx*dt; b.y+=b.vy*dt; b.ttl-=dt;
      }else{
        b.x+=b.vx*dt; b.y+=b.vy*dt; b.ttl-=dt;
      }
      // 플레이어와 충돌(적탄)
      if(b.hostile && player?.alive){
        let hit=false;
        if(b.ring){
          // 원형 쉘 — 플레이어 중심 거리와 링 반지름 차이
          const d = Math.hypot(player.x-b.x, player.y-b.y);
          if(Math.abs(d-b.r) < (b.thick + player.r)) hit=true;
        }else{
          if(dist2(player.x,player.y,b.x,b.y) <= (player.r + b.r)*(player.r + b.r)) hit=true;
        }
        if(hit){
          b.alive=false;
          player.hit(b.dmg||1);
        }
      }
      // 보스와 플레이어탄 충돌
      if(!b.hostile && boss && boss.alive){
        if(b.laser){
          if(Math.hypot(boss.x-b.x,boss.y-b.y) <= b.r + boss.r) { boss.take(b.dmg||0.5); }
        }else{
          if(dist2(boss.x,boss.y,b.x,b.y) <= (boss.r + b.r)*(boss.r + b.r)){
            boss.take(b.dmg||1);
            
            // 플라즈마는 관통, 부메랑은 통과
            if(!b.plasma && !b.boomerang) {
              b.alive=false;
            } else if(b.plasma && b.penetration !== undefined) {
              b.penetration--;
              if(b.penetration < 0) b.alive = false;
              // 플라즈마 관통 이펙트
              for(let i=0; i<8; i++) {
                spawnPart({
                  x: b.x + rand(-10, 10),
                  y: b.y + rand(-10, 10),
                  ttl: rand(0.2, 0.4),
                  color: b.color,
                  sz: rand(3, 6)
                });
              }
            }
            
            if(b.explode){
              // 픽셀 스타일 폭발 이펙트
              for(let i=0;i<50;i++){
                const aa=Math.random()*TAU, sp=rand(80,280);
                const size = rand(2,8);
                const colors = ['#ffd24a', '#ff9b3b', '#ff71ff', '#ff3b5c'];
                const color = colors[Math.floor(Math.random()*colors.length)];
                spawnPart({
                 
                  x:b.x+rand(-5,5),
                  y:b.y+rand(-5,5),
                  vx:Math.cos(aa)*sp*0.6,
                  vy:Math.sin(aa)*sp*0.6,
                  sz:size,
                  ttl:rand(0.3,0.9),
                  color:color
                });
              }
              
              // 중심 폭발 코어
              for(let i=0;i<8;i++){
                spawnPart({
                  x:b.x,
                  y:b.y,
                  vx:rand(-50,50),
                  vy:rand(-50,50),
                  sz:rand(6,12),
                  ttl:0.4,
                  color:'#ffffff'
                });
              }
              
              // 폭발 범위 데미지
              if(dist2(b.x,b.y,boss.x,boss.y) < (100+boss.r)*(100+boss.r)){
                boss.take((b.dmg||1)*1.5);
              }
            }
          }
        }
      }
      // 화면 밖/수명 종료
      if(b.ttl<=0 || b.x<-60||b.x>W+60||b.y<-60||b.y>H+60) { b.alive=false; }
    }
    // 풀 정리
    for(let i=bullets.length-1;i>=0;i--) if(!bullets[i].alive) bulletPool.push(bullets.splice(i,1)[0]);

    // 플레이어 총알과 적 유도탄 충돌 처리
    for(let i=0; i<bullets.length; i++){
      const playerBullet = bullets[i];
      if(!playerBullet.alive || playerBullet.hostile) continue;
      
      for(let j=0; j<bullets.length; j++){
        const enemyBullet = bullets[j];
        if(!enemyBullet.alive || !enemyBullet.hostile || !enemyBullet.homing) continue;
        
        if(dist2(playerBullet.x, playerBullet.y, enemyBullet.x, enemyBullet.y) < (playerBullet.r + enemyBullet.r) * (playerBullet.r + enemyBullet.r)){
          // 부메랑과 플라즈마는 유도탄을 파괴하지만 계속 진행
          if(playerBullet.boomerang || playerBullet.plasma) {
            enemyBullet.alive = false;
            // 유도탄 파괴 이펙트만 생성
            for(let k=0; k<5; k++){
              spawnPart({
                x: enemyBullet.x + rand(-5, 5),
                y: enemyBullet.y + rand(-5, 5),
                ttl: rand(0.2, 0.4),
                color: enemyBullet.color,
                sz: rand(3, 6)
              });
            }
          } else {
            // 일반 총알은 서로 파괴
            playerBullet.alive = false;
            enemyBullet.alive = false;
            // 파괴 이펙트
            for(let k=0; k<5; k++){
              spawnPart({
                x: enemyBullet.x + rand(-5, 5),
                y: enemyBullet.y + rand(-5, 5),
                ttl: rand(0.2, 0.4),
                color: enemyBullet.color,
                sz: rand(3, 6)
              });
            }
          }
          break;
        }
      }
    }

    // 파티클
    for(const p of parts){
      p.ttl-=dt;
      if(p.vx) p.x += p.vx*dt;
      if(p.vy) p.y += p.vy*dt;
    }
    for(let i=parts.length-1;i>=0;i--) if(parts[i].ttl<=0){ partPool.push(parts.splice(i,1)[0]); }

    // 코어(경험치)
    for(const o of orbs){
      o.ttl-=dt;
      // 플레이어에게 끌림
      const a=angleTo(o.x,o.y, player.x,player.y);
      const s= 80 + (200*(1 - Math.min(1,Math.hypot(o.x-player.x,o.y-player.y)/300)));
      o.vx += Math.cos(a)*s*dt*0.6;
      o.vy += Math.sin(a)*s*dt*0.6;
      o.vx*=0.96; o.vy*=0.96;
      o.x+=o.vx*dt; o.y+=o.vy*dt;
      if(dist2(o.x,o.y,player.x,player.y) < (o.r+player.r)*(o.r+player.r)){
        cores += o.amt;
        o.alive=false;
      }
    }
    for(let i=orbs.length-1;i>=0;i--) if(!orbs[i].alive || orbs[i].ttl<=0) orbs.splice(i,1);

    // 보스
    if(boss && boss.alive) boss.update(dt);
    updateHpBar();

    // 포탈
    if (gameState === STATE.STAGECLEAR && portal) {
      portal.t += dt;
      if (player && dist2(player.x, player.y, portal.x, portal.y) < (player.r + portal.r) * (player.r + portal.r)) {
        nextStage();
      }
    }

    // UI 라벨
    document.getElementById('coreLabel').textContent = cores|0;
    document.getElementById('stageLabel').textContent = (stageIndex+1);

    // FPS
    if(settings.showFps){
      accFps++; fpsTick+=dt;
      if(fpsTick>=1){ fps=accFps; accFps=0; fpsTick=0; }
    }
  }

  function draw(){
    // 배경 네트워크
    ctx.clearRect(0,0,W,H);
    drawGrid();

    // 파티클/오브젝트/탄
    for(const o of orbs){
      drawPixelOrb(o.x, o.y, o.r, settings.colorBlind?'#00e5ff':'#49f3ff');
    }
    
    // 보스
    boss?.draw(ctx);
    
    // VOID_REAPER 특수 이펙트 렌더링
    if(boss && boss.cfg.id === 'VOID_REAPER') {
      // 그림자 벽 렌더링
      if(boss._sw && boss._sw.walls) {
        for(const wall of boss._sw.walls) {
          if(wall.phase === 'warning') {
            // 경고 단계 - 깜빡이는 반투명 벽
            ctx.save();
            ctx.globalAlpha = 0.3 + Math.sin(now() * 0.01) * 0.2;
            ctx.fillStyle = '#ff3b5c';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ff3b5c';
            ctx.fillRect(wall.x - wall.width/2, wall.y - wall.height/2, wall.width, wall.height);
            
            // 틈 표시 (초록색)
            ctx.fillStyle = '#00ff88';
            ctx.shadowColor = '#00ff88';
            for(const gap of wall.gaps) {
              ctx.fillRect(gap.x - gap.width/2, gap.y - gap.height/2, gap.width, gap.height);
            }
            ctx.restore();
          } else if(wall.phase === 'moving') {
            // 이동 단계 - 단단한 벽
            ctx.save();
            ctx.fillStyle = wall.color;
            ctx.shadowBlur = 10;
            ctx.shadowColor = wall.color;
            ctx.fillRect(wall.x - wall.width/2, wall.y - wall.height/2, wall.width, wall.height);
            
            // 틈은 투명하게 (검은색으로 뚫림)
            ctx.globalCompositeOperation = 'destination-out';
            for(const gap of wall.gaps) {
              ctx.fillRect(gap.x - gap.width/2, gap.y - gap.height/2, gap.width, gap.height);
            }
            ctx.restore();
          }
        }
      }
      
      // 왜곡 필드 렌더링
      if(boss._sd && boss._sd.distortionFields) {
        for(const field of boss._sd.distortionFields) {
          ctx.save();
          ctx.globalAlpha = field.intensity * 0.4;
          
          // 왜곡 필드 시각 효과 (동심원)
          for(let i = 3; i > 0; i--) {
            ctx.strokeStyle = '#8B00FF';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#8B00FF';
            ctx.beginPath();
            ctx.arc(field.x, field.y, field.radius * (i/3) * field.intensity, 0, TAU);
            ctx.stroke();
          }
          ctx.restore();
        }
      }
      
      // 블랙홀 렌더링 (그래픽 모드에 따라 조절)
      if(boss._dc && boss._dc.blackholes) {
        for(const bh of boss._dc.blackholes) {
          ctx.save();
          
          const intensity = getEffectIntensity();
          const time = now() * 0.001;
          const pulse = Math.sin(time * 3) * 0.5 + 0.5;
          const rotation = time * 2;
          
          if(settings.graphicsMode === 'performance') {
            // 성능 모드: 단순한 블랙홀
            ctx.fillStyle = getColorBlindSafeColor('#000000', 'blackhole');
            ctx.shadowBlur = 10;
            ctx.shadowColor = getColorBlindSafeColor('#8B00FF', 'blackhole');
            ctx.beginPath();
            ctx.arc(bh.x, bh.y, bh.radius * 0.4, 0, TAU);
            ctx.fill();
            
            // 단순한 링
            ctx.strokeStyle = getColorBlindSafeColor('#8B00FF', 'blackhole');
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(bh.x, bh.y, bh.radius * 0.7, 0, TAU);
            ctx.stroke();
            
          } else if(settings.graphicsMode === 'simple') {
            // 단순 모드: 기본적인 블랙홀 + 몇 개 링
            const ringCount = 4;
            ctx.globalAlpha = 0.4;
            for(let i = 1; i <= ringCount; i++) {
              const radiusMultiplier = 0.4 + i * 0.15;
              const alpha = (ringCount - i) / ringCount * 0.6;
              ctx.globalAlpha = alpha;
              
              ctx.strokeStyle = getColorBlindSafeColor('#8B00FF', 'blackhole');
              ctx.lineWidth = 2;
              ctx.shadowBlur = 8;
              ctx.shadowColor = ctx.strokeStyle;
              
              ctx.beginPath();
              ctx.arc(bh.x, bh.y, bh.radius * radiusMultiplier, 0, TAU);
              ctx.stroke();
            }
            
            // 중심부
            const gradient = ctx.createRadialGradient(bh.x, bh.y, 0, bh.x, bh.y, bh.radius * 0.4);
            gradient.addColorStop(0, '#000000');
            gradient.addColorStop(1, getColorBlindSafeColor('#8B00FF', 'blackhole'));
            
            ctx.fillStyle = gradient;
            ctx.shadowBlur = 20;
            ctx.shadowColor = getColorBlindSafeColor('#8B00FF', 'blackhole');
            ctx.beginPath();
            ctx.arc(bh.x, bh.y, bh.radius * 0.4, 0, TAU);
            ctx.fill();
            
          } else {
            // 화려함 모드: 모든 효과 (기존 코드 유지하되 색약 보조 적용)
            // 배경 왜곡 링들 (더 많고 화려하게)
            ctx.globalAlpha = 0.4;
            for(let i = 1; i <= 8; i++) {
              const radiusMultiplier = 0.4 + i * 0.15;
              const alpha = (8 - i) / 8 * 0.6;
              ctx.globalAlpha = alpha;
              
              // 다양한 색상의 링 (색약 보조 적용)
              const colors = [
                getColorBlindSafeColor('#8B00FF', 'blackhole'), 
                getColorBlindSafeColor('#4B0082', 'blackhole'), 
                getColorBlindSafeColor('#9400D3', 'blackhole'), 
                getColorBlindSafeColor('#FF00FF', 'blackhole'), 
                getColorBlindSafeColor('#DA70D6', 'blackhole')
              ];
              ctx.strokeStyle = colors[i % colors.length];
              ctx.lineWidth = 3 + pulse * 2;
              ctx.shadowBlur = 15 + pulse * 10;
              ctx.shadowColor = ctx.strokeStyle;
              ctx.setLineDash([5, 10]);
              ctx.lineDashOffset = rotation * (i % 2 === 0 ? 1 : -1) * 20;
              
              ctx.beginPath();
              ctx.arc(bh.x, bh.y, bh.radius * radiusMultiplier, 0, TAU);
              ctx.stroke();
            }
            
            // 회전하는 나선 효과
            ctx.setLineDash([]);
            ctx.globalAlpha = 0.7;
            ctx.lineWidth = 2;
            for(let spiral = 0; spiral < 3; spiral++) {
              const spiralColors = [
                getColorBlindSafeColor('#8B00FF', 'blackhole'), 
                getColorBlindSafeColor('#FF00FF', 'blackhole'), 
                getColorBlindSafeColor('#4B0082', 'blackhole')
              ];
              ctx.strokeStyle = spiralColors[spiral];
              ctx.shadowBlur = 20;
              ctx.shadowColor = ctx.strokeStyle;
              ctx.beginPath();
              
              const spiralOffset = spiral * TAU / 3 + rotation;
              for(let angle = 0; angle < TAU * 3; angle += 0.1) {
                const r = bh.radius * 0.3 + (angle / (TAU * 3)) * bh.radius * 0.4;
                const x = bh.x + Math.cos(angle + spiralOffset) * r;
                const y = bh.y + Math.sin(angle + spiralOffset) * r;
                
                if(angle === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
              }
              ctx.stroke();
            }
            
            // 블랙홀 중심부 (더 강렬하게)
            const gradient = ctx.createRadialGradient(bh.x, bh.y, 0, bh.x, bh.y, bh.radius * 0.4);
            gradient.addColorStop(0, '#000000');
            gradient.addColorStop(0.7, '#1a0033');
            gradient.addColorStop(1, getColorBlindSafeColor('#8B00FF', 'blackhole'));
            
            ctx.fillStyle = gradient;
            ctx.shadowBlur = 30 + pulse * 15;
            ctx.shadowColor = getColorBlindSafeColor('#8B00FF', 'blackhole');
            ctx.beginPath();
            ctx.arc(bh.x, bh.y, bh.radius * 0.4, 0, TAU);
            ctx.fill();
            
            // 중심 핵 (밝은 점)
            ctx.fillStyle = '#FFFFFF';
            ctx.shadowBlur = 40;
            ctx.shadowColor = getColorBlindSafeColor('#FF00FF', 'blackhole');
            ctx.beginPath();
            ctx.arc(bh.x, bh.y, 3 + pulse * 2, 0, TAU);
            ctx.fill();
            
            // 주변 파티클 효과 (번개같은 선들)
            ctx.globalAlpha = 0.8;
            ctx.lineWidth = 1;
            for(let i = 0; i < 12; i++) {
              const angle = (i / 12) * TAU + rotation;
              const length = bh.radius * (0.5 + pulse * 0.3);
              
              const lightningColors = [
                getColorBlindSafeColor('#8B00FF', 'blackhole'), 
                getColorBlindSafeColor('#FF00FF', 'blackhole'), 
                getColorBlindSafeColor('#DA70D6', 'blackhole')
              ];
              ctx.strokeStyle = lightningColors[i % 3];
              ctx.shadowBlur = 15;
              ctx.shadowColor = ctx.strokeStyle;
              
              ctx.beginPath();
              ctx.moveTo(bh.x + Math.cos(angle) * bh.radius * 0.3, 
                        bh.y + Math.sin(angle) * bh.radius * 0.3);
              
              // 지그재그 라인
              for(let j = 1; j <= 5; j++) {
                const progress = j / 5;
                const zigzag = Math.sin(progress * TAU * 2) * 15;
                const perpAngle = angle + Math.PI / 2;
                const x = bh.x + Math.cos(angle) * length * progress + 
                         Math.cos(perpAngle) * zigzag;
                const y = bh.y + Math.sin(angle) * length * progress + 
                         Math.sin(perpAngle) * zigzag;
                ctx.lineTo(x, y);
              }
              ctx.stroke();
            }
          } // 화려함 모드 끝
          
          ctx.restore();
        }
      }
      
      // 차원 균열 렌더링
      if(boss._dc && boss._dc.rifts) {
        for(const rift of boss._dc.rifts) {
          ctx.save();
          
          // 균열 라인
          ctx.strokeStyle = '#4B0082';
          ctx.lineWidth = rift.width;
          ctx.shadowBlur = 12;
          ctx.shadowColor = '#4B0082';
          ctx.lineCap = 'round';
          
          const startX = rift.x - Math.cos(rift.angle) * rift.length/2;
          const startY = rift.y - Math.sin(rift.angle) * rift.length/2;
          const endX = rift.x + Math.cos(rift.angle) * rift.length/2;
          const endY = rift.y + Math.sin(rift.angle) * rift.length/2;
          
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(endX, endY);
          ctx.stroke();
          
          // 균열 중심 빛
          ctx.strokeStyle = '#8B00FF';
          ctx.lineWidth = rift.width * 0.3;
          ctx.shadowBlur = 8;
          ctx.shadowColor = '#8B00FF';
          ctx.stroke();
          
          ctx.restore();
        }
      }
    }

    // 포탈
    if (portal) {
      drawPixelPortal(portal.x, portal.y, portal.r, portal.t);
    }

    // 적탄
    for(const b of bullets){
      if(!b.alive) continue;
      if(b.ring){
        ctx.save();
        ctx.strokeStyle=b.color||'#49f3ff';
        ctx.lineWidth=b.thick||6;
        ctx.shadowBlur = 8;
        ctx.shadowColor = b.color||'#49f3ff';
        ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,TAU); ctx.stroke();
        ctx.restore();
      }else if(b.boomerang){
        // 부메랑 특별 렌더링
        ctx.save();
        ctx.translate(b.x, b.y);
        ctx.rotate(b.spinAngle || 0);
        ctx.fillStyle = b.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = b.color;
        // 부메랑 모양 (V자)
        ctx.fillRect(-b.r, -2, b.r*2, 4);
        ctx.fillRect(-2, -b.r, 4, b.r*2);
        ctx.restore();
      }else if(b.plasma){
        // 플라즈마 특별 렌더링
        ctx.save();
        ctx.fillStyle = b.color;
        ctx.shadowBlur = 15;
        ctx.shadowColor = b.color;
        ctx.fillRect(b.x - b.r, b.y - b.r, b.r*2, b.r*2);
        // 내부 코어
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(b.x - b.r*0.4, b.y - b.r*0.4, b.r*0.8, b.r*0.8);
        ctx.restore();
      }else if(b.debug){
        // 디버그 탄환 특별 렌더링
        ctx.save();
        
        // 강력한 글로우 이펙트
        ctx.shadowBlur = 25;
        ctx.shadowColor = b.color;
        
        // 외부 링
        ctx.strokeStyle = b.color;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r + 3, 0, TAU);
        ctx.stroke();
        
        // 내부 코어
        ctx.fillStyle = b.color;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, TAU);
        ctx.fill();
        
        // 중심 하이라이트
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r * 0.4, 0, TAU);
        ctx.fill();
        
        // 회전하는 외부 링
        const time = now() * 0.01;
        ctx.strokeStyle = '#ffff00';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.lineDashOffset = time * 10;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r + 6, 0, TAU);
        ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.restore();
      }else{
        drawPixelBullet(b.x, b.y, b.r, b.color||'#49f3ff', !b.hostile);
      }
    }
    
    // 플레이어
    player?.draw(ctx);

    // 파티클
    for(const p of parts){
      drawPixelParticle(p.x, p.y, p.sz, p.color||'#fff', p.ttl);
    }

    // 대쉬 쿨다운 표시
    if(player && gameState === STATE.PLAY) {
      const dashRatio = 1 - (player.dashCd / player.dashCooldown);
      const barWidth = 60;
      const barHeight = 6;
      const barX = W - barWidth - 20;
      const barY = 50;
      
      ctx.save();
      // 배경
      ctx.fillStyle = '#333333';
      ctx.fillRect(barX, barY, barWidth, barHeight);
      // 진행도
      ctx.fillStyle = dashRatio >= 1 ? '#00ff88' : '#666666';
      ctx.fillRect(barX, barY, barWidth * dashRatio, barHeight);
      // 테두리
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 1;
      ctx.strokeRect(barX, barY, barWidth, barHeight);
      // 라벨
      ctx.fillStyle = '#ffffff';
      ctx.font = '12px monospace';
      ctx.fillText('DASH', barX, barY - 2);
      ctx.restore();
    }

    // 디버그
    if(settings.showFps){
      ctx.fillStyle='#9ff'; ctx.fillText(`${fps} fps`, 10, 16);
    }
    
    // 디버그 모드 표시
    if(settings.debugMode){
      ctx.fillStyle='#ff0000'; 
      ctx.font='16px monospace';
      ctx.fillText('DEBUG MODE - INVINCIBLE', 10, 40);
      ctx.font='12px monospace'; // 폰트 복원
    }
    
    // 저격총 탄약/재장전 표시
    if(player && player.weapon === 'SNIPER') {
      const dashBarX = W - 80; // 대쉬 바 위치 기준
      const dashBarY = 50;
      
      ctx.save();
      
      if(player.sniperReloading) {
        // 재장전 중 - 로딩 바 표시
        const reloadRatio = 1 - (player.sniperReloadTime / player.sniperMaxReloadTime);
        const barWidth = 60;
        const barHeight = 6;
        const barX = dashBarX - barWidth - 15;
        const barY = dashBarY;
        
        // 배경
        ctx.fillStyle = '#333333';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        // 진행도
        ctx.fillStyle = reloadRatio >= 1 ? '#ffaa00' : '#ff6666';
        ctx.fillRect(barX, barY, barWidth * reloadRatio, barHeight);
        // 테두리
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, barWidth, barHeight);
        // 라벨
        ctx.fillStyle = '#ffffff';
        ctx.font = '10px monospace';
        ctx.fillText('RELOAD', barX, barY - 2);
      } else {
        // 일반 상태 - 탄약 개수 표시
        const bulletSize = 6;
        const bulletSpacing = 10;
        const startX = dashBarX - (player.sniperMaxAmmo * bulletSpacing) - 15; // 대쉬 바 왼쪽에 위치
        const startY = dashBarY + 3; // 대쉬 바와 같은 높이
        
        for(let i = 0; i < player.sniperMaxAmmo; i++) {
          const x = startX + i * bulletSpacing;
          const y = startY;
          
          if(i < player.sniperAmmo) {
            // 남은 탄약 - 밝은 색
            ctx.fillStyle = '#ffaa00';
          } else {
            // 사용된 탄약 - 어두운 색
            ctx.fillStyle = '#333333';
          }
          
          // 총알 모양 그리기 (작은 원형)
          ctx.beginPath();
          ctx.arc(x, y, bulletSize/2, 0, Math.PI * 2);
          ctx.fill();
          
          // 총알 테두리
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.stroke();
        }
        
        // 라벨
        ctx.fillStyle = '#ffffff';
        ctx.font = '10px monospace';
        ctx.fillText('AMMO', startX - 5, dashBarY - 2);
      }
      ctx.restore();
    }
    
    // 로켓 탄약/재장전 표시
    if(player && player.weapon === 'ROCKET') {
      const dashBarX = W - 80; // 대쉬 바 위치 기준
      const dashBarY = 50;
      
      ctx.save();
      
      if(player.rocketReloading) {
        // 재장전 중 - 로딩 바 표시
        const reloadRatio = 1 - (player.rocketReloadTime / player.rocketMaxReloadTime);
        const barWidth = 60;
        const barHeight = 6;
        const barX = dashBarX - barWidth - 15;
        const barY = dashBarY;
        
        // 배경
        ctx.fillStyle = '#333333';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        // 진행도
        ctx.fillStyle = reloadRatio >= 1 ? '#ffd24a' : '#ff6666';
        ctx.fillRect(barX, barY, barWidth * reloadRatio, barHeight);
        // 테두리
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, barWidth, barHeight);
        // 라벨
        ctx.fillStyle = '#ffffff';
        ctx.font = '10px monospace';
        ctx.fillText('RELOAD', barX, barY - 2);
      } else {
        // 일반 상태 - 탄약 개수 표시
        const rocketSize = 8; // 로켓은 조금 더 크게
        const rocketSpacing = 12;
        const startX = dashBarX - (player.rocketMaxAmmo * rocketSpacing) - 15; // 대쉬 바 왼쪽에 위치
        const startY = dashBarY + 3; // 대쉬 바와 같은 높이
        
        for(let i = 0; i < player.rocketMaxAmmo; i++) {
          const x = startX + i * rocketSpacing;
          const y = startY;
          
          if(i < player.rocketAmmo) {
            // 남은 탄약 - 로켓 색상
            ctx.fillStyle = '#ffd24a';
          } else {
            // 사용된 탄약 - 어두운 색
            ctx.fillStyle = '#333333';
          }
          
          // 로켓 모양 그리기 (둥근 사각형)
          ctx.beginPath();
          ctx.roundRect(x - rocketSize/3, y - rocketSize/2, rocketSize/1.5, rocketSize, 2);
          ctx.fill();
          
          // 로켓 테두리
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.stroke();
        }
        
        // 라벨
        ctx.fillStyle = '#ffffff';
        ctx.font = '10px monospace';
        ctx.fillText('ROCKETS', startX - 8, dashBarY - 2);
      }
      ctx.restore();
    }
    
    // 디버그 무기 표시
    if(player && player.weapon === 'DEBUG_CANNON' && settings.debugMode) {
      const dashBarX = W - 80; // 대쉬 바 위치 기준
      const dashBarY = 50;
      
      ctx.save();
      
      // 디버그 무기 상태 표시
      const barWidth = 100;
      const barHeight = 8;
      const barX = dashBarX - barWidth - 15;
      const barY = dashBarY + 20; // 대쉬 바 아래에 위치
      
      // 깜빡이는 배경
      const flashIntensity = Math.sin(now() * 0.01) * 0.3 + 0.7;
      ctx.fillStyle = `rgba(255, 0, 0, ${flashIntensity * 0.3})`;
      ctx.fillRect(barX - 5, barY - 5, barWidth + 10, barHeight + 10);
      
      // 메인 바
      ctx.fillStyle = '#ff0000';
      ctx.fillRect(barX, barY, barWidth, barHeight);
      
      // 내부 펄스 효과
      const pulseIntensity = Math.sin(now() * 0.02) * 0.5 + 0.5;
      ctx.fillStyle = `rgba(255, 255, 0, ${pulseIntensity})`;
      ctx.fillRect(barX + 2, barY + 2, (barWidth - 4) * pulseIntensity, barHeight - 4);
      
      // 테두리
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      ctx.strokeRect(barX, barY, barWidth, barHeight);
      
      // 경고 라벨
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 10px monospace';
      ctx.fillText('⚠️ DEBUG WEAPON ⚠️', barX - 10, barY - 8);
      
      // 화력 표시
      ctx.fillStyle = '#ffff00';
      ctx.font = '8px monospace';
      ctx.fillText('POWER: ∞', barX + barWidth + 5, barY + 6);
      
      ctx.restore();
    }
  }



 function drawGrid(){
    const t = now()*0.0005;
    ctx.save();
    
    // 픽셀 스타일 네온 그리드
    ctx.strokeStyle='rgba(73,243,255,0.12)';
    ctx.lineWidth=1;
    ctx.shadowBlur = 3;
    ctx.shadowColor = 'rgba(73,243,255,0.3)';
    
    // 수직선들
    for(let x=40; x<W; x+=40){
      const offset = Math.sin((x*0.01)+t*4)*3;
      ctx.beginPath();
      ctx.moveTo(x + offset, 80);
      ctx.lineTo(x + offset, H);
      ctx.stroke();
    }
    
    // 수평선들
    for(let y=80; y<H; y+=40){
      const offset = Math.sin((y*0.01)+t*5)*2;
      ctx.beginPath();
      ctx.moveTo(40, y + offset);
      ctx.lineTo(W, y + offset);
      ctx.stroke();
    }
    
    // 픽셀 도트들 (교차점에)
    ctx.fillStyle='rgba(255,113,255,0.15)';
    ctx.shadowBlur = 2;
    ctx.shadowColor = 'rgba(255,113,255,0.5)';
    for(let x=40; x<W; x+=120){
      for(let y=80; y<H; y+=120){
        const dotOffset = Math.sin(t*6 + x*0.01 + y*0.01)*2;
        ctx.fillRect(x + dotOffset - 1, y + dotOffset - 1, 2, 2);
      }
    }
    
    ctx.restore();
  }
  function neonCircle(x,y,r,color){
    ctx.save();
    ctx.shadowBlur=12; ctx.shadowColor=color; ctx.fillStyle=color;
    ctx.beginPath(); ctx.arc(x,y,r,0,TAU); ctx.fill();
    ctx.shadowBlur=0; ctx.restore();
  }

  // ===== 픽셀 아트 스타일 그래픽 함수들 =====
  function drawPixelSquare(x, y, size, color) {
    ctx.fillStyle = color;
    ctx.fillRect(Math.floor(x - size/2), Math.floor(y - size/2), size, size);
  }

  function drawPixelPlayer(x, y, r, aim) {
    const pixelSize = 3;
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(aim);
    
    // 플레이어 몸체 (십자 모양)
    ctx.fillStyle = '#49f3ff';
    ctx.shadowBlur = 8;
    ctx.shadowColor = '#49f3ff';
    
    // 중앙 코어
    ctx.fillRect(-6, -6, 12, 12);
    // 팔 부분
    ctx.fillRect(-12, -3, 6, 6);
    ctx.fillRect(6, -3, 6, 6);
    ctx.fillRect(-3, -12, 6, 6);
    ctx.fillRect(-3, 6, 6, 6);
    
    // 무기 표시
    ctx.fillStyle = '#ff71ff';
    ctx.fillRect(12, -2, 8, 4); // 무기
    
    ctx.restore();
  }

  function drawPixelBoss(x, y, r, color, phase) {
    const pixelSize = 4;
    const time = now() * 0.001;
    ctx.save();
    ctx.translate(x, y);
    
    // 보스 배경 글로우 - 자연스러운 원형 그라데이션
    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, r * 1.8);
    gradient.addColorStop(0, color + '44');
    gradient.addColorStop(0.3, color + '22');
    gradient.addColorStop(0.6, color + '11');
    gradient.addColorStop(1, color + '00');
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(0, 0, r * 1.8, 0, TAU);
    ctx.fill();
    
    // 추가 펄스 글로우 효과
    const pulseIntensity = Math.sin(time * 3) * 0.3 + 0.7;
    const pulseGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, r * 1.2 * pulseIntensity);
    pulseGradient.addColorStop(0, color + '33');
    pulseGradient.addColorStop(0.5, color + '11');
    pulseGradient.addColorStop(1, color + '00');
    
    ctx.fillStyle = pulseGradient;
    ctx.beginPath();
    ctx.arc(0, 0, r * 1.2 * pulseIntensity, 0, TAU);
    ctx.fill();
    
    // 보스 중앙 코어 - 더 크고 화려하게
    ctx.fillStyle = color;
    ctx.shadowBlur = 20;
    ctx.shadowColor = color;
    
    const coreSize = 28;
    ctx.fillRect(-coreSize/2, -coreSize/2, coreSize, coreSize);
    
    // 코어 내부 디테일
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(-8, -8, 16, 16);
    ctx.fillStyle = color;
    ctx.fillRect(-4, -4, 8, 8);
    
    // 페이즈별 복잡한 디테일
    if(phase === 0) { // 링 패턴 - 회전하는 링들
      ctx.fillStyle = color;
      // 외부 링
      for(let i = 0; i < 12; i++) {
        const angle = (i / 12) * TAU + time * 2;
        const px = Math.cos(angle) * 32;
        const py = Math.sin(angle) * 32;
        ctx.fillRect(px - 4, py - 4, 8, 8);
      }
      // 중간 링 (반대 방향)
      ctx.fillStyle = '#00e5ff';
      for(let i = 0; i < 8; i++) {
        const angle = (i / 8) * TAU - time * 1.5;
        const px = Math.cos(angle) * 22;
        const py = Math.sin(angle) * 22;
        ctx.fillRect(px - 3, py - 3, 6, 6);
      }
    } else if(phase === 1) { // 스파이럴 패턴 - 회전 암들
      // 주요 암들
      for(let arm = 0; arm < 4; arm++) {
        ctx.fillStyle = arm % 2 ? color : '#ff71ff';
        const baseAngle = (arm / 4) * TAU + time * 1.2;
        for(let seg = 1; seg <= 4; seg++) {
          const px = Math.cos(baseAngle) * (seg * 8);
          const py = Math.sin(baseAngle) * (seg * 8);
          const size = 7 - seg;
          ctx.fillRect(px - size/2, py - size/2, size, size);
        }
      }
      // 보조 암들
      ctx.fillStyle = '#ffd24a';
      for(let i = 0; i < 6; i++) {
        const angle = (i / 6) * TAU + time * 0.8;
        const px = Math.cos(angle) * 18;
        const py = Math.sin(angle) * 18;
        ctx.fillRect(px - 2, py - 2, 4, 4);
      }
    } else { // 레이저 패턴 - 충전 효과
      // 레이저 포트들
      ctx.fillStyle = '#ff3b5c';
      const ports = [
        {x: 0, y: -38, w: 6, h: 18},
        {x: 0, y: 38, w: 6, h: 18},
        {x: -38, y: 0, w: 18, h: 6},
        {x: 38, y: 0, w: 18, h: 6}
      ];
      
      for(const port of ports) {
        ctx.fillRect(port.x - port.w/2, port.y - port.h/2, port.w, port.h);
        // 충전 이펙트
        ctx.fillStyle = '#ffffff';
        const charge = Math.sin(time * 8) * 0.5 + 0.5;
        const chargeSize = port.w * charge * 0.6;
        ctx.fillRect(port.x - chargeSize/2, port.y - chargeSize/2, chargeSize, chargeSize);
        ctx.fillStyle = '#ff3b5c';
      }
      
      // 중앙에서 뻗어나가는 에너지 라인
      ctx.strokeStyle = '#ff3b5c';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for(let i = 0; i < 8; i++) {
        const angle = (i / 8) * TAU;
        const len = 15 + Math.sin(time * 6 + i) * 8;
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(angle) * len, Math.sin(angle) * len);
      }
      ctx.stroke();
    }
    
    // 보스 테두리 강조
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.shadowBlur = 15;
    ctx.shadowColor = color;
    ctx.strokeRect(-coreSize/2 - 2, -coreSize/2 - 2, coreSize + 4, coreSize + 4);
    
    ctx.restore();
  }

  function drawPixelBullet(x, y, r, color, isPlayer = false) {
    const pixelSize = Math.max(2, Math.floor(r * 0.8));
    ctx.save();
    
    if(isPlayer) {
      // 플레이어 탄환 - 더 밝고 선명
      ctx.fillStyle = color;
      ctx.shadowBlur = 6;
      ctx.shadowColor = color;
      ctx.fillRect(Math.floor(x - pixelSize/2), Math.floor(y - pixelSize/2), pixelSize, pixelSize);
      
      // 내부 코어
      const coreSize = Math.max(1, pixelSize - 2);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(Math.floor(x - coreSize/2), Math.floor(y - coreSize/2), coreSize, coreSize);
    } else {
      // 적 탄환 - 위험하고 다양한 모양
      ctx.fillStyle = color;
      ctx.shadowBlur = 8;
      ctx.shadowColor = color;
      
      const halfSize = pixelSize / 2;
      
      // 색상에 따라 다른 모양
      if(color.includes('#ff3b5c') || color.includes('#ff71ff')) {
        // 빨강/마젠타 계열 - 스파이크 다이아몬드
        ctx.beginPath();
        ctx.moveTo(x, y - halfSize * 1.3);
        ctx.lineTo(x + halfSize * 0.7, y - halfSize * 0.3);
        ctx.lineTo(x + halfSize * 1.3, y);
        ctx.lineTo(x + halfSize * 0.7, y + halfSize * 0.3);
        ctx.lineTo(x, y + halfSize * 1.3);
        ctx.lineTo(x - halfSize * 0.7, y + halfSize * 0.3);
        ctx.lineTo(x - halfSize * 1.3, y);
        ctx.lineTo(x - halfSize * 0.7, y - halfSize * 0.3);
        ctx.closePath();
        ctx.fill();
      } else if(color.includes('#00e5ff') || color.includes('#49f3ff')) {
        // 청록 계열 - 십자 모양
        ctx.fillRect(x - halfSize * 1.2, y - halfSize * 0.4, halfSize * 2.4, halfSize * 0.8);
        ctx.fillRect(x - halfSize * 0.4, y - halfSize * 1.2, halfSize * 0.8, halfSize * 2.4);
      } else if(color.includes('#ffd24a')) {
        // 노란색 - 별 모양
        ctx.beginPath();
        for(let i = 0; i < 8; i++) {
          const angle = (i * Math.PI) / 4;
          const radius = (i % 2 === 0) ? halfSize * 1.2 : halfSize * 0.6;
          const px = x + Math.cos(angle) * radius;
          const py = y + Math.sin(angle) * radius;
          if(i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
      } else {
        // 기본 - 다이아몬드 모양
        ctx.beginPath();
        ctx.moveTo(x, y - halfSize);
        ctx.lineTo(x + halfSize, y);
        ctx.lineTo(x, y + halfSize);
        ctx.lineTo(x - halfSize, y);
        ctx.closePath();
        ctx.fill();
      }
      
      // 내부 어두운 코어 추가
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = '#000000';
      const coreSize = Math.max(1, pixelSize * 0.3);
      ctx.fillRect(Math.floor(x - coreSize/2), Math.floor(y - coreSize/2), coreSize, coreSize);
    }
    
    ctx.restore();
  }

  function drawPixelParticle(x, y, size, color, ttl) {
    const alpha = Math.min(1, ttl * 3);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = color;
    ctx.shadowBlur = 4;
    ctx.shadowColor = color;
    
    const pixelSize = Math.max(1, Math.floor(size));
    ctx.fillRect(Math.floor(x - pixelSize/2), Math.floor(y - pixelSize/2), pixelSize, pixelSize);
    
    ctx.restore();
  }

  function drawPixelPortal(x, y, r, t) {
    ctx.save();
    ctx.translate(x, y);
    
    const pulse = 1 + 0.1 * Math.sin(t * 5);
    const rotation = t * 2;
    
    ctx.rotate(rotation);
    ctx.scale(pulse, pulse);
    
    // 포탈 링들
    ctx.strokeStyle = '#ff71ff';
    ctx.shadowBlur = 15;
    ctx.shadowColor = '#ff71ff';
    ctx.lineWidth = 4;
    
    for(let ring = 0; ring < 3; ring++) {
      const ringR = r * (0.3 + ring * 0.3);
      ctx.beginPath();
      
      // 픽셀화된 원 그리기
      const segments = 16;
      for(let i = 0; i <= segments; i++) {
        const angle = (i / segments) * TAU;
        const px = Math.cos(angle) * ringR;
        const py = Math.sin(angle) * ringR;
        
        if(i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.stroke();
    }
    
    // 중앙 코어
    ctx.fillStyle = '#ff71ff';
    ctx.fillRect(-4, -4, 8, 8);
    
    ctx.restore();
  }

  function drawPixelOrb(x, y, r, color) {
    ctx.save();
    
    // 외부 글로우
    ctx.fillStyle = color + '44';
    ctx.shadowBlur = 8;
    ctx.shadowColor = color;
    const outerSize = r * 2;
    ctx.fillRect(Math.floor(x - outerSize/2), Math.floor(y - outerSize/2), outerSize, outerSize);
    
    // 메인 오브
    ctx.fillStyle = color;
    ctx.shadowBlur = 4;
    const mainSize = r;
    ctx.fillRect(Math.floor(x - mainSize/2), Math.floor(y - mainSize/2), mainSize, mainSize);
    
    // 코어
    ctx.fillStyle = '#ffffff';
    ctx.shadowBlur = 0;
    const coreSize = Math.max(2, r * 0.5);
    ctx.fillRect(Math.floor(x - coreSize/2), Math.floor(y - coreSize/2), coreSize, coreSize);
    
    ctx.restore();
  }

  // ===== 레벨업 카드 =====
  const LVL_CARDS = [
    {id:'DMG', text:'공격력 +20%', apply:()=>playerUp.dmg*=1.2},
    {id:'ROF', text:'연사속도 +15%', apply:()=>playerUp.rof*=1.15},
    {id:'SPD', text:'탄속 +20%', apply:()=>playerUp.projSpeed*=1.2},
    {id:'RANGE', text:'사거리 +15%', apply:()=>playerUp.range*=1.15},
    {id:'HEART', text:'최대 체력 +1 (즉시 회복)', apply:()=>{player.hpMax += 1; player.hp = Math.min(player.hp + 1, player.hpMax); playerUp.survivability*=1.05}},
    {id:'SPECIAL_LASER', text:'레이저 과열 내성↑(쿨 -15%)', apply:()=>playerUp.special.laserCool = (playerUp.special.laserCool||1)*0.85},
    {id:'CORE_MAGNET', text:'코어 흡입 강화', apply:()=>playerUp.special.magnet = (playerUp.special.magnet||0)+1}
  ];
  function presentUpgradeChoices(){
    // 카드 3개
    const picks=[];
    while(picks.length<3){
      const c = LVL_CARDS[(Math.random()*LVL_CARDS.length)|0];
      if(!picks.includes(c)) picks.push(c);
    }
    const holder = document.getElementById('cardHolder');
    holder.innerHTML='';
    for(const c of picks){
      const div=document.createElement('div');
      div.className='cardOpt';
      div.innerHTML=`<b>${c.text}</b><div class="hint tiny">${c.id}</div>`;
      div.onclick=()=>{
        c.apply(); hideLvl();
      };
      holder.appendChild(div);
    }
    showLvl();
  }

  // ===== 히트스톱 =====
  let _hitstopUntil=0;
  function hitstop(ms){
    _hitstopUntil = Math.max(_hitstopUntil, now()+ms);
  }

  // ===== HP바 =====
  function updateHpBar(){
    const bar = document.getElementById('bossHpFill');
    if(!boss||!boss.alive){ bar.style.width='0%'; return; }
    bar.style.width = (boss.hpRatio*100).toFixed(1)+'%';
  }

  // ===== 상태 전환 =====
  function stageClear(){
    document.getElementById('bossHp').style.display='none';
    setTimeout(()=>{
      nextStage();
      document.getElementById('bossHp').style.display='block';
    }, 900);
  }
  function stageClearAll(){
    gameState=STATE.STAGECLEAR;
    const timeSec = totalTime;
    // 기록 저장
    if(!save.bestTimeSec || timeSec < save.bestTimeSec){
      save.bestTimeSec = timeSec;
      save.bestStage = BOSSES.length;
      saveNow();
    }
    showStartMenu();
  }
  function gameOver(){
    gameState=STATE.GAMEOVER;
    // 기록 업데이트(최고 스테이지)
    if((stageIndex+1) > (save.bestStage||0)){
      save.bestStage = stageIndex+1;
      save.bestTimeSec = totalTime;
      saveNow();
    }
    showStartMenu('GAME OVER');
  }

  function showStartMenu(note){
    const menu=document.getElementById('menuStart');
    menu.style.display='flex';
    if(note) menu.querySelector('h1').textContent = `NEON BOSS HUNTER — ${note}`;
  }
  function hideStartMenu(){
    document.getElementById('menuStart').style.display='none';
  }

  function showLvl(){
    gameState=STATE.LEVELUP;
    document.getElementById('lvlup').style.display='flex';
  }
  function hideLvl(){
    document.getElementById('lvlup').style.display='none';
    
    // 다음 스테이지로 진행
    stageIndex++;
    if(stageIndex>=BOSSES.length){
      // 전 스테이지 클리어
      stageClearAll();
      return;
    }
    
    gameState = STATE.PLAY;
    stageNote(`STAGE ${stageIndex+1}`);
    boss = new Boss(BOSSES[stageIndex]);
    updateHpBar();
  }

  function togglePause(){
    if(gameState===STATE.PLAY){ gameState=STATE.PAUSE; }
    else if(gameState===STATE.PAUSE){ gameState=STATE.PLAY; loop(); }
  }

  // ===== 스테이지 노트 =====
  let noteTimer=0;
  function stageNote(text){
    const el=document.getElementById('stageNote');
    el.textContent=text;
    el.style.display='block';
    noteTimer=1.6;
    const hide=()=>{ if(noteTimer<=0){ el.style.display='none'; } else { noteTimer-=0.1; setTimeout(hide,100); } };
    setTimeout(hide,1000);
  }

  // ===== UI 세팅 =====
  function buildWeaponGrid(){
    const g=document.getElementById('weaponGrid');
    g.innerHTML='';
    for(const w of weapons){
      if(!save.unlockedWeapons[w.id]) continue; // 해금 제한이 있다면
      
      // 디버그 무기는 디버그 모드일 때만 표시
      if(w.debug && !settings.debugMode) continue;
      
      const d=document.createElement('div');
      d.className='weapon'; d.dataset.id=w.id;
      
      // 디버그 무기인 경우 특별한 스타일 적용
      if(w.debug) {
        d.style.border = '2px solid #ff0000';
        d.style.backgroundColor = 'rgba(255, 0, 0, 0.1)';
      }
      
      d.innerHTML=`<b>${w.name}</b><div>${w.desc}</div><div class="tiny">이동속도 계수: ${w.move}</div>`;
      d.onclick=()=>{
        chosenWeapon=w.id;
        [...g.children].forEach(c=>c.classList.remove('sel'));
        d.classList.add('sel');
      };
      if(w.id===chosenWeapon) d.classList.add('sel');
      g.appendChild(d);
    }
  }
  function buildKeyList(){
    const list=document.getElementById('keyList');
    list.innerHTML='';
    const items = [
      ['up','위'],['down','아래'],['left','왼쪽'],['right','오른쪽'],
      ['fire','사격'],['melee','근접'],['dash','대시'],['pause','일시정지']
    ];
    for(const [id,label] of items){
      const row=document.createElement('div');
      row.className='row'; row.style.margin='6px 0';
      const btn=document.createElement('div');
      btn.className='btn pill';
      btn.textContent=settings.keys[id];
      btn.onclick=()=>{
        btn.textContent='눌러서 설정...';
        const onKey=(e)=>{
          e.preventDefault();
          settings.keys[id]= e.code || 'MouseLeft';
          btn.textContent=settings.keys[id];
          save.settings=settings; saveNow();
          removeEventListener('keydown', onKey);
          removeEventListener('mousedown', onMouse);
        };
        const onMouse=(e)=>{
          settings.keys[id]='MouseLeft';
          btn.textContent='MouseLeft';
          save.settings=settings; saveNow();
          removeEventListener('keydown', onKey);
          removeEventListener('mousedown', onMouse);
        };
        addEventListener('keydown', onKey, {once:true});
        addEventListener('mousedown', onMouse, {once:true});
      }
      row.innerHTML=`<div style="width:80px">${label}</div>`;
      row.appendChild(btn);
      list.appendChild(row);
    }
  }

  // 이벤트 바인딩
  document.getElementById('btnStart').onclick=()=>startRun();
  document.getElementById('btnSettings').onclick=()=>{ document.getElementById('modalSettings').style.display='flex'; buildKeyList(); }
  document.getElementById('btnCloseSettings').onclick=()=>{ document.getElementById('modalSettings').style.display='none'; }
  document.getElementById('btnResetSave').onclick=()=>{ localStorage.removeItem(SAVE_KEY); save=loadSave(); settings=save.settings; saveNow(); buildWeaponGrid(); buildKeyList(); };
  document.getElementById('btnDebug').onclick=()=>{ settings.showHitbox = !settings.showHitbox; save.settings=settings; saveNow(); };
  document.getElementById('btnPause').onclick=()=>togglePause();

  // 옵션
  document.getElementById('optGraphicsMode').onchange=(e)=>{ settings.graphicsMode=e.target.value; save.settings=settings; saveNow(); }
  document.getElementById('optColorBlindMode').onchange=(e)=>{ settings.colorBlindMode=e.target.value; save.settings=settings; saveNow(); }
  document.getElementById('optShowHitbox').onchange=(e)=>{ settings.showHitbox=e.target.checked; save.settings=settings; saveNow(); }
  document.getElementById('optShowFps').onchange=(e)=>{ settings.showFps=e.target.checked; save.settings=settings; saveNow(); }
  document.getElementById('optVibrate').onchange=(e)=>{ settings.vibrate=e.target.checked; save.settings=settings; saveNow(); }

  buildWeaponGrid(); buildKeyList(); refreshUIFromSave();

  // 시작 시 메뉴 표시
  showStartMenu();
})();
</script>
</body>
</html>
