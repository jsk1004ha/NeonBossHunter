<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>NEON BOSS HUNTER — Bullet Hell + Action</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0a0f1f;
    --panel:#0f1630;
    --txt:#e6f3ff;
    --accent:#49f3ff;
    --accent2:#ff71ff;
    --danger:#ff3b5c;
    --ok:#5bff8c;
    --warn:#ffd24a;
    --neonShadow: 0 0 10px var(--accent), 0 0 20px var(--accent2);
    --font-clean: 'Orbitron', monospace;
  }
  body{margin:0;background:radial-gradient(1200px 600px at 50% 30%,#101836 0%,#0a0f1f 50%,#050811 100%);color:var(--txt);font-family:var(--font-clean);overscroll-behavior:none;}
  #uiLayer{position:fixed;inset:0;pointer-events:none;}
  canvas{display:block;margin:40px auto 0;max-width:100vw;max-height:calc(100vh - 40px);touch-action:none;image-rendering: pixelated;}
  .topbar{position:fixed;left:0;right:0;top:0;display:flex;justify-content:center;gap:12px;padding:8px 12px;pointer-events:auto;background:rgba(16,24,48,.9);backdrop-filter: blur(6px);border-bottom:1px solid rgba(120,160,255,.25);z-index:1000}
  .pill{background:rgba(16,24,48,.7);backdrop-filter: blur(6px);border:1px solid rgba(80,140,255,.25);border-radius:2px;padding:6px 12px;box-shadow: var(--neonShadow);display:flex;align-items:center;gap:8px;}
  .btn{pointer-events:auto;cursor:pointer;user-select:none}
  .btn:hover{filter:brightness(1.1)}
  .menu{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(3,8,16,.75), rgba(3,8,16,.9));backdrop-filter: blur(6px);pointer-events:auto}
  .card{width:min(980px,92vw);max-height:86vh;overflow:auto;background:var(--panel);border:1px solid rgba(120,160,255,.25);border-radius:4px;padding:18px 18px 22px;box-shadow:0 10px 40px rgba(0,0,0,.45), 0 0 30px rgba(120,160,255,.15);}
  h1{margin:0 0 10px 0;font-size:28px;font-weight:900;text-shadow:0 0 20px var(--accent);}
  h2{margin:12px 0 8px 0;font-size:20px;font-weight:700;}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:12px}
  .weapon{border:1px solid rgba(120,160,255,.3);border-radius:2px;padding:12px;background:rgba(12,18,40,.8);display:flex;flex-direction:column;gap:8px}
  .weapon.sel{outline:2px solid var(--accent);box-shadow:0 0 20px rgba(73,243,255,.35) inset}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .chip{border:1px solid rgba(120,160,255,.25);background:rgba(12,18,40,.7);border-radius:2px;padding:4px 10px}
  .kbd{font-family:ui-monospace,Menlo,Consolas,monospace;border:1px solid rgba(255,255,255,.2);background:#0b1226;border-radius:2px;padding:2px 6px}
  .floating{position:fixed;right:12px;bottom:12px;display:flex;flex-direction:column;gap:8px}
  .floating .btn{border:1px solid rgba(120,160,255,.25);background:rgba(12,18,40,.8);border-radius:2px;padding:10px 12px}
  .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);backdrop-filter: blur(2px);pointer-events:auto}
  .modal .card{width:min(720px,92vw)}
  .hpbar{position:fixed;left:50%;transform:translateX(-50%);top:42px;width:min(880px,92vw);height:16px;background:rgba(20,28,55,.8);border-radius:2px;border:1px solid rgba(120,160,255,.3);overflow:hidden;z-index:999}
  .hpfill{height:100%;background:linear-gradient(90deg,#ff4d7e,#ffd24a);box-shadow:0 0 12px rgba(255,77,126,.6) inset}
  .stageNote{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);font-size:28px;padding:10px 16px;background:rgba(0,0,0,.35);border:1px solid rgba(120,160,255,.3);border-radius:2px;display:none;font-weight:700;text-shadow:0 0 15px var(--accent);}
  /* 모바일 조이스틱 */
  .stick{position:fixed;bottom:18px;width:140px;height:140px;border-radius:50%;border:1px solid rgba(120,160,255,.25);background:rgba(12,18,40,.55);backdrop-filter: blur(4px);pointer-events:auto;touch-action:none}
  .stick .knob{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:72px;height:72px;border-radius:50%;background:rgba(73,243,255,.35);border:2px solid rgba(73,243,255,.65);box-shadow:0 0 16px rgba(73,243,255,.5) inset}
  #stickMove{left:18px}
  #stickAim{right:18px}
  .attackBtn{position:fixed;right:22px;bottom:172px;width:92px;height:92px;border-radius:2px;border:2px solid rgba(255,113,255,.7);background:rgba(255,113,255,.2);backdrop-filter: blur(2px);pointer-events:auto;display:flex;align-items:center;justify-content:center;font-weight:700}
  .lvlup{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.6)}
  .cards{display:grid;grid-template-columns:repeat(3,1fr);gap:14px;width:min(980px,92vw)}
  .cardOpt{border:1px solid rgba(120,160,255,.35);background:rgba(10,18,40,.95);padding:16px;border-radius:2px;cursor:pointer}
  .cardOpt:hover{box-shadow:0 0 18px rgba(73,243,255,.25) inset}
  .hint{opacity:.8;font-size:12px}
  .tiny{font-size:11px;opacity:.8}
  .hidden{display:none !important}
</style>
</style>
</head>
<body>
<canvas id="game" width="1280" height="720"></canvas>
<div id="uiLayer" aria-hidden="true"></div>

<!-- 상단 HP/패널 -->
<div class="hpbar" id="bossHp" style="display:none">
  <div id="bossName" style="position:absolute;left:10px;top:50%;transform:translateY(-50%);font-size:12px;font-weight:bold;"></div>
  <div class="hpfill" id="bossHpFill" style="width:100%"></div>
</div>
<div class="topbar">
  <div class="pill">❤️ <span id="playerHpLabel">3</span></div>
  <div class="pill">스테이지 <span id="stageLabel">1-1</span></div>
  <div class="pill">코어 <span id="coreLabel">0</span></div>
  <div class="pill btn" id="btnSettings">설정</div>
  <div class="pill btn" id="btnDebug">디버그</div>
</div>

<!-- 시작 메뉴: 무기 선택 -->
<div class="menu" id="menuStart">
  <div class="card">
    <h1>NEON BOSS HUNTER</h1>
    <div class="tiny">탑다운 탄막+액션 • PC/모바일 • 네온 테마 • 단일 HTML</div>
    <h2>무기 선택</h2>
    <div class="grid" id="weaponGrid"></div>
    <div class="row" style="margin-top:12px">
      <span class="chip">조작: WASD 이동, 마우스 조준/사격 • 모바일 듀얼 조이스틱</span>
    </div>
    <div style="margin-top:12px" class="row">
      <div class="btn pill" id="btnStart">게임 시작</div>
      <div class="pill">최고 기록: <span id="bestLabel">-</span></div>
    </div>
  </div>
</div>

<!-- 레벨업 카드 -->
<div class="lvlup" id="lvlup">
  <div class="cards" id="cardHolder"></div>
</div>

<!-- 설정 모달 -->
<div class="modal" id="modalSettings">
  <div class="card">
    <h2>설정</h2>
    <div class="grid">
      <div class="weapon">
        <b>키 리맵</b>
        <div class="tiny">변경할 키 항목을 눌러 새 키를 입력하세요.</div>
        <div id="keyList"></div>
      </div>
      <div class="weapon">
        <b>옵션</b>
        <label><input type="checkbox" id="optColorBlind"> 색약 보조(고대비 탄색)</label><br/>
        <label><input type="checkbox" id="optShowHitbox"> 히트박스 표시</label><br/>
        <label><input type="checkbox" id="optShowFps"> FPS 표시</label><br/>
        <label><input type="checkbox" id="optVibrate"> 모바일 진동(Hit/피격)</label>
      </div>
      <div class="weapon">
        <b>저장</b>
        <div>로컬 저장에는 최고 기록, 설정, 해금이 포함됩니다.</div>
        <div class="row" style="margin-top:8px">
          <div class="btn pill" id="btnResetSave">저장 초기화</div>
          <div class="btn pill" id="btnCloseSettings">닫기</div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- 스테이지 안내 -->
<div class="stageNote" id="stageNote">STAGE 1</div>

<!-- 모바일 조이스틱/버튼 -->
<div id="stickMove" class="stick hidden"><div class="knob"></div></div>
<div id="stickAim" class="stick hidden"><div class="knob"></div></div>
<div id="btnAttack" class="attackBtn hidden">공격</div>

<!-- 플로팅 버튼 -->
<div class="floating">
  <div class="btn" id="btnPause">⏸ 일시정지</div>
</div>

<script>
/**
 * NEON BOSS HUNTER — 단일 파일 완성본
 * 스펙:
 * - 1280x720 Canvas, 탑다운, PC+모바일
 * - 무기: 레이저/산탄/로켓/기관총(원거리), 검/대검/망치(근접)
 * - 레벨업 카드 3중 택1 (공격력/연사/탄속/사거리/특수 등)
 * - 스테이지 방식, 보스 1명씩. 각 2~3 페이즈
 * - 색약 보조, 히트박스/FPS 토글, 키 리맵, 진동(옵션), 로컬 저장
 * - 히트스톱 100ms, 피격 후 무적 1초, 플레이어 체력 3, 무기별 이동속도 상이
 */

(() => {
  // ===== 유틸 =====
  const TAU = Math.PI*2;
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const rand = (a,b)=>Math.random()*(b-a)+a;
  const chance = (p)=>Math.random()<p;
  const now = ()=>performance.now();
  const dist2 = (ax,ay,bx,by)=>{let dx=ax-bx, dy=ay-by;return dx*dx+dy*dy;}
  const angleTo = (ax,ay,bx,by)=>Math.atan2(by-ay,bx-ax);
  const vec2 = (a)=>({x:Math.cos(a),y:Math.sin(a)});
  const vibrate = (ms)=>{try{ if(settings.vibrate && navigator.vibrate) navigator.vibrate(ms);}catch{}}

  // ===== 저장 =====
  const SAVE_KEY='neon_boss_hunter_v1';
  
  // ===========================================
  // 디버그 모드 활성화 방법:
  // debugMode: false를 debugMode: true로 변경
  // 플레이어가 무적이 되어 모든 데미지를 무시합니다
  // ===========================================
  
  const defaultSave = {
    bestTimeSec:null,
    bestStage:0,
    settings:{
      colorBlind:false, showHitbox:false, showFps:false, vibrate:true,
      debugMode:false, // 디버그 모드 - 무적 (코드에서만 변경 가능)
      keys:{up:'KeyW',down:'KeyS',left:'KeyA',right:'KeyD',fire:'MouseLeft',dash:'ShiftLeft',pause:'Escape'}
    },
    unlockedWeapons:{ LASER:true, SHOTGUN:true, ROCKET:true, MINIGUN:true, PLASMA:true, BOOMERANG:true, SMG:true, SNIPER:true }
  };
  let save = loadSave();

  function loadSave(){
    try{
      const s = JSON.parse(localStorage.getItem(SAVE_KEY));
      if(!s) return structuredClone(defaultSave);
      // 합치기(신규 필드 보정)
      return deepMerge(structuredClone(defaultSave), s);
    }catch{ return structuredClone(defaultSave); }
  }
  function deepMerge(a,b){
    for(const k in b){
      if(b[k] && typeof b[k]==='object' && !Array.isArray(b[k])){
        a[k] = deepMerge(a[k] ?? {}, b[k]);
      }else a[k]=b[k];
    }
    return a;
  }
  function saveNow(){
    localStorage.setItem(SAVE_KEY, JSON.stringify(save));
    refreshUIFromSave();
  }

  // ===== 설정 전역 =====
  let settings = save.settings;
  function refreshUIFromSave(){
    document.getElementById('optColorBlind').checked = settings.colorBlind;
    document.getElementById('optShowHitbox').checked = settings.showHitbox;
    document.getElementById('optShowFps').checked = settings.showFps;
    document.getElementById('optVibrate').checked = settings.vibrate;
    document.getElementById('bestLabel').textContent = save.bestTimeSec ? `${save.bestTimeSec.toFixed(1)}s (Stage ${save.bestStage})` : '-';
  }

  // ===== 캔버스/스케일 =====
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');
  let W=cvs.width, H=cvs.height;
  function fitCanvas(){
    // CSS로만 반응형 — 내부 해상도 고정(1280x720)
    // 모바일일 때 조이스틱 표시
    const isTouch = matchMedia('(pointer:coarse)').matches;
    toggleMobileUI(isTouch);
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

  // ===== 입력 =====
  const keyState = new Set();
  const mouse = {x:W/2,y:H/2,down:false};
  let aimDir = 0; // 마우스/우측 스틱 각도

  // 키 매핑
  function isKey(code, action){
    const map = settings.keys;
    const target = map[action];
    if(code===target) return true;
    // 특별 처리: MouseLeft
    if(action==='fire' && code==='MouseLeft' && mouse.down) return true;
    return false;
  }

  addEventListener('keydown', e=>{
    keyState.add(e.code);
    if(isKey(e.code,'pause')) { togglePause(); e.preventDefault(); }
  });
  addEventListener('keyup', e=>{ keyState.delete(e.code); });
  cvs.addEventListener('mousedown', e=>{ mouse.down=true; });
  addEventListener('mouseup', e=>{ mouse.down=false; });
  cvs.addEventListener('mousemove', e=>{
    const rect=cvs.getBoundingClientRect();
    mouse.x = (e.clientX-rect.left)*W/rect.width;
    mouse.y = (e.clientY-rect.top)*H/rect.height;
    if(player) aimDir = angleTo(player.x,player.y,mouse.x,mouse.y);
  });

  // ===== 모바일 조이스틱 =====
  const stickMove = setupStick('stickMove');
  const stickAim  = setupStick('stickAim');
  const btnAttack = document.getElementById('btnAttack');
  let mobileAttack=false;

  btnAttack.addEventListener('touchstart', e=>{ e.preventDefault(); mobileAttack=true;});
  btnAttack.addEventListener('touchend', e=>{ e.preventDefault(); mobileAttack=false;});

  function setupStick(id){
    const el = document.getElementById(id);
    const knob = el.querySelector('.knob');
    const state = {active:false, vx:0, vy:0, angle:0, mag:0};
    let base={x:0,y:0};
    function setKnob(dx,dy){
      const r=55; // half range
      const m = Math.hypot(dx,dy);
      const cl = m>r ? r/m : 1;
      knob.style.left = (50 + (dx*cl)/1.4)+'%';
      knob.style.top  = (50 + (dy*cl)/1.4)+'%';
    }
    function onStart(cx,cy){
      state.active=true;
      base={x:cx,y:cy};
    }
    function onMove(cx,cy){
      if(!state.active) return;
      const dx=cx-base.x, dy=cy-base.y;
      const m=Math.hypot(dx,dy);
      state.mag = clamp(m/70,0,1);
      state.angle = Math.atan2(dy,dx);
      state.vx = Math.cos(state.angle)*state.mag;
      state.vy = Math.sin(state.angle)*state.mag;
      setKnob(dx,dy);
    }
    function onEnd(){
      state.active=false; state.vx=state.vy=state.mag=0;
      knob.style.left='50%'; knob.style.top='50%';
    }
    el.addEventListener('touchstart', e=>{
      e.preventDefault();
      const t=e.changedTouches[0];
      onStart(t.clientX,t.clientY);
    }, {passive:false});
    el.addEventListener('touchmove', e=>{
      e.preventDefault();
      const t=e.changedTouches[0];
      onMove(t.clientX,t.clientY);
    }, {passive:false});
    el.addEventListener('touchend', e=>{ e.preventDefault(); onEnd(); }, {passive:false});
    return state;
  }
  function toggleMobileUI(show){
    document.getElementById('stickMove').classList.toggle('hidden', !show);
    document.getElementById('stickAim').classList.toggle('hidden', !show);
    document.getElementById('btnAttack').classList.toggle('hidden', !show);
  }

  // ===== 게임 상태 =====
  const STATE = { MENU:0, PLAY:1, PAUSE:2, LEVELUP:3, STAGECLEAR:4, GAMEOVER:5 };
  let gameState = STATE.MENU;
  let stageIndex = 0; // 0..(bosses.length-1)
  let stageStartTime=0;
  let totalTime=0;
  let cores=0;
  let portal = null;

  // ===== 플레이어/무기 =====
  let player=null;
  const weapons = [
    {id:'LASER', name:'레이저', desc:'관통 지속빔, 과열 게이지', type:'ranged', move:1.00},
    {id:'SHOTGUN', name:'산탄', desc:'확산 다중탄, 근접 고효율', type:'ranged', move:1.00},
    {id:'ROCKET', name:'로켓', desc:'폭발 범위 피해/넉백', type:'ranged', move:0.95},
    {id:'MINIGUN', name:'기관총', desc:'고연사 저반동, 과열', type:'ranged', move:1.05},
    {id:'PLASMA', name:'플라즈마', desc:'충전식 고위력 관통탄', type:'ranged', move:0.90},
    {id:'BOOMERANG', name:'부메랑', desc:'되돌아오는 곡선 투사체', type:'ranged', move:1.05},
    {id:'SMG', name:'기관단총', desc:'초고속 연사, 기동성 특화', type:'ranged', move:1.25},
    {id:'SNIPER', name:'저격총', desc:'장거리 고위력, 정밀 사격', type:'ranged', move:0.75}
  ];
  let chosenWeapon = 'LASER';

  // 업그레이드 가능한 스탯
  const playerUp = {
    dmg:1, rof:1, projSpeed:1, range:1, survivability:1, special: {}
  };

  // ===== 보스 데이터(스테이지식: 각 보스 1명) =====
  // 각 보스는 phases: [{pattern(time), hpRatioStart, hpRatioEnd}]
  const BOSSES = [
    {
      id:'RING_SENTINEL',
      name:'링 센티넬',
      color:'#49f3ff',
      baseHP:1000, // 2~5분 밸런스: 실제 전투는 난이도/무기 업글에 따라 변동
      phases:[
        { name:'Opening Rings',  until:0.66,  script:'rings' },
        { name:'Spiral+Target',  until:0.33,  script:'spiral_target' },
        { name:'Laser Sweep',    until:0.00,  script:'laser_sweep' }
      ]
    },
    {
      id:'HYDRA_CORE',
      name:'하이드라 코어',
      color:'#ff71ff',
      baseHP:1300,
      phases:[
        { name:'Orbit Orbs',     until:0.5,   script:'orbits' },
        { name:'Spawn Drones',   until:0.2,   script:'drones' },
        { name:'Frenzy Spiral',  until:0.0,   script:'frenzy' }
      ]
    },
    {
      id:'TITAN_FORGE',
      name:'타이탄 포지',
      color:'#ffd24a',
      baseHP:1600,
      phases:[
        { name:'Meteor Hammers', until:0.6,   script:'meteors' },
        { name:'Hammer Barrage', until:0.3,   script:'hammer_barrage' },
        { name:'Desperation',    until:0.0,   script:'desperate' }
      ]
    }
  ];

  // ===== 엔티티 풀 =====
  const bullets=[]; const bulletPool=[];
  const parts=[]; const partPool=[];
  const orbs=[];  // 경험치 코어

  function spawnBullet(b){
    const o = bulletPool.pop() || {};
    Object.assign(o,b,{alive:true,ttl:b.ttl??6});
    bullets.push(o);

    // 이펙트 강화: 보스 탄환 발사 시 파티클 효과 추가
    if (b.hostile) {
      for(let i=0; i<2; i++) {
        spawnPart({
          x: b.x, y: b.y,
          ttl: rand(0.1, 0.3),
          color: b.color,
          sz: rand(2, 4),
          vx: (b.vx || 0) * 0.1 + rand(-30, 30),
          vy: (b.vy || 0) * 0.1 + rand(-30, 30)
        });
      }
    }

    return o;
  }
  function spawnPart(p){
    const o = partPool.pop() || {};
    Object.assign(o,p,{alive:true,ttl:p.ttl??0.6});
    parts.push(o);
    return o;
  }
  function spawnOrb(x,y,amt=1){
    orbs.push({x,y,vx:rand(-50,50),vy:rand(-50,50),r:5,amt,alive:true,ttl:10});
  }

  function clearEntities() {
    bullets.length = 0;
    bulletPool.length = 0;
    parts.length = 0;
    partPool.length = 0;
    orbs.length = 0;
  }

  // ===== 플레이어/보스 클래스 =====
  class Player{
    constructor(){
      this.x=W*0.5; this.y=H*0.75;
      this.r=12; this.hp=3; this.hpMax=3; this.ifr=0;
      this.moveSpd=220; // base, weapon별 계수 적용
      this.fireCd=0; this.meleeCd=0; this.dashCd=0; this.overheat=0;
      this.weapon=chosenWeapon;
      this.aim=0;
      this.alive=true;
      // 플라즈마 캐논용
      this.chargeTime=0;
      this.isCharging=false;
      // 저격총 탄창 시스템
      this.sniperAmmo=5;
      this.sniperMaxAmmo=5;
      this.sniperReloading=false;
      this.sniperReloadTime=0;
      this.sniperMaxReloadTime=7.5;
      // 대쉬 시스템
      this.isDashPreviewing=false;
      this.dashPreviewX=0;
      this.dashPreviewY=0;
      this.dashDistance=120;
      this.dashCooldown=2.0;
    }
    speed(){
      const w=weapons.find(w=>w.id===this.weapon);
      return this.moveSpd*(w?.move||1);
    }
    update(dt){
      if(!this.alive) return;
      
      // 대쉬 쿨다운 감소
      this.dashCd = Math.max(0, this.dashCd - dt);
      
      // 저격총 재장전 처리
      if(this.sniperReloading) {
        this.sniperReloadTime -= dt;
        if(this.sniperReloadTime <= 0) {
          this.sniperReloading = false;
          this.sniperAmmo = this.sniperMaxAmmo;
        }
      }
      
      // 대쉬 입력 처리 (Left Shift)
      const isDashPressed = keyState.has('ShiftLeft');
      
      if(isDashPressed && this.dashCd === 0) {
        // 대쉬 미리보기 - 지속적으로 현재 위치와 조준 방향 기준으로 업데이트
        this.isDashPreviewing = true;
        const dashAngle = this.aim;
        this.dashPreviewX = clamp(this.x + Math.cos(dashAngle) * this.dashDistance, 20, W-20);
        this.dashPreviewY = clamp(this.y + Math.sin(dashAngle) * this.dashDistance, 20, H-20);
      } else if(!isDashPressed && this.isDashPreviewing) {
        // 대쉬 실행
        this.x = this.dashPreviewX;
        this.y = this.dashPreviewY;
        this.dashCd = this.dashCooldown;
        this.isDashPreviewing = false;
        this.ifr = 0.3; // 대쉬 후 짧은 무적 시간
        
        // 대쉬 이펙트
        for(let i=0; i<12; i++) {
          spawnPart({
            x: this.x + rand(-15, 15),
            y: this.y + rand(-15, 15),
            ttl: 0.4,
            color: '#00ff88',
            sz: rand(3, 8)
          });
        }
      } else if(!isDashPressed) {
        // Shift를 누르지 않으면 미리보기 해제
        this.isDashPreviewing = false;
      }
      
      // 이동 입력
      let ix=0, iy=0;
      // 모바일 우선
      if(stickMove.mag>0.01){ ix+=stickMove.vx; iy+=stickMove.vy; }
      else {
        if(keyState.has(settings.keys.left)) ix-=1;
        if(keyState.has(settings.keys.right)) ix+=1;
        if(keyState.has(settings.keys.up)) iy-=1;
        if(keyState.has(settings.keys.down)) iy+=1;
      }
      const n = Math.hypot(ix,iy);
      if(n>0){ ix/=n; iy/=n; }
      const s=this.speed();
      this.x=clamp(this.x+ix*s*dt, 20, W-20);
      this.y=clamp(this.y+iy*s*dt, 20, H-20);

      // 조준 각
      if(stickAim.mag>0.01){
        this.aim = stickAim.angle;
      }else{
        this.aim = aimDir;
      }

      // 무적 프레임
      this.ifr = Math.max(0,this.ifr-dt);

      // 사격/공격
      this.fireCd=Math.max(0,this.fireCd-dt);

      const wantsFire = mouse.down || stickAim.mag>0.2 || keyState.has(settings.keys.fire);

      handleWeaponFire(this, dt, wantsFire);
    }
    draw(g){
      // 대쉬 미리보기 그리기
      if(this.isDashPreviewing) {
        g.save();
        g.globalAlpha = 0.6;
        g.strokeStyle = '#00ff88';
        g.setLineDash([5, 5]);
        g.lineWidth = 2;
        g.beginPath();
        g.moveTo(this.x, this.y);
        g.lineTo(this.dashPreviewX, this.dashPreviewY);
        g.stroke();
        g.setLineDash([]);
        
        // 목표 위치 표시
        g.fillStyle = '#00ff8866';
        g.beginPath();
        g.arc(this.dashPreviewX, this.dashPreviewY, this.r, 0, TAU);
        g.fill();
        g.strokeStyle = '#00ff88';
        g.lineWidth = 2;
        g.stroke();
        g.restore();
      }
      
      // 플레이어 — 픽셀 아트 스타일
      if(this.ifr > 0 && Math.floor(now() / 100) % 2) return; // 피격 시 깜빡임
      drawPixelPlayer(this.x, this.y, this.r, this.aim);
      
      if(settings.showHitbox){
        g.save();
        g.strokeStyle='#ffffff66'; g.setLineDash([3,3]);
        g.beginPath(); g.arc(this.x, this.y, this.r, 0, TAU); g.stroke(); g.setLineDash([]);
        g.restore();
      }
    }
    hit(dmg){
      // 디버그 모드에서는 무적
      if(settings.debugMode) {
        console.log('DEBUG MODE: Damage ignored -', dmg);
        return;
      }
      
      if(this.ifr>0 || !this.alive) return;
      this.hp = Math.max(0, Math.floor(this.hp - dmg)); this.ifr=1.0;
      vibrate(40);
      hitstop(100);
      for(let i=0;i<15;i++) spawnPart({x:this.x+rand(-10,10),y:this.y+rand(-10,10),ttl:rand(0.3,0.6),color:'#ff3b5c',sz:rand(4,9)});
      if(this.hp<=0){ this.alive=false; gameOver(); }
      document.getElementById('playerHpLabel').textContent = Math.floor(this.hp);
    }
  }

  class Boss{
    constructor(cfg){
      this.cfg=cfg;
      this.x=W*0.5; this.y=H*0.28;
      this.r=42;
      this.hpMax=cfg.baseHP*(1+stageIndex*0.2);
      this.hp=this.hpMax;
      this.phaseIndex=0;
      this.timer=0;
      this.laserTimer=0;
      this.alive=true;
      this.color=cfg.color;
      this.script = cfg.phases[0].script;
      this.moveSpeed = 80;
      this.moveTimer = 0;
      this.moveTargetX = this.x;
      this.moveTargetY = this.y;
    }
    get hpRatio(){ return this.hp/this.hpMax; }
    update(dt){
      if(!this.alive) return;
      this.timer+=dt;

      // 보스 이동
      this.moveTimer -= dt;
      if (this.moveTimer <= 0) {
        this.moveTimer = rand(2, 4); // 2-4초마다 방향 변경
        this.moveTargetX = W * 0.5 + rand(-200, 200);
        this.moveTargetY = H * 0.28 + rand(-100, 100);
      }

      const moveAngle = angleTo(this.x, this.y, this.moveTargetX, this.moveTargetY);
      const distToTarget = dist2(this.x, this.y, this.moveTargetX, this.moveTargetY);

      if (distToTarget > 25*25) {
          this.x += Math.cos(moveAngle) * this.moveSpeed * dt;
          this.y += Math.sin(moveAngle) * this.moveSpeed * dt;
      }

      // 페이즈 진행
      const p = this.cfg.phases[this.phaseIndex];
      if(this.hpRatio <= p.until){
        if(this.phaseIndex < this.cfg.phases.length-1){
          this.phaseIndex++;
          this.script = this.cfg.phases[this.phaseIndex].script;
          this.timer=0;
          stageNote(`${this.cfg.name} — ${this.cfg.phases[this.phaseIndex].name}`);
        }
      }
      // 패턴 실행
      bossScripts[this.script]?.(this, dt);
    }
    draw(g){
      // 보스 — 픽셀 아트 스타일
      drawPixelBoss(this.x, this.y, this.r, this.color, this.phaseIndex);
      
      if(settings.showHitbox){
        g.save();
        g.strokeStyle='#fff5'; g.setLineDash([4,4]); 
        g.beginPath(); g.arc(this.x, this.y, this.r, 0, TAU); g.stroke(); g.setLineDash([]);
        g.restore();
      }
    }
    take(dmg){
      this.hp-=dmg;
      spawnPart({x:this.x+rand(-this.r,this.r),y:this.y+rand(-this.r,this.r),ttl:0.25,color:this.color,sz:rand(5,10)});
      if(this.hp<=0 && this.alive){
        this.alive=false;
        // 대폭발 + 코어 드랍
        for(let i=0;i<60;i++) spawnPart({x:this.x+rand(-40,40),y:this.y+rand(-40,40),ttl:rand(0.5,1.2),color:this.color,sz:rand(8,16)});
        for(let i=0;i<20;i++) spawnOrb(this.x+rand(-30,30),this.y+rand(-30,30), rand(2,4));
        
        // 체력 회복
        player.hp = Math.min(player.hpMax, Math.floor(player.hp + player.hpMax * 0.5)); // 50% 체력 회복 (정수로)
        
        // 직접 업그레이드 화면 표시
        setTimeout(() => {
          presentUpgradeChoices();
        }, 500);
      }
    }
  }

  // ===== 보스 패턴 스크립트 =====
  const bossScripts = {
    // 링 센티넬 Phase 1 - 확장된 링 패턴
    rings(b,dt){
      if(!b._ring){ b._ring={cd:0, step:0, pattern:0, subTimer:0}; }
      const R=b._ring; R.cd-=dt; R.subTimer+=dt;
      
      // 패턴 로테이션 (4가지 패턴)
      if(R.subTimer > 6) { R.pattern = (R.pattern + 1) % 4; R.subTimer = 0; }
      
      if(R.cd<=0){
        R.cd = 1.2 + R.pattern * 0.2; // 패턴별 타이밍 조절
        const col = settings.colorBlind? '#00e5ff' : '#49f3ff';
        
        if(R.pattern === 0) { // 기본 동심원 - 강화
          const N=28; const speed=150;
          for(let i=0;i<N;i++){
            const a=i/N*TAU + (R.step%2?0:TAU/N/2);
            spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, r:8, dmg:1, color:col, hostile:true});
          }
          // 추가 내부 링
          const N2=16; const speed2=80;
          for(let i=0;i<N2;i++){
            const a=i/N2*TAU + R.step*0.1;
            spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*speed2, vy:Math.sin(a)*speed2, r:6, dmg:1, color:'#00e5ff', hostile:true});
          }
        } else if(R.pattern === 1) { // 펄스 링 - 강화
          const N=36; const speed=110 + Math.sin(R.step*0.5)*50;
          for(let i=0;i<N;i++){
            const a=i/N*TAU + R.step*0.1;
            spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, r:7, dmg:1, color:'#ff71ff', hostile:true});
          }
          // 지연 펄스
          setTimeout(()=>{
            if(!boss || !boss.alive) return;
            for(let i=0;i<N;i++){
              const a=i/N*TAU + R.step*0.1 + TAU/N/2;
              spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*(speed+30), vy:Math.sin(a)*(speed+30), r:5, dmg:1, color:'#ff3b5c', hostile:true});
            }
          }, 300);
        } else if(R.pattern === 2) { // 교차 링 - 강화
          for(let ring=0; ring<3; ring++){
            const N=24; const speed=140 + ring*25;
            for(let i=0;i<N;i++){
              const a=i/N*TAU + ring*TAU/N/3 + R.step*0.15;
              const colors = ['#49f3ff', '#ffd24a', '#ff71ff'];
              spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, r:7, dmg:1, color:colors[ring], hostile:true});
            }
          }
        } else { // 가변 밀도 링 - 강화
          const N=20 + Math.floor(Math.sin(R.step*0.3)*16); const speed=130;
          for(let i=0;i<N;i++){
            const a=i/N*TAU + R.step*0.08;
            const size = 6 + Math.sin(i*0.5 + R.step)*2;
            spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, r:size, dmg:1, color:'#ff3b5c', hostile:true});
          }
          // 반대 방향 회전
          for(let i=0;i<N/2;i++){
            const a=i/(N/2)*TAU - R.step*0.12;
            spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*speed*0.7, vy:Math.sin(a)*speed*0.7, r:5, dmg:1, color:'#00e5ff', hostile:true});
          }
        }
        R.step++;
      }
      
      // 추가 패턴: 추적 미사일 - 수량 감소
      if(Math.floor(b.timer*2)%8===0 && chance(0.04)){
        const a = angleTo(b.x,b.y, player.x,player.y) + rand(-0.3,0.3);
        for(let i=0;i<2;i++){
          setTimeout(()=>{
            if(!boss || !boss.alive) return;
            spawnBullet({x:b.x,y:b.y, homing:true, r:8, spd:200, dmg:1, color:'#ff71ff', hostile:true, ttl:4.0, turnRate: 2.2});
          }, i*200);
        }
      }
    },
    // 링 센티넬 Phase 2 - 스파이럴+타겟 다양화
    spiral_target(b,dt){
      if(!b._sp){ b._sp={a:0,cd:0,mode:0,modeTimer:0}; }
      const S=b._sp; S.a+=dt*2.5; S.cd-=dt; S.modeTimer+=dt;
      
      // 모드 변경 (3가지 모드)
      if(S.modeTimer > 5) { S.mode = (S.mode + 1) % 3; S.modeTimer = 0; }
      
      if(S.cd<=0){
        S.cd = 0.12 + S.mode * 0.03; // 발사 간격 증가 (0.06->0.12, 0.02->0.03)
        const speed=140 + S.mode * 20;
        const a=S.a;
        const col=settings.colorBlind? '#ffd24a' : '#ff71ff';
        
        if(S.mode === 0) { // 2-way 스파이럴 - 간격 증가
          for(let arm=0; arm<2; arm++){
            const baseAngle = a + arm*TAU/2;
            spawnBullet({x:b.x,y:b.y, vx:Math.cos(baseAngle)*speed, vy:Math.sin(baseAngle)*speed, r:7, dmg:1, color:col, hostile:true});
            // 추가 분기 - 개수 감소
            for(let sub=-1; sub<=1; sub+=2){
              if(Math.random() < 0.6) { // 60% 확률로만 생성
                spawnBullet({x:b.x,y:b.y, vx:Math.cos(baseAngle+sub*0.3)*speed*0.7, vy:Math.sin(baseAngle+sub*0.3)*speed*0.7, r:4, dmg:1, color:'#00e5ff', hostile:true});
              }
            }
          }
        } else if(S.mode === 1) { // 4-way 스파이럴 - 중간탄 제거
          for(let i=0;i<4;i++){
            const aa = a + i*TAU/4;
            spawnBullet({x:b.x,y:b.y, vx:Math.cos(aa)*speed, vy:Math.sin(aa)*speed, r:7, dmg:1, color:'#49f3ff', hostile:true});
            // 중간 각도 추가 - 확률적 생성
            if(Math.random() < 0.4) { // 40% 확률로만 생성
              const midAngle = aa + TAU/8;
              spawnBullet({x:b.x,y:b.y, vx:Math.cos(midAngle)*speed*0.5, vy:Math.sin(midAngle)*speed*0.5, r:4, dmg:1, color:'#ff3b5c', hostile:true});
            }
          }
        } else { // 6-way 가변속도 - 반대방향 탄 감소
          for(let i=0;i<6;i++){
            const aa = a + i*TAU/6;
            const spd = speed + Math.sin(a + i)*40;
            spawnBullet({x:b.x,y:b.y, vx:Math.cos(aa)*spd, vy:Math.sin(aa)*spd, r:7, dmg:1, color:'#ffd24a', hostile:true});
          }
          // 반대 방향 3-way - 개수 감소
          if(Math.random() < 0.5) { // 50% 확률로만 생성
            for(let i=0;i<2;i++){ // 3개에서 2개로 감소
              const aa = -a + i*TAU/2;
              spawnBullet({x:b.x,y:b.y, vx:Math.cos(aa)*speed*0.6, vy:Math.sin(aa)*speed*0.6, r:5, dmg:1, color:'#ff71ff', hostile:true});
            }
          }
        }
      }
      
      // 추가: 바운싱 탄 - 빈도 감소
      if(Math.floor(b.timer*3)%12===0 && chance(0.03)){ // 주기 증가 (9->12), 확률 감소 (0.06->0.03)
        const base=angleTo(b.x,b.y, player.x,player.y);
        for(let i=-2;i<=2;i++){ // 범위 감소 (-3~3 -> -2~2)
          const aa=base+i*0.3; // 각도 간격 증가 (0.2->0.3)
          spawnBullet({x:b.x,y:b.y, vx:Math.cos(aa)*180, vy:Math.sin(aa)*180, r:7, dmg:1, color:'#ff3b5c', hostile:true, bounce:3}); // 속도 감소 (200->180), 바운스 감소 (4->3)
        }
      }
    },
    // 링 센티넬 Phase 3 - 레이저 패턴 강화
    laser_sweep(b,dt){
      if(!b._lz){ b._lz={cd:0, step:0, warm:0, multiMode:0}; }
      const L=b._lz; L.cd-=dt;
      
      if(L.cd<=0){
        L.cd = 5.0 - L.step * 0.15; // 레이저 간격 증가 (3.8->5.0, 0.2->0.15)
        L.step++;
        L.multiMode = L.step % 3; // 3가지 레이저 패턴
        
        if(L.multiMode === 0) { // 단일 추적 레이저
          const target = angleTo(b.x,b.y, player.x,player.y) + rand(-0.3,0.3); // 정확도 약간 감소
          L.warm = 1.2; L.target = target; // 예고 시간 증가
          setTimeout(()=>{
            if(!boss || !boss.alive) return;
            const len=1200, w=10; // 길이와 폭 감소 (1400->1200, 12->10)
            for(let t=0;t<25;t++){ // 레이저 세그먼트 감소 (30->25)
              const d = (t/25)*len;
              spawnBullet({x:b.x+Math.cos(target)*d, y:b.y+Math.sin(target)*d, vx:0,vy:0, r:w, dmg:2, color:'#ff3b5c', hostile:true, ttl:0.1, laser:true}); // ttl 감소
            }
          }, 1200);
        } else if(L.multiMode === 1) { // 2-way 레이저 (3-way에서 감소)
          for(let i=-0.5;i<=0.5;i+=1){ // 3개에서 2개로 감소
            const target = angleTo(b.x,b.y, player.x,player.y) + i*0.8; // 각도 간격 증가
            L.warm = 1.4; // 예고 시간 증가
            setTimeout(()=>{
              if(!boss || !boss.alive) return;
              const len=1000, w=8; // 길이와 폭 감소 (1200->1000, 10->8)
              for(let t=0;t<20;t++){ // 세그먼트 감소 (25->20)
                const d = (t/20)*len;
                spawnBullet({x:b.x+Math.cos(target)*d, y:b.y+Math.sin(target)*d, vx:0,vy:0, r:w, dmg:1.5, color:'#ffd24a', hostile:true, ttl:0.08, laser:true});
              }
            }, 1400);
          }
        } else { // 회전 레이저 - 회전 수 감소
          const baseAngle = angleTo(b.x,b.y, player.x,player.y);
          L.warm = 1.8; // 예고 시간 증가
          for(let rot=0; rot<3; rot++){ // 5개에서 3개로 감소
            setTimeout(()=>{
              if(!boss || !boss.alive) return;
              const target = baseAngle + rot*0.5; // 각도 간격 증가
              const len=1100, w=6; // 길이와 폭 감소 (1300->1100, 8->6)
              for(let t=0;t<28;t++){
                const d = (t/28)*len;
                spawnBullet({x:b.x+Math.cos(target)*d, y:b.y+Math.sin(target)*d, vx:0,vy:0, r:w, dmg:1, color:'#49f3ff', hostile:true, ttl:0.08, laser:true});
              }
            }, 1500 + rot*200);
          }
        }
      }
      if(L.warm>0) L.warm-=dt;
      
      // 추가: 레이저 간격에 소형 탄막
      if(L.warm <= 0 && chance(0.02)){
        const N=8; const speed=100;
        for(let i=0;i<N;i++){
          const a = i/N*TAU + b.timer;
          spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, r:3, dmg:1, color:'#ff71ff', hostile:true});
        }
      }
    },
    // 하이드라 코어 Phase 1 - 오비트 패턴 강화
    orbits(b,dt){
      if(!b._orb){ b._orb={t:0, pattern:0, switchTimer:0}; }
      b._orb.t+=dt; b._orb.switchTimer+=dt;
      
      // 패턴 변경 (4가지)
      if(b._orb.switchTimer > 7) { b._orb.pattern = (b._orb.pattern + 1) % 4; b._orb.switchTimer = 0; }
      
      const patterns = [
        {N:6, speed:120, rad:90, fireRate:0.02}, // 기본
        {N:8, speed:100, rad:70, fireRate:0.03}, // 밀집
        {N:4, speed:160, rad:110, fireRate:0.015}, // 빠른 4개
        {N:10, speed:80, rad:60, fireRate:0.04} // 느린 다수
      ];
      
      const p = patterns[b._orb.pattern];
      
      for(let i=0;i<p.N;i++){
        const a = b._orb.t*1.2 + i/p.N*TAU;
        const px=b.x+Math.cos(a)*p.rad, py=b.y+Math.sin(a)*p.rad;
        
        if(Math.floor((b._orb.t+i*0.3)*5)%5===0 && chance(p.fireRate)){
          const aim=angleTo(px,py, player.x,player.y);
          const colors = ['#49f3ff', '#ff71ff', '#ffd24a', '#ff3b5c'];
          spawnBullet({x:px,y:py,vx:Math.cos(aim)*p.speed,vy:Math.sin(aim)*p.speed,r:4,dmg:1,color:colors[b._orb.pattern],hostile:true});
        }
      }
      
      // 추가: 중앙에서 펄스 링
      if(Math.floor(b._orb.t*2)%6===0 && chance(0.05)){
        const N=12; const speed=90;
        for(let i=0;i<N;i++){
          const a = i/N*TAU + b._orb.t*0.5;
          spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, r:3, dmg:1, color:'#ff71ff', hostile:true});
        }
      }
    },
    // 하이드라 코어 Phase 2 - 드론 시스템 확장
    drones(b,dt){
      if(!b._dr){ b._dr={cd:0, list:[], formation:0, formationTimer:0}; }
      const D=b._dr; D.cd-=dt; D.formationTimer+=dt;
      
      // 포메이션 변경 (3가지)
      if(D.formationTimer > 8) { D.formation = (D.formation + 1) % 3; D.formationTimer = 0; }
      
      if(D.cd<=0 && D.list.length<6){
        D.cd = 2.8 - D.formation * 0.3;
        let newDrone;
        
        if(D.formation === 0) { // 랜덤 배치
          newDrone = {x:b.x+rand(-120,120), y:b.y+rand(-60,60), hp:8, t:0, type:'basic'};
        } else if(D.formation === 1) { // 원형 배치
          const angle = D.list.length * TAU/6;
          newDrone = {x:b.x+Math.cos(angle)*100, y:b.y+Math.sin(angle)*80, hp:6, t:0, type:'orbiter'};
        } else { // 라인 배치
          newDrone = {x:b.x + (D.list.length-2.5)*40, y:b.y-80, hp:10, t:0, type:'heavy'};
        }
        D.list.push(newDrone);
      }
      
      for(const d of D.list){
        if(!d.alive && d.hp<=0) continue;
        d.t+=dt;
        
        // 드론 타입별 행동
        if(d.type === 'basic') {
          d.x += Math.cos(d.t*2)*30*dt;
          d.y += Math.sin(d.t*2.2)*20*dt;
        } else if(d.type === 'orbiter') {
          const angle = d.t*1.5 + D.list.indexOf(d)*TAU/6;
          d.x = b.x + Math.cos(angle)*100;
          d.y = b.y + Math.sin(angle)*80;
        } else { // heavy
          d.x += Math.sin(d.t*1.5)*15*dt;
          d.y += Math.cos(d.t*1.8)*10*dt;
        }
        
        // 공격 패턴
        const fireChance = d.type === 'heavy' ? 0.08 : 0.05;
        if(Math.floor(d.t*5)%5===0 && chance(fireChance)){
          const a=angleTo(d.x,d.y, player.x,player.y);
          if(d.type === 'heavy') {
            // 3-way 공격
            for(let i=-1;i<=1;i++){
              const aa = a + i*0.2;
              spawnBullet({x:d.x,y:d.y,vx:Math.cos(aa)*220,vy:Math.sin(aa)*220,r:5,dmg:1,color:'#ffd24a',hostile:true});
            }
          } else {
            spawnBullet({x:d.x,y:d.y,vx:Math.cos(a)*200,vy:Math.sin(a)*200,r:4,dmg:1,color:'#ff71ff',hostile:true});
          }
        }
        
        // 피격 처리
        for(const k of bullets){
          if(!k.alive||k.hostile) continue;
          if(dist2(d.x,d.y,k.x,k.y) < (8+k.r)*(8+k.r)){
            d.hp-=k.dmg||1; k.alive=false;
            spawnPart({x:d.x,y:d.y,ttl:0.2,color:'#ff71ff',sz:6});
            if(d.hp<=0){ d.alive=false; spawnOrb(d.x,d.y, rand(2,4)); }
          }
        }
      }
      D.list = D.list.filter(d=>d.alive!==false);
    },
    // 하이드라 코어 Phase 3 - 광란 패턴 업그레이드
    frenzy(b,dt){
      if(!b._fz){ b._fz={cd:0,a:0,intensity:1,burstTimer:0}; }
      const F=b._fz; F.cd-=dt; F.a+=dt*4; F.burstTimer+=dt;
      
      // 강도 증가
      F.intensity = 1 + Math.floor(F.burstTimer/5) * 0.5;
      
      if(F.cd<=0){
        F.cd = 0.05 / F.intensity;
        const speed=180 + F.intensity*20;
        const a=F.a;
        const col=settings.colorBlind? '#ffd24a' : '#ff71ff';
        
        // 기본 3-way
        for(let i=0;i<3;i++){
          const aa=a+i*(TAU/3);
          spawnBullet({x:b.x,y:b.y,vx:Math.cos(aa)*speed,vy:Math.sin(aa)*speed,r:4,dmg:1,color:col,hostile:true});
        }
        
        // 강도에 따른 추가 패턴
        if(F.intensity >= 2) {
          // 6-way 추가
          for(let i=0;i<6;i++){
            const aa=a+i*(TAU/6)+TAU/12;
            spawnBullet({x:b.x,y:b.y,vx:Math.cos(aa)*speed*0.7,vy:Math.sin(aa)*speed*0.7,r:3,dmg:1,color:'#49f3ff',hostile:true});
          }
        }
        
        if(F.intensity >= 3) {
          // 추적 탄환 추가 - 발생 확률 감소
          if(chance(0.05)){
            spawnBullet({x:b.x,y:b.y, homing:true, r:6, spd:120, dmg:1, color:'#ff3b5c',hostile:true, ttl:8});
          }
        }
      }
      
      // 버스트 공격
      if(Math.floor(F.burstTimer)%4===0 && chance(0.03)){
        for(let ring=0;ring<2;ring++){
          const N=20; const speed=100+ring*50;
          for(let i=0;i<N;i++){
            const aa = i/N*TAU + ring*TAU/N/2;
            spawnBullet({x:b.x,y:b.y,vx:Math.cos(aa)*speed,vy:Math.sin(aa)*speed,r:4,dmg:1,color:'#ffd24a',hostile:true});
          }
        }
      }
    },
    // 타이탄 포지 Phase 2 - 해머 연타 패턴 (난이도 증가)
    hammer_barrage(b,dt){
      if(!b._hm){ b._hm={cd:1.0, pattern:0, comboTimer:0, targetX:W*0.5, targetY:H*0.6}; } // 초기 딜레이 감소
      const HM=b._hm; HM.cd-=dt; HM.comboTimer+=dt;
      
      // 패턴 변경 (3가지) - 더 빠른 변경
      if(HM.comboTimer > 6) { HM.pattern = (HM.pattern + 1) % 3; HM.comboTimer = 0; }
      
      if(HM.cd<=0){
        HM.cd = 1.2 + HM.pattern * 0.2; // 패턴별 간격 감소 (1.8->1.2)
        
        if(HM.pattern === 0) { // 직선 해머 스트라이크 - 강화
          // 플레이어를 향해 해머 발사
          const angle = angleTo(b.x, b.y, player.x, player.y);
          for(let i=0; i<5; i++) { // 3발 -> 5발
            setTimeout(() => {
              if(boss && boss.alive) {
                const spread = (i-2) * 0.15; // 5발 확산
                spawnBullet({
                  x: b.x + Math.cos(angle) * 30,
                  y: b.y + Math.sin(angle) * 30,
                  vx: Math.cos(angle + spread) * 320, // 속도 증가 (250->320)
                  vy: Math.sin(angle + spread) * 320,
                  r: 8, // 크기 증가 (7->8)
                  dmg: 1.5, // 데미지 증가
                  color: '#ffd24a',
                  hostile: true,
                  ttl: 2.5
                });
              }
            }, i * 120); // 딜레이 감소 (200->120)
          }
        } else if(HM.pattern === 1) { // 교차 해머 - 강화
          // X자 패턴으로 8방향 발사 (4->8)
          for(let i=0; i<8; i++) {
            const angle = (i * TAU/8); // 8방향
            spawnBullet({
              x: b.x,
              y: b.y,
              vx: Math.cos(angle) * 280, // 속도 증가 (200->280)
              vy: Math.sin(angle) * 280,
              r: 9, // 크기 증가 (8->9)
              dmg: 2, // 데미지 증가 (1.5->2)
              color: '#ff9b3b',
              hostile: true,
              ttl: 3.0
            });
          }
        } else { // 망치 폭격 - 강화
          // 랜덤 위치에 망치들이 떨어짐
          for(let i=0; i<6; i++) { // 개수 증가 (4->6)
            setTimeout(() => {
              if(boss && boss.alive) {
                const targetX = rand(100, W-100); // 범위 확대
                const targetY = rand(H*0.4, H-100);
                
                // 경고 표시 파티클
                for(let j=0; j<8; j++) { // 경고 파티클 증가
                  spawnPart({
                    x: targetX + rand(-25, 25),
                    y: targetY + rand(-25, 25),
                    ttl: 0.8, // 경고 시간 감소 (1.0->0.8)
                    color: '#ff3b5c',
                    sz: rand(4, 8)
                  });
                }
                
                // 0.8초 후 망치 투하
                setTimeout(() => {
                  if(boss && boss.alive) {
                    spawnBullet({
                      x: targetX,
                      y: targetY - 50,
                      vx: 0,
                      vy: 450, // 속도 증가 (350->450)
                      r: 12, // 크기 증가 (10->12)
                      dmg: 3, // 데미지 증가 (2->3)
                      color: '#ffd24a',
                      hostile: true,
                      ttl: 2.0
                    });
                  }
                }, 800); // 경고 시간 감소
              }
            }, i * 200); // 간격 감소 (300->200)
          }
        }
      }
      
      // 추가: 작은 파편 흩뿌리기 - 빈도 증가
      if(Math.floor(HM.comboTimer*2)%6===0 && chance(0.08)){ // 빈도 증가 (%10->%6, 0.03->0.08)
        const N=10; const speed=120; // 개수, 속도 증가 (6->10, 80->120)
        for(let i=0;i<N;i++){
          const a = i/N*TAU + Math.random()*0.4;
          spawnBullet({
            x: b.x + rand(-25, 25),
            y: b.y + rand(-25, 25),
            vx: Math.cos(a) * speed,
            vy: Math.sin(a) * speed,
            r: 4, // 크기 증가 (3->4)
            dmg: 1, // 데미지 증가 (0.5->1)
            color: '#ffaa44',
            hostile: true,
            ttl: 1.5
          });
        }
      }
    },
    // 타이탄 포지 Phase 2 - 메테오 패턴 강화
    meteors(b,dt){
      if(!b._mt){ b._mt={cd:0, pattern:0, salvoTimer:0}; }
      const M=b._mt; M.cd-=dt; M.salvoTimer+=dt;
      
      // 패턴 변경 (3가지)
      if(M.salvoTimer > 8) { M.pattern = (M.pattern + 1) % 3; M.salvoTimer = 0; }
      
      if(M.cd<=0){
        if(M.pattern === 0) { // 단발 추적
          M.cd = 1.0;
          const x = rand(40,W-40), y=-20;
          const a = angleTo(x,y, player.x+rand(-80,80), player.y);
          spawnBullet({x,y, vx:Math.cos(a)*260, vy:Math.sin(a)*260, r:9, dmg:2, color:'#ff9b3b',hostile:true});
        } else if(M.pattern === 1) { // 3연발
          M.cd = 1.8;
          for(let i=0;i<3;i++){
            setTimeout(()=>{
              if(!boss || !boss.alive) return;
              const x = rand(40,W-40), y=-20;
              const a = angleTo(x,y, player.x+rand(-60,60), player.y);
              spawnBullet({x,y, vx:Math.cos(a)*240, vy:Math.sin(a)*240, r:8, dmg:1.5, color:'#ffd24a',hostile:true});
            }, i*400);
          }
        } else { // 광역 폭격
          M.cd = 2.5;
          for(let i=0;i<6;i++){
            setTimeout(()=>{
              if(!boss || !boss.alive) return;
              const x = rand(60,W-60), y=-20;
              const targetX = rand(100,W-100), targetY = rand(200,H-100);
              const a = angleTo(x,y, targetX, targetY);
              spawnBullet({x,y, vx:Math.cos(a)*220, vy:Math.sin(a)*220, r:7, dmg:1, color:'#ff71ff',hostile:true});
            }, i*200);
          }
        }
      }
      
      // 추가: 용암 분출 (위에서 내려오는 탄막)
      if(chance(0.01)){
        const N=8;
        for(let i=0;i<N;i++){
          const x = rand(50,W-50);
          spawnBullet({x, y:-10, vx:rand(-30,30), vy:150, r:5, dmg:1, color:'#ff3b5c', hostile:true});
        }
      }
    },
    // 타이탄 포지 Phase 3 - 절망 패턴 완전체 (난이도 대폭 증가)
    desperate(b,dt){
      if(!b._dp){ 
        b._dp={
          t:0, 
          chaos:1, 
          lastBurst:0, 
          meteorTimer:0, 
          waveTimer:0,
          laserTimer:0,
          intensity:1
        }; 
      }
      const D=b._dp; 
      D.t+=dt; 
      D.chaos = Math.min(3, 1 + D.t*0.15); // 혼돈 수치 증가 속도 증가
      D.intensity = 1 + D.t * 0.2; // 강도 증가

      // 1. 메테오 레인 - 대폭 강화
      D.meteorTimer -= dt;
      if(D.meteorTimer <= 0){
        D.meteorTimer = Math.max(0.3, 1.2 - D.chaos*0.2); // 간격 대폭 감소
        
        // 동시에 여러 위치에 메테오
        const meteorCount = Math.floor(2 + D.chaos * 2); // 2~8개
        for(let i=0; i<meteorCount; i++){
          const px = rand(80, W-80);
          const py = rand(H*0.3, H-80);
          
          // 경고 이펙트 강화
          for(let j=0; j<12; j++){
            spawnPart({
              x: px + rand(-30, 30),
              y: py + rand(-30, 30),
              ttl: 0.6, // 경고 시간 감소
              color: '#ff3b5c',
              sz: rand(6, 12)
            });
          }
          
          setTimeout(()=>{
            if(boss && boss.alive){
              spawnBullet({
                x: px, y: py-60,
                vx: rand(-50, 50), vy: 400 + D.chaos*50, // 속도 증가
                r: 8 + D.chaos, dmg: 2 + D.chaos*0.5, // 크기, 데미지 증가
                color: '#ffd24a',
                hostile: true,
                ttl: 3.0
              });
            }
          }, 600);
        }
      }

      // 2. 스파이럴 웨이브 - 적당히 조정
      D.waveTimer -= dt;
      if(D.waveTimer <= 0){
        D.waveTimer = Math.max(0.4, 1.2 - D.chaos*0.2); // 간격 조정 (0.2->0.4, 0.8->1.2)
        
        const N = Math.floor(16 + D.chaos*4); // 탄환 수 감소 (24+8 -> 16+4)
        const layers = Math.floor(1 + D.chaos*0.3); // 레이어 수 감소 (0.5->0.3)
        
        for(let layer=0; layer<layers; layer++){
          for(let i=0; i<N; i++){
            const a = i/N*TAU + D.t*(1+layer*0.5) + layer*TAU/N/2;
            const speed = 120 + D.chaos*20 + layer*15; // 속도 감소 (140+30 -> 120+20, 20->15)
            const size = 5 + layer*1.5; // 크기 감소
            
            spawnBullet({
              x: b.x + Math.cos(a)*30,
              y: b.y + Math.sin(a)*30,
              vx: Math.cos(a)*speed,
              vy: Math.sin(a)*speed,
              r: size,
              dmg: 1 + layer*0.3, // 데미지 감소
              color: layer === 0 ? '#ff71ff' : '#ffd24a',
              hostile: true,
              ttl: 4.0
            });
          }
        }
      }

      // 3. 회전 탄환 - 적당히 조정 (기존 충격파 대신)
      if(Math.floor(D.t*3)%4===0 && chance(0.05 * D.chaos)){ // 빈도 감소 (4->3)
        const N=12 + D.chaos*2; const speed=180+D.chaos*30; // 개수 감소 (20+4 -> 12+2)
        for(let i=0;i<N;i++){
          const a = i/N*TAU + D.t*0.8;
          spawnBullet({
            x: b.x,
            y: b.y,
            vx: Math.cos(a)*speed,
            vy: Math.sin(a)*speed,
            r: 6 + D.chaos*0.3, // 크기 감소
            dmg: 1.2 + D.chaos*0.2, // 데미지 감소
            color: '#ffd24a',
            hostile: true,
            ttl: 3.5
          });
        }
      }

      // 4. 새로운 패턴: 혼돈 버스트 - 적당히 조정
      if(D.t - D.lastBurst > Math.max(3, 5 - D.chaos*0.4)){ // 간격 조정 (2->3, 4->5)
        D.lastBurst = D.t;
        
        // 동시 다발 공격 조정
        const N=32 + D.chaos*8; const speed=140; // 개수 감소 (48+16 -> 32+8)
        for(let i=0;i<N;i++){
          const a = i/N*TAU + Math.random()*0.4;
          setTimeout(()=>{
            if(boss && boss.alive){
              spawnBullet({
                x: b.x + rand(-30, 30), // 범위 감소
                y: b.y + rand(-30, 30),
                vx: Math.cos(a)*speed,
                vy: Math.sin(a)*speed,
                r: 5 + Math.random()*2, // 크기 감소
                dmg: 1.2,
                color: Math.random() > 0.5 ? '#ff71ff' : '#ff3b5c',
                hostile: true,
                ttl: 3.0
              });
            }
          }, Math.random()*1000); // 시간 간격 조정
        }
        
        // 추가: 레이저 스위프
        D.laserTimer = 2.0;
      }

      // 5. 레이저 스위프 (새로운 공격)
      if(D.laserTimer > 0){
        D.laserTimer -= dt;
        const progress = (2.0 - D.laserTimer) / 2.0;
        const angle = progress * TAU * 2; // 2바퀴 회전
        
        // 회전하는 레이저 빔
        for(let i=0; i<3; i++){ // 3개의 레이저
          const a = angle + i*TAU/3;
          for(let d=40; d<300; d+=15){
            const px = b.x + Math.cos(a)*d;
            const py = b.y + Math.sin(a)*d;
            if(px > 0 && px < W && py > 0 && py < H){
              spawnBullet({
                x: px, y: py,
                vx: 0, vy: 0,
                r: 8,
                dmg: 2,
                color: '#49f3ff',
                hostile: true,
                ttl: 0.1,
                laser: true
              });
            }
          }
        }
      }

      // 6. 추가 패턴: 추적 미사일
      if(Math.floor(D.t*1.5)%8===0 && chance(0.06 * D.chaos)){
        const homingCount = Math.floor(2 + D.chaos);
        for(let i=0;i<homingCount;i++){
          setTimeout(()=>{
            if(boss && boss.alive){
              spawnBullet({
                x: b.x + rand(-30, 30),
                y: b.y + rand(-30, 30),
                homing: true,
                r: 8,
                spd: 160 + i*20,
                dmg: 2,
                color: '#ff3b5c',
                hostile: true,
                ttl: 8,
                turnRate: 3.0
              });
            }
          }, i*200);
        }
      }
    }
  };

  // ===== 무기 구현 =====
  function handleWeaponFire(p, dt, wantsFire){
    const bw = p.weapon;
    
    // 플라즈마 캐논은 별도 처리 (fireCd 체크 우회)
    if(bw==='PLASMA'){
      if(wantsFire && !p.isCharging && p.fireCd <= 0) {
        p.isCharging = true;
        p.chargeTime = 0;
      }
      
      if(p.isCharging) {
        p.chargeTime += dt * 1.5; // Charge speed increased by 1.5x
        p.chargeTime = Math.min(2.0, p.chargeTime); // 최대 2초 충전
        
        // 충전 이펙트
        const chargeIntensity = p.chargeTime / 2.0;
        if(Math.random() < chargeIntensity * 0.8) {
          spawnPart({
            x: p.x + rand(-15, 15),
            y: p.y + rand(-15, 15),
            ttl: 0.2,
            color: `hsl(${180 + chargeIntensity * 60}, 100%, ${50 + chargeIntensity * 30}%)`,
            sz: rand(2, 4 + chargeIntensity * 3)
          });
        }
      }
      
      if(!wantsFire && p.isCharging) {
        // 발사!
        const chargeRatio = p.chargeTime / 2.0;
        const size = 6 + chargeRatio * 8; // 6~14
        const damage = (5.0 + chargeRatio * 10.0) * playerUp.dmg; // 5.0~15.0배 (2x buff from 2.5~7.5)
        const speed = 500 * playerUp.projSpeed;
        const penetration = Math.floor(chargeRatio * 4); // 0~4 관통
        
        spawnBullet({
          x: p.x + Math.cos(p.aim) * 20,
          y: p.y + Math.sin(p.aim) * 20,
          vx: Math.cos(p.aim) * speed,
          vy: Math.sin(p.aim) * speed,
          r: size,
          dmg: damage,
          color: `hsl(${180 + chargeRatio * 60}, 100%, ${60 + chargeRatio * 20}%)`,
          hostile: false,
          ttl: 2.5,
          penetration: penetration,
          plasma: true
        });
        
        // 발사 이펙트
        for(let i=0; i<15; i++) {
          spawnPart({
            x: p.x,
            y: p.y,
            vx: Math.cos(p.aim + rand(-0.4, 0.4)) * rand(50, 200),
            vy: Math.sin(p.aim + rand(-0.4, 0.4)) * rand(50, 200),
            ttl: rand(0.3, 0.8),
            color: `hsl(${180 + chargeRatio * 60}, 100%, ${60 + chargeRatio * 20}%)`,
            sz: rand(3, 6)
          });
        }
        
        p.isCharging = false;
        p.chargeTime = 0;
        p.fireCd = 0.4 / playerUp.rof;
      }
      return; // 플라즈마는 여기서 종료
    }
    
    // 원거리 공용: 사격 (플라즈마 제외)
    if(wantsFire && p.fireCd<=0){
      if(bw==='LASER'){
        // 지속빔: 짧게 펄스 형태(성능상)
        const len=900, seg=22, dmg=1.4*playerUp.dmg; // Damage buffed from 0.8 to 1.4
        for(let i=0;i<seg;i++){
          const d=i/seg*len;
          const px = p.x + Math.cos(p.aim)*d;
          const py = p.y + Math.sin(p.aim)*d;
          const b = spawnBullet({x:px,y:py,vx:0,vy:0,r:6,dmg,color:'#49f3ff',hostile:false,ttl:0.08}); // TTL up
        }
        p.fireCd = 0.15/ playerUp.rof; // Cooldown up
        // 픽셀 스타일 레이저 이펙트
        for(let i=0;i<4;i++) spawnPart({x:p.x+Math.cos(p.aim)*20+rand(-3,3),y:p.y+Math.sin(p.aim)*20+rand(-3,3),ttl:0.1,color:'#49f3ff',sz:rand(3,6)});
      }
      else if(bw==='SHOTGUN'){
        const K=6, spread=0.22; // Spread reduced for tighter pattern
        const spd=380*playerUp.projSpeed, dmg=2.4*playerUp.dmg; // Damage buffed from 1.8 to 2.4
        for(let i=0;i<K;i++){
          const a=p.aim + rand(-spread,spread);
          spawnBullet({x:p.x+Math.cos(a)*16,y:p.y+Math.sin(a)*16,vx:Math.cos(a)*spd,vy:Math.sin(a)*spd,r:4,dmg,color:'#ff71ff',hostile:false,ttl:1.3}); // TTL increased for range buff
        }
        p.fireCd=0.55/ playerUp.rof; // Cooldown up
        // 픽셀 스타일 산탄 발사 이펙트
        for(let i=0;i<6;i++) spawnPart({x:p.x+Math.cos(p.aim)*12+rand(-4,4),y:p.y+Math.sin(p.aim)*12+rand(-4,4),ttl:0.15,color:'#ff71ff',sz:rand(2,5)});
      }
      else if(bw==='ROCKET'){
        const a=p.aim, spd=300*playerUp.projSpeed; // Speed up
        spawnBullet({x:p.x+Math.cos(a)*18,y:p.y+Math.sin(a)*18,vx:Math.cos(a)*spd,vy:Math.sin(a)*spd,r:6,dmg:11.25*playerUp.dmg,color:'#ffd24a',hostile:false,ttl:2.4, explode:true}); // Damage buffed from 7.5 to 11.25 (1.5x increase)
        p.fireCd=0.65/ playerUp.rof; // Cooldown up
        // 픽셀 스타일 로켓 발사 이펙트
        for(let i=0;i<8;i++) spawnPart({x:p.x+Math.cos(p.aim+Math.PI)*15+rand(-2,2),y:p.y+Math.sin(p.aim+Math.PI)*15+rand(-2,2),ttl:0.2,color:'#ffd24a',sz:rand(3,6)});
      }
      else if(bw==='MINIGUN'){
        p.fireCd = 0.08 / playerUp.rof;
        const a = p.aim + rand(-0.05,0.05);
        const spd = 800*playerUp.projSpeed;
        const dmg = 10*playerUp.dmg;
        const range = 1*playerUp.range;
        spawnBullet({x:p.x,y:p.y,vx:Math.cos(a)*spd*1.1,vy:Math.sin(a)*spd*1.1,r:5,dmg:dmg*0.2,ttl:0.5*range,color:'#ffd24a',hostile:false}); // Damage nerfed from 0.25 to 0.15
      }
      else if(bw==='BOOMERANG'){
        p.fireCd = 1.2 / playerUp.rof;
        const speed = 400 * playerUp.projSpeed;
        const damage = 1.2 * playerUp.dmg; // 데미지 너프: 2.0 -> 1.2
        
        spawnBullet({
          x: p.x + Math.cos(p.aim) * 15,
          y: p.y + Math.sin(p.aim) * 15,
          vx: Math.cos(p.aim) * speed,
          vy: Math.sin(p.aim) * speed,
          r: 8,
          dmg: damage,
          color: '#00ff88',
          hostile: false,
          ttl: 4.0,
          boomerang: true,
          originX: p.x,
          originY: p.y,
          launched: now(),
          spinAngle: 0
        });
        
        // 부메랑 발사 이펙트
        for(let i=0; i<8; i++) {
          spawnPart({
            x: p.x,
            y: p.y,
            vx: Math.cos(p.aim + i*TAU/8) * 80,
            vy: Math.sin(p.aim + i*TAU/8) * 80,
            ttl: 0.4,
            color: '#00ff88',
            sz: rand(3, 5)
          });
        }
      }
      else if(bw==='SMG'){
        p.fireCd = 0.05 / playerUp.rof; // 매우 빠른 연사 (0.05초 간격)
        const a = p.aim + rand(-0.08, 0.08); // 약간의 반동
        const spd = 650 * playerUp.projSpeed; // 빠른 탄속
        const dmg = 6 * playerUp.dmg; // 낮은 기본 데미지
        const range = 0.6 * playerUp.range; // 짧은 사정거리
        
        spawnBullet({
          x: p.x + Math.cos(a) * 10,
          y: p.y + Math.sin(a) * 10,
          vx: Math.cos(a) * spd,
          vy: Math.sin(a) * spd,
          r: 3, // 작은 탄환
          dmg: dmg * 0.35, // 최종 데미지: 매우 낮음
          ttl: 0.4 * range, // 짧은 사정거리
          color: '#ffaa00',
          hostile: false
        });
        
        // SMG 발사 이펙트 (간단함)
        for(let i=0; i<2; i++) {
          spawnPart({
            x: p.x + Math.cos(p.aim) * 8 + rand(-2, 2),
            y: p.y + Math.sin(p.aim) * 8 + rand(-2, 2),
            ttl: 0.1,
            color: '#ffaa00',
            sz: rand(2, 4)
          });
        }
      }
      else if(bw==='SNIPER'){
        // 저격총 재장전 중인지 확인
        if(p.sniperReloading) {
          return; // 재장전 중이면 발사 불가
        }
        
        // 저격총 탄창 시스템
        if(p.sniperAmmo <= 0) {
          // 탄창이 비어있으면 긴 재장전 시작
          p.sniperReloading = true;
          p.sniperReloadTime = p.sniperMaxReloadTime;
          return; // 이번 프레임에는 발사하지 않음
        }
        
        // 탄약 소모
        p.sniperAmmo--;
        
        // 마지막 총알을 쏜 경우 자동으로 재장전 시작
        if(p.sniperAmmo <= 0) {
          p.sniperReloading = true;
          p.sniperReloadTime = p.sniperMaxReloadTime;
        }
        
        // 일반 발사 속도 (탄창 내 발사)
        p.fireCd = 1.8 / playerUp.rof; // 빠른 연사 (1.8초 간격으로 감소)
        const a = p.aim; // 정확한 조준
        const spd = 1200 * playerUp.projSpeed; // 매우 빠른 탄속
        const dmg = 50 * playerUp.dmg; // 높은 기본 데미지 (2x buff: 25->50)
        const range = 2.5 * playerUp.range; // 긴 사정거리
        
        spawnBullet({
          x: p.x + Math.cos(a) * 25,
          y: p.y + Math.sin(a) * 25,
          vx: Math.cos(a) * spd,
          vy: Math.sin(a) * spd,
          r: 4,
          dmg: dmg * 0.8, // 최종 데미지: 매우 높음 (50*0.8=40)
          ttl: 1.5 * range, // 긴 사정거리
          color: '#ff4444',
          hostile: false,
          penetration: 2 // 관통력 추가
        });
        
        // 저격총 발사 이펙트 (강력함)
        for(let i=0; i<15; i++) {
          spawnPart({
            x: p.x + Math.cos(p.aim + Math.PI) * 20 + rand(-5, 5),
            y: p.y + Math.sin(p.aim + Math.PI) * 20 + rand(-5, 5),
            ttl: 0.3,
            color: '#ff4444',
            sz: rand(4, 8)
          });
        }
      }
    }
  }

  // ===== 게임 루프 =====
  let lastT=now();
  let accFps=0, fps=0, fpsTick=0;

  let boss=null;

  function startRun(){
    // 초기화
    clearEntities();
    gameState=STATE.PLAY;
    stageIndex=0;
    totalTime=0;
    stageStartTime=0;
    cores=0;
    playerUp.dmg=1; playerUp.rof=1; playerUp.projSpeed=1; playerUp.range=1; playerUp.survivability=1; playerUp.special={};
    player = new Player();
    boss = new Boss(BOSSES[stageIndex]);
    stageStartTime=now();
    document.getElementById('bossHp').style.display='block';
    document.getElementById('playerHpLabel').textContent = Math.floor(player.hp);
    updateHpBar();
    hideStartMenu();
    loop();
  }

  function nextStage(){
    stageIndex++;
    if(stageIndex>=BOSSES.length){
      // 전 스테이지 클리어
      stageClearAll();
      return;
    }
    gameState = STATE.PLAY;
    portal = null;
    stageNote(`STAGE ${stageIndex+1}`);
    boss = new Boss(BOSSES[stageIndex]);
    updateHpBar();
  }

  function loop(){
    if(gameState===STATE.PLAY || gameState===STATE.STAGECLEAR){
      const t=now(); let dt=(t-lastT)/1000; lastT=t;
      dt=Math.min(0.033,dt);
      totalTime = (t-stageStartTime)/1000;

      update(dt);
      draw();

      requestAnimationFrame(loop);
    }else{
      // 일시정지 등 상태에서 타임스탬프 업데이트
      lastT=now();
    }
  }

  function update(dt){
    // 입력 이동/공격
    player?.update(dt);

    // 적탄 업데이트/충돌
    for(const b of bullets){
      if(!b.alive) continue;
      if(b.ring){ // 충격파형
        b.r += b.vr*dt;
        b.ttl -= dt;
      }else if(b.boomerang && !b.hostile){ // 부메랑
        const elapsed = (now() - b.launched) / 1000;
        b.spinAngle += dt * 15; // 회전 애니메이션
        
        if(elapsed < 1.5) {
          // 나가는 단계
          b.x += b.vx * dt;
          b.y += b.vy * dt;
        } else {
          // 돌아오는 단계
          const returnAngle = angleTo(b.x, b.y, b.originX, b.originY);
          const returnSpeed = 300 + (elapsed - 1.5) * 200; // 점점 빨라짐
          b.vx = Math.cos(returnAngle) * returnSpeed;
          b.vy = Math.sin(returnAngle) * returnSpeed;
          b.x += b.vx * dt;
          b.y += b.vy * dt;
          
          // 플레이어에게 복귀했는지 체크
          if(player && dist2(b.x, b.y, player.x, player.y) < 900) { // 30픽셀 반경
            b.alive = false;
            // 복귀 이펙트
            for(let i=0; i<6; i++) {
              spawnPart({
                x: b.x,
                y: b.y,
                vx: rand(-80, 80),
                vy: rand(-80, 80),
                ttl: 0.3,
                color: '#00ff88',
                sz: rand(2, 4)
              });
            }
          }
        }
        b.ttl -= dt;
      }else if(b.homing){
        const distToPlayer = Math.hypot(b.x - player.x, b.y - player.y);
        // 플레이어와 150픽셀 이내로 가까워지거나 이미 직진모드면 직진 모드 유지
        if(!b.straightMode && distToPlayer <= 150) {
          b.straightMode = true; // 직진모드 플래그 설정
        }
        
        if(!b.straightMode) {
          const a = angleTo(b.x,b.y, player.x,player.y);
          const currentAngle = Math.atan2(b.vy, b.vx);
          const turnRate = b.turnRate || 3.5;
          let angleDiff = a - currentAngle;
          // 각도 차이를 -π ~ π 범위로 정규화
          while(angleDiff > Math.PI) angleDiff -= 2*Math.PI;
          while(angleDiff < -Math.PI) angleDiff += 2*Math.PI;
          const newAngle = currentAngle + Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), turnRate * dt);
          b.vx = Math.cos(newAngle)*b.spd; 
          b.vy = Math.sin(newAngle)*b.spd;
        }
        // 직진 모드거나 가까우면 현재 방향 유지
        b.x+=b.vx*dt; b.y+=b.vy*dt; b.ttl-=dt;
      }else{
        b.x+=b.vx*dt; b.y+=b.vy*dt; b.ttl-=dt;
      }
      // 플레이어와 충돌(적탄)
      if(b.hostile && player?.alive){
        let hit=false;
        if(b.ring){
          // 원형 쉘 — 플레이어 중심 거리와 링 반지름 차이
          const d = Math.hypot(player.x-b.x, player.y-b.y);
          if(Math.abs(d-b.r) < (b.thick + player.r)) hit=true;
        }else{
          if(dist2(player.x,player.y,b.x,b.y) <= (player.r + b.r)*(player.r + b.r)) hit=true;
        }
        if(hit){
          b.alive=false;
          player.hit(b.dmg||1);
        }
      }
      // 보스와 플레이어탄 충돌
      if(!b.hostile && boss && boss.alive){
        if(b.laser){
          if(Math.hypot(boss.x-b.x,boss.y-b.y) <= b.r + boss.r) { boss.take(b.dmg||0.5); }
        }else{
          if(dist2(boss.x,boss.y,b.x,b.y) <= (boss.r + b.r)*(boss.r + b.r)){
            boss.take(b.dmg||1);
            
            // 플라즈마는 관통, 부메랑은 통과
            if(!b.plasma && !b.boomerang) {
              b.alive=false;
            } else if(b.plasma && b.penetration !== undefined) {
              b.penetration--;
              if(b.penetration < 0) b.alive = false;
              // 플라즈마 관통 이펙트
              for(let i=0; i<8; i++) {
                spawnPart({
                  x: b.x + rand(-10, 10),
                  y: b.y + rand(-10, 10),
                  ttl: rand(0.2, 0.4),
                  color: b.color,
                  sz: rand(3, 6)
                });
              }
            }
            
            if(b.explode){
              // 픽셀 스타일 폭발 이펙트
              for(let i=0;i<50;i++){
                const aa=Math.random()*TAU, sp=rand(80,280);
                const size = rand(2,8);
                const colors = ['#ffd24a', '#ff9b3b', '#ff71ff', '#ff3b5c'];
                const color = colors[Math.floor(Math.random()*colors.length)];
                spawnPart({
                 
                  x:b.x+rand(-5,5),
                  y:b.y+rand(-5,5),
                  vx:Math.cos(aa)*sp*0.6,
                  vy:Math.sin(aa)*sp*0.6,
                  sz:size,
                  ttl:rand(0.3,0.9),
                  color:color
                });
              }
              
              // 중심 폭발 코어
              for(let i=0;i<8;i++){
                spawnPart({
                  x:b.x,
                  y:b.y,
                  vx:rand(-50,50),
                  vy:rand(-50,50),
                  sz:rand(6,12),
                  ttl:0.4,
                  color:'#ffffff'
                });
              }
              
              // 폭발 범위 데미지
              if(dist2(b.x,b.y,boss.x,boss.y) < (100+boss.r)*(100+boss.r)){
                boss.take((b.dmg||1)*1.5);
              }
            }
          }
        }
      }
      // 화면 밖/수명 종료
      if(b.ttl<=0 || b.x<-60||b.x>W+60||b.y<-60||b.y>H+60) { b.alive=false; }
    }
    // 풀 정리
    for(let i=bullets.length-1;i>=0;i--) if(!bullets[i].alive) bulletPool.push(bullets.splice(i,1)[0]);

    // 플레이어 총알과 적 유도탄 충돌 처리
    for(let i=0; i<bullets.length; i++){
      const playerBullet = bullets[i];
      if(!playerBullet.alive || playerBullet.hostile) continue;
      
      for(let j=0; j<bullets.length; j++){
        const enemyBullet = bullets[j];
        if(!enemyBullet.alive || !enemyBullet.hostile || !enemyBullet.homing) continue;
        
        if(dist2(playerBullet.x, playerBullet.y, enemyBullet.x, enemyBullet.y) < (playerBullet.r + enemyBullet.r) * (playerBullet.r + enemyBullet.r)){
          // 부메랑과 플라즈마는 유도탄을 파괴하지만 계속 진행
          if(playerBullet.boomerang || playerBullet.plasma) {
            enemyBullet.alive = false;
            // 유도탄 파괴 이펙트만 생성
            for(let k=0; k<5; k++){
              spawnPart({
                x: enemyBullet.x + rand(-5, 5),
                y: enemyBullet.y + rand(-5, 5),
                ttl: rand(0.2, 0.4),
                color: enemyBullet.color,
                sz: rand(3, 6)
              });
            }
          } else {
            // 일반 총알은 서로 파괴
            playerBullet.alive = false;
            enemyBullet.alive = false;
            // 파괴 이펙트
            for(let k=0; k<5; k++){
              spawnPart({
                x: enemyBullet.x + rand(-5, 5),
                y: enemyBullet.y + rand(-5, 5),
                ttl: rand(0.2, 0.4),
                color: enemyBullet.color,
                sz: rand(3, 6)
              });
            }
          }
          break;
        }
      }
    }

    // 파티클
    for(const p of parts){
      p.ttl-=dt;
      if(p.vx) p.x += p.vx*dt;
      if(p.vy) p.y += p.vy*dt;
    }
    for(let i=parts.length-1;i>=0;i--) if(parts[i].ttl<=0){ partPool.push(parts.splice(i,1)[0]); }

    // 코어(경험치)
    for(const o of orbs){
      o.ttl-=dt;
      // 플레이어에게 끌림
      const a=angleTo(o.x,o.y, player.x,player.y);
      const s= 80 + (200*(1 - Math.min(1,Math.hypot(o.x-player.x,o.y-player.y)/300)));
      o.vx += Math.cos(a)*s*dt*0.6;
      o.vy += Math.sin(a)*s*dt*0.6;
      o.vx*=0.96; o.vy*=0.96;
      o.x+=o.vx*dt; o.y+=o.vy*dt;
      if(dist2(o.x,o.y,player.x,player.y) < (o.r+player.r)*(o.r+player.r)){
        cores += o.amt;
        o.alive=false;
      }
    }
    for(let i=orbs.length-1;i>=0;i--) if(!orbs[i].alive || orbs[i].ttl<=0) orbs.splice(i,1);

    // 보스
    if(boss && boss.alive) boss.update(dt);
    updateHpBar();

    // 포탈
    if (gameState === STATE.STAGECLEAR && portal) {
      portal.t += dt;
      if (player && dist2(player.x, player.y, portal.x, portal.y) < (player.r + portal.r) * (player.r + portal.r)) {
        nextStage();
      }
    }

    // UI 라벨
    document.getElementById('coreLabel').textContent = cores|0;
    document.getElementById('stageLabel').textContent = (stageIndex+1);

    // FPS
    if(settings.showFps){
      accFps++; fpsTick+=dt;
      if(fpsTick>=1){ fps=accFps; accFps=0; fpsTick=0; }
    }
  }

  function draw(){
    // 배경 네트워크
    ctx.clearRect(0,0,W,H);
    drawGrid();

    // 파티클/오브젝트/탄
    for(const o of orbs){
      drawPixelOrb(o.x, o.y, o.r, settings.colorBlind?'#00e5ff':'#49f3ff');
    }
    
    // 보스
    boss?.draw(ctx);

    // 포탈
    if (portal) {
      drawPixelPortal(portal.x, portal.y, portal.r, portal.t);
    }

    // 적탄
    for(const b of bullets){
      if(!b.alive) continue;
      if(b.ring){
        ctx.save();
        ctx.strokeStyle=b.color||'#49f3ff';
        ctx.lineWidth=b.thick||6;
        ctx.shadowBlur = 8;
        ctx.shadowColor = b.color||'#49f3ff';
        ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,TAU); ctx.stroke();
        ctx.restore();
      }else if(b.boomerang){
        // 부메랑 특별 렌더링
        ctx.save();
        ctx.translate(b.x, b.y);
        ctx.rotate(b.spinAngle || 0);
        ctx.fillStyle = b.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = b.color;
        // 부메랑 모양 (V자)
        ctx.fillRect(-b.r, -2, b.r*2, 4);
        ctx.fillRect(-2, -b.r, 4, b.r*2);
        ctx.restore();
      }else if(b.plasma){
        // 플라즈마 특별 렌더링
        ctx.save();
        ctx.fillStyle = b.color;
        ctx.shadowBlur = 15;
        ctx.shadowColor = b.color;
        ctx.fillRect(b.x - b.r, b.y - b.r, b.r*2, b.r*2);
        // 내부 코어
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(b.x - b.r*0.4, b.y - b.r*0.4, b.r*0.8, b.r*0.8);
        ctx.restore();
      }else{
        drawPixelBullet(b.x, b.y, b.r, b.color||'#49f3ff', !b.hostile);
      }
    }
    
    // 플레이어
    player?.draw(ctx);

    // 파티클
    for(const p of parts){
      drawPixelParticle(p.x, p.y, p.sz, p.color||'#fff', p.ttl);
    }

    // 대쉬 쿨다운 표시
    if(player && gameState === STATE.PLAY) {
      const dashRatio = 1 - (player.dashCd / player.dashCooldown);
      const barWidth = 60;
      const barHeight = 6;
      const barX = W - barWidth - 20;
      const barY = 50;
      
      ctx.save();
      // 배경
      ctx.fillStyle = '#333333';
      ctx.fillRect(barX, barY, barWidth, barHeight);
      // 진행도
      ctx.fillStyle = dashRatio >= 1 ? '#00ff88' : '#666666';
      ctx.fillRect(barX, barY, barWidth * dashRatio, barHeight);
      // 테두리
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 1;
      ctx.strokeRect(barX, barY, barWidth, barHeight);
      // 라벨
      ctx.fillStyle = '#ffffff';
      ctx.font = '12px monospace';
      ctx.fillText('DASH', barX, barY - 2);
      ctx.restore();
    }

    // 디버그
    if(settings.showFps){
      ctx.fillStyle='#9ff'; ctx.fillText(`${fps} fps`, 10, 16);
    }
    
    // 디버그 모드 표시
    if(settings.debugMode){
      ctx.fillStyle='#ff0000'; 
      ctx.font='16px monospace';
      ctx.fillText('DEBUG MODE - INVINCIBLE', 10, 40);
      ctx.font='12px monospace'; // 폰트 복원
    }
    
    // 저격총 탄약/재장전 표시
    if(player && player.weapon === 'SNIPER') {
      const dashBarX = W - 80; // 대쉬 바 위치 기준
      const dashBarY = 50;
      
      ctx.save();
      
      if(player.sniperReloading) {
        // 재장전 중 - 로딩 바 표시
        const reloadRatio = 1 - (player.sniperReloadTime / player.sniperMaxReloadTime);
        const barWidth = 60;
        const barHeight = 6;
        const barX = dashBarX - barWidth - 15;
        const barY = dashBarY;
        
        // 배경
        ctx.fillStyle = '#333333';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        // 진행도
        ctx.fillStyle = reloadRatio >= 1 ? '#ffaa00' : '#ff6666';
        ctx.fillRect(barX, barY, barWidth * reloadRatio, barHeight);
        // 테두리
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, barWidth, barHeight);
        // 라벨
        ctx.fillStyle = '#ffffff';
        ctx.font = '10px monospace';
        ctx.fillText('RELOAD', barX, barY - 2);
      } else {
        // 일반 상태 - 탄약 개수 표시
        const bulletSize = 6;
        const bulletSpacing = 10;
        const startX = dashBarX - (player.sniperMaxAmmo * bulletSpacing) - 15; // 대쉬 바 왼쪽에 위치
        const startY = dashBarY + 3; // 대쉬 바와 같은 높이
        
        for(let i = 0; i < player.sniperMaxAmmo; i++) {
          const x = startX + i * bulletSpacing;
          const y = startY;
          
          if(i < player.sniperAmmo) {
            // 남은 탄약 - 밝은 색
            ctx.fillStyle = '#ffaa00';
          } else {
            // 사용된 탄약 - 어두운 색
            ctx.fillStyle = '#333333';
          }
          
          // 총알 모양 그리기 (작은 원형)
          ctx.beginPath();
          ctx.arc(x, y, bulletSize/2, 0, Math.PI * 2);
          ctx.fill();
          
          // 총알 테두리
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.stroke();
        }
        
        // 라벨
        ctx.fillStyle = '#ffffff';
        ctx.font = '10px monospace';
        ctx.fillText('AMMO', startX - 5, dashBarY - 2);
      }
      ctx.restore();
    }
  }



 function drawGrid(){
    const t = now()*0.0005;
    ctx.save();
    
    // 픽셀 스타일 네온 그리드
    ctx.strokeStyle='rgba(73,243,255,0.12)';
    ctx.lineWidth=1;
    ctx.shadowBlur = 3;
    ctx.shadowColor = 'rgba(73,243,255,0.3)';
    
    // 수직선들
    for(let x=40; x<W; x+=40){
      const offset = Math.sin((x*0.01)+t*4)*3;
      ctx.beginPath();
      ctx.moveTo(x + offset, 80);
      ctx.lineTo(x + offset, H);
      ctx.stroke();
    }
    
    // 수평선들
    for(let y=80; y<H; y+=40){
      const offset = Math.sin((y*0.01)+t*5)*2;
      ctx.beginPath();
      ctx.moveTo(40, y + offset);
      ctx.lineTo(W, y + offset);
      ctx.stroke();
    }
    
    // 픽셀 도트들 (교차점에)
    ctx.fillStyle='rgba(255,113,255,0.15)';
    ctx.shadowBlur = 2;
    ctx.shadowColor = 'rgba(255,113,255,0.5)';
    for(let x=40; x<W; x+=120){
      for(let y=80; y<H; y+=120){
        const dotOffset = Math.sin(t*6 + x*0.01 + y*0.01)*2;
        ctx.fillRect(x + dotOffset - 1, y + dotOffset - 1, 2, 2);
      }
    }
    
    ctx.restore();
  }
  function neonCircle(x,y,r,color){
    ctx.save();
    ctx.shadowBlur=12; ctx.shadowColor=color; ctx.fillStyle=color;
    ctx.beginPath(); ctx.arc(x,y,r,0,TAU); ctx.fill();
    ctx.shadowBlur=0; ctx.restore();
  }

  // ===== 픽셀 아트 스타일 그래픽 함수들 =====
  function drawPixelSquare(x, y, size, color) {
    ctx.fillStyle = color;
    ctx.fillRect(Math.floor(x - size/2), Math.floor(y - size/2), size, size);
  }

  function drawPixelPlayer(x, y, r, aim) {
    const pixelSize = 3;
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(aim);
    
    // 플레이어 몸체 (십자 모양)
    ctx.fillStyle = '#49f3ff';
    ctx.shadowBlur = 8;
    ctx.shadowColor = '#49f3ff';
    
    // 중앙 코어
    ctx.fillRect(-6, -6, 12, 12);
    // 팔 부분
    ctx.fillRect(-12, -3, 6, 6);
    ctx.fillRect(6, -3, 6, 6);
    ctx.fillRect(-3, -12, 6, 6);
    ctx.fillRect(-3, 6, 6, 6);
    
    // 무기 표시
    ctx.fillStyle = '#ff71ff';
    ctx.fillRect(12, -2, 8, 4); // 무기
    
    ctx.restore();
  }

  function drawPixelBoss(x, y, r, color, phase) {
    const pixelSize = 4;
    const time = now() * 0.001;
    ctx.save();
    ctx.translate(x, y);
    
    // 보스 배경 글로우 - 자연스러운 원형 그라데이션
    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, r * 1.8);
    gradient.addColorStop(0, color + '44');
    gradient.addColorStop(0.3, color + '22');
    gradient.addColorStop(0.6, color + '11');
    gradient.addColorStop(1, color + '00');
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(0, 0, r * 1.8, 0, TAU);
    ctx.fill();
    
    // 추가 펄스 글로우 효과
    const pulseIntensity = Math.sin(time * 3) * 0.3 + 0.7;
    const pulseGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, r * 1.2 * pulseIntensity);
    pulseGradient.addColorStop(0, color + '33');
    pulseGradient.addColorStop(0.5, color + '11');
    pulseGradient.addColorStop(1, color + '00');
    
    ctx.fillStyle = pulseGradient;
    ctx.beginPath();
    ctx.arc(0, 0, r * 1.2 * pulseIntensity, 0, TAU);
    ctx.fill();
    
    // 보스 중앙 코어 - 더 크고 화려하게
    ctx.fillStyle = color;
    ctx.shadowBlur = 20;
    ctx.shadowColor = color;
    
    const coreSize = 28;
    ctx.fillRect(-coreSize/2, -coreSize/2, coreSize, coreSize);
    
    // 코어 내부 디테일
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(-8, -8, 16, 16);
    ctx.fillStyle = color;
    ctx.fillRect(-4, -4, 8, 8);
    
    // 페이즈별 복잡한 디테일
    if(phase === 0) { // 링 패턴 - 회전하는 링들
      ctx.fillStyle = color;
      // 외부 링
      for(let i = 0; i < 12; i++) {
        const angle = (i / 12) * TAU + time * 2;
        const px = Math.cos(angle) * 32;
        const py = Math.sin(angle) * 32;
        ctx.fillRect(px - 4, py - 4, 8, 8);
      }
      // 중간 링 (반대 방향)
      ctx.fillStyle = '#00e5ff';
      for(let i = 0; i < 8; i++) {
        const angle = (i / 8) * TAU - time * 1.5;
        const px = Math.cos(angle) * 22;
        const py = Math.sin(angle) * 22;
        ctx.fillRect(px - 3, py - 3, 6, 6);
      }
    } else if(phase === 1) { // 스파이럴 패턴 - 회전 암들
      // 주요 암들
      for(let arm = 0; arm < 4; arm++) {
        ctx.fillStyle = arm % 2 ? color : '#ff71ff';
        const baseAngle = (arm / 4) * TAU + time * 1.2;
        for(let seg = 1; seg <= 4; seg++) {
          const px = Math.cos(baseAngle) * (seg * 8);
          const py = Math.sin(baseAngle) * (seg * 8);
          const size = 7 - seg;
          ctx.fillRect(px - size/2, py - size/2, size, size);
        }
      }
      // 보조 암들
      ctx.fillStyle = '#ffd24a';
      for(let i = 0; i < 6; i++) {
        const angle = (i / 6) * TAU + time * 0.8;
        const px = Math.cos(angle) * 18;
        const py = Math.sin(angle) * 18;
        ctx.fillRect(px - 2, py - 2, 4, 4);
      }
    } else { // 레이저 패턴 - 충전 효과
      // 레이저 포트들
      ctx.fillStyle = '#ff3b5c';
      const ports = [
        {x: 0, y: -38, w: 6, h: 18},
        {x: 0, y: 38, w: 6, h: 18},
        {x: -38, y: 0, w: 18, h: 6},
        {x: 38, y: 0, w: 18, h: 6}
      ];
      
      for(const port of ports) {
        ctx.fillRect(port.x - port.w/2, port.y - port.h/2, port.w, port.h);
        // 충전 이펙트
        ctx.fillStyle = '#ffffff';
        const charge = Math.sin(time * 8) * 0.5 + 0.5;
        const chargeSize = port.w * charge * 0.6;
        ctx.fillRect(port.x - chargeSize/2, port.y - chargeSize/2, chargeSize, chargeSize);
        ctx.fillStyle = '#ff3b5c';
      }
      
      // 중앙에서 뻗어나가는 에너지 라인
      ctx.strokeStyle = '#ff3b5c';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for(let i = 0; i < 8; i++) {
        const angle = (i / 8) * TAU;
        const len = 15 + Math.sin(time * 6 + i) * 8;
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(angle) * len, Math.sin(angle) * len);
      }
      ctx.stroke();
    }
    
    // 보스 테두리 강조
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.shadowBlur = 15;
    ctx.shadowColor = color;
    ctx.strokeRect(-coreSize/2 - 2, -coreSize/2 - 2, coreSize + 4, coreSize + 4);
    
    ctx.restore();
  }

  function drawPixelBullet(x, y, r, color, isPlayer = false) {
    const pixelSize = Math.max(2, Math.floor(r * 0.8));
    ctx.save();
    
    if(isPlayer) {
      // 플레이어 탄환 - 더 밝고 선명
      ctx.fillStyle = color;
      ctx.shadowBlur = 6;
      ctx.shadowColor = color;
      ctx.fillRect(Math.floor(x - pixelSize/2), Math.floor(y - pixelSize/2), pixelSize, pixelSize);
      
      // 내부 코어
      const coreSize = Math.max(1, pixelSize - 2);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(Math.floor(x - coreSize/2), Math.floor(y - coreSize/2), coreSize, coreSize);
    } else {
      // 적 탄환 - 위험하고 다양한 모양
      ctx.fillStyle = color;
      ctx.shadowBlur = 8;
      ctx.shadowColor = color;
      
      const halfSize = pixelSize / 2;
      
      // 색상에 따라 다른 모양
      if(color.includes('#ff3b5c') || color.includes('#ff71ff')) {
        // 빨강/마젠타 계열 - 스파이크 다이아몬드
        ctx.beginPath();
        ctx.moveTo(x, y - halfSize * 1.3);
        ctx.lineTo(x + halfSize * 0.7, y - halfSize * 0.3);
        ctx.lineTo(x + halfSize * 1.3, y);
        ctx.lineTo(x + halfSize * 0.7, y + halfSize * 0.3);
        ctx.lineTo(x, y + halfSize * 1.3);
        ctx.lineTo(x - halfSize * 0.7, y + halfSize * 0.3);
        ctx.lineTo(x - halfSize * 1.3, y);
        ctx.lineTo(x - halfSize * 0.7, y - halfSize * 0.3);
        ctx.closePath();
        ctx.fill();
      } else if(color.includes('#00e5ff') || color.includes('#49f3ff')) {
        // 청록 계열 - 십자 모양
        ctx.fillRect(x - halfSize * 1.2, y - halfSize * 0.4, halfSize * 2.4, halfSize * 0.8);
        ctx.fillRect(x - halfSize * 0.4, y - halfSize * 1.2, halfSize * 0.8, halfSize * 2.4);
      } else if(color.includes('#ffd24a')) {
        // 노란색 - 별 모양
        ctx.beginPath();
        for(let i = 0; i < 8; i++) {
          const angle = (i * Math.PI) / 4;
          const radius = (i % 2 === 0) ? halfSize * 1.2 : halfSize * 0.6;
          const px = x + Math.cos(angle) * radius;
          const py = y + Math.sin(angle) * radius;
          if(i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
      } else {
        // 기본 - 다이아몬드 모양
        ctx.beginPath();
        ctx.moveTo(x, y - halfSize);
        ctx.lineTo(x + halfSize, y);
        ctx.lineTo(x, y + halfSize);
        ctx.lineTo(x - halfSize, y);
        ctx.closePath();
        ctx.fill();
      }
      
      // 내부 어두운 코어 추가
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = '#000000';
      const coreSize = Math.max(1, pixelSize * 0.3);
      ctx.fillRect(Math.floor(x - coreSize/2), Math.floor(y - coreSize/2), coreSize, coreSize);
    }
    
    ctx.restore();
  }

  function drawPixelParticle(x, y, size, color, ttl) {
    const alpha = Math.min(1, ttl * 3);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = color;
    ctx.shadowBlur = 4;
    ctx.shadowColor = color;
    
    const pixelSize = Math.max(1, Math.floor(size));
    ctx.fillRect(Math.floor(x - pixelSize/2), Math.floor(y - pixelSize/2), pixelSize, pixelSize);
    
    ctx.restore();
  }

  function drawPixelPortal(x, y, r, t) {
    ctx.save();
    ctx.translate(x, y);
    
    const pulse = 1 + 0.1 * Math.sin(t * 5);
    const rotation = t * 2;
    
    ctx.rotate(rotation);
    ctx.scale(pulse, pulse);
    
    // 포탈 링들
    ctx.strokeStyle = '#ff71ff';
    ctx.shadowBlur = 15;
    ctx.shadowColor = '#ff71ff';
    ctx.lineWidth = 4;
    
    for(let ring = 0; ring < 3; ring++) {
      const ringR = r * (0.3 + ring * 0.3);
      ctx.beginPath();
      
      // 픽셀화된 원 그리기
      const segments = 16;
      for(let i = 0; i <= segments; i++) {
        const angle = (i / segments) * TAU;
        const px = Math.cos(angle) * ringR;
        const py = Math.sin(angle) * ringR;
        
        if(i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.stroke();
    }
    
    // 중앙 코어
    ctx.fillStyle = '#ff71ff';
    ctx.fillRect(-4, -4, 8, 8);
    
    ctx.restore();
  }

  function drawPixelOrb(x, y, r, color) {
    ctx.save();
    
    // 외부 글로우
    ctx.fillStyle = color + '44';
    ctx.shadowBlur = 8;
    ctx.shadowColor = color;
    const outerSize = r * 2;
    ctx.fillRect(Math.floor(x - outerSize/2), Math.floor(y - outerSize/2), outerSize, outerSize);
    
    // 메인 오브
    ctx.fillStyle = color;
    ctx.shadowBlur = 4;
    const mainSize = r;
    ctx.fillRect(Math.floor(x - mainSize/2), Math.floor(y - mainSize/2), mainSize, mainSize);
    
    // 코어
    ctx.fillStyle = '#ffffff';
    ctx.shadowBlur = 0;
    const coreSize = Math.max(2, r * 0.5);
    ctx.fillRect(Math.floor(x - coreSize/2), Math.floor(y - coreSize/2), coreSize, coreSize);
    
    ctx.restore();
  }

  // ===== 레벨업 카드 =====
  const LVL_CARDS = [
    {id:'DMG', text:'공격력 +20%', apply:()=>playerUp.dmg*=1.2},
    {id:'ROF', text:'연사속도 +15%', apply:()=>playerUp.rof*=1.15},
    {id:'SPD', text:'탄속 +20%', apply:()=>playerUp.projSpeed*=1.2},
    {id:'RANGE', text:'사거리 +15%', apply:()=>playerUp.range*=1.15},
    {id:'HEART', text:'최대 체력 +1 (즉시 회복)', apply:()=>{player.hpMax += 1; player.hp = Math.min(player.hp + 1, player.hpMax); playerUp.survivability*=1.05}},
    {id:'SPECIAL_LASER', text:'레이저 과열 내성↑(쿨 -15%)', apply:()=>playerUp.special.laserCool = (playerUp.special.laserCool||1)*0.85},
    {id:'CORE_MAGNET', text:'코어 흡입 강화', apply:()=>playerUp.special.magnet = (playerUp.special.magnet||0)+1}
  ];
  function presentUpgradeChoices(){
    // 카드 3개
    const picks=[];
    while(picks.length<3){
      const c = LVL_CARDS[(Math.random()*LVL_CARDS.length)|0];
      if(!picks.includes(c)) picks.push(c);
    }
    const holder = document.getElementById('cardHolder');
    holder.innerHTML='';
    for(const c of picks){
      const div=document.createElement('div');
      div.className='cardOpt';
      div.innerHTML=`<b>${c.text}</b><div class="hint tiny">${c.id}</div>`;
      div.onclick=()=>{
        c.apply(); hideLvl();
      };
      holder.appendChild(div);
    }
    showLvl();
  }

  // ===== 히트스톱 =====
  let _hitstopUntil=0;
  function hitstop(ms){
    _hitstopUntil = Math.max(_hitstopUntil, now()+ms);
  }

  // ===== HP바 =====
  function updateHpBar(){
    const bar = document.getElementById('bossHpFill');
    if(!boss||!boss.alive){ bar.style.width='0%'; return; }
    bar.style.width = (boss.hpRatio*100).toFixed(1)+'%';
  }

  // ===== 상태 전환 =====
  function stageClear(){
    document.getElementById('bossHp').style.display='none';
    setTimeout(()=>{
      nextStage();
      document.getElementById('bossHp').style.display='block';
    }, 900);
  }
  function stageClearAll(){
    gameState=STATE.STAGECLEAR;
    const timeSec = totalTime;
    // 기록 저장
    if(!save.bestTimeSec || timeSec < save.bestTimeSec){
      save.bestTimeSec = timeSec;
      save.bestStage = BOSSES.length;
      saveNow();
    }
    showStartMenu();
  }
  function gameOver(){
    gameState=STATE.GAMEOVER;
    // 기록 업데이트(최고 스테이지)
    if((stageIndex+1) > (save.bestStage||0)){
      save.bestStage = stageIndex+1;
      save.bestTimeSec = totalTime;
      saveNow();
    }
    showStartMenu('GAME OVER');
  }

  function showStartMenu(note){
    const menu=document.getElementById('menuStart');
    menu.style.display='flex';
    if(note) menu.querySelector('h1').textContent = `NEON BOSS HUNTER — ${note}`;
  }
  function hideStartMenu(){
    document.getElementById('menuStart').style.display='none';
  }

  function showLvl(){
    gameState=STATE.LEVELUP;
    document.getElementById('lvlup').style.display='flex';
  }
  function hideLvl(){
    document.getElementById('lvlup').style.display='none';
    
    // 다음 스테이지로 진행
    stageIndex++;
    if(stageIndex>=BOSSES.length){
      // 전 스테이지 클리어
      stageClearAll();
      return;
    }
    
    gameState = STATE.PLAY;
    stageNote(`STAGE ${stageIndex+1}`);
    boss = new Boss(BOSSES[stageIndex]);
    updateHpBar();
  }

  function togglePause(){
    if(gameState===STATE.PLAY){ gameState=STATE.PAUSE; }
    else if(gameState===STATE.PAUSE){ gameState=STATE.PLAY; loop(); }
  }

  // ===== 스테이지 노트 =====
  let noteTimer=0;
  function stageNote(text){
    const el=document.getElementById('stageNote');
    el.textContent=text;
    el.style.display='block';
    noteTimer=1.6;
    const hide=()=>{ if(noteTimer<=0){ el.style.display='none'; } else { noteTimer-=0.1; setTimeout(hide,100); } };
    setTimeout(hide,1000);
  }

  // ===== UI 세팅 =====
  function buildWeaponGrid(){
    const g=document.getElementById('weaponGrid');
    g.innerHTML='';
    for(const w of weapons){
      if(!save.unlockedWeapons[w.id]) continue; // 해금 제한이 있다면
      const d=document.createElement('div');
      d.className='weapon'; d.dataset.id=w.id;
      d.innerHTML=`<b>${w.name}</b><div>${w.desc}</div><div class="tiny">이동속도 계수: ${w.move}</div>`;
      d.onclick=()=>{
        chosenWeapon=w.id;
        [...g.children].forEach(c=>c.classList.remove('sel'));
        d.classList.add('sel');
      };
      if(w.id===chosenWeapon) d.classList.add('sel');
      g.appendChild(d);
    }
  }
  function buildKeyList(){
    const list=document.getElementById('keyList');
    list.innerHTML='';
    const items = [
      ['up','위'],['down','아래'],['left','왼쪽'],['right','오른쪽'],
      ['fire','사격'],['melee','근접'],['dash','대시'],['pause','일시정지']
    ];
    for(const [id,label] of items){
      const row=document.createElement('div');
      row.className='row'; row.style.margin='6px 0';
      const btn=document.createElement('div');
      btn.className='btn pill';
      btn.textContent=settings.keys[id];
      btn.onclick=()=>{
        btn.textContent='눌러서 설정...';
        const onKey=(e)=>{
          e.preventDefault();
          settings.keys[id]= e.code || 'MouseLeft';
          btn.textContent=settings.keys[id];
          save.settings=settings; saveNow();
          removeEventListener('keydown', onKey);
          removeEventListener('mousedown', onMouse);
        };
        const onMouse=(e)=>{
          settings.keys[id]='MouseLeft';
          btn.textContent='MouseLeft';
          save.settings=settings; saveNow();
          removeEventListener('keydown', onKey);
          removeEventListener('mousedown', onMouse);
        };
        addEventListener('keydown', onKey, {once:true});
        addEventListener('mousedown', onMouse, {once:true});
      }
      row.innerHTML=`<div style="width:80px">${label}</div>`;
      row.appendChild(btn);
      list.appendChild(row);
    }
  }

  // 이벤트 바인딩
  document.getElementById('btnStart').onclick=()=>startRun();
  document.getElementById('btnSettings').onclick=()=>{ document.getElementById('modalSettings').style.display='flex'; buildKeyList(); }
  document.getElementById('btnCloseSettings').onclick=()=>{ document.getElementById('modalSettings').style.display='none'; }
  document.getElementById('btnResetSave').onclick=()=>{ localStorage.removeItem(SAVE_KEY); save=loadSave(); settings=save.settings; saveNow(); buildWeaponGrid(); buildKeyList(); };
  document.getElementById('btnDebug').onclick=()=>{ settings.showHitbox = !settings.showHitbox; save.settings=settings; saveNow(); };
  document.getElementById('btnPause').onclick=()=>togglePause();

  // 옵션
  document.getElementById('optColorBlind').onchange=(e)=>{ settings.colorBlind=e.target.checked; save.settings=settings; saveNow(); }
  document.getElementById('optShowHitbox').onchange=(e)=>{ settings.showHitbox=e.target.checked; save.settings=settings; saveNow(); }
  document.getElementById('optShowFps').onchange=(e)=>{ settings.showFps=e.target.checked; save.settings=settings; saveNow(); }
  document.getElementById('optVibrate').onchange=(e)=>{ settings.vibrate=e.target.checked; save.settings=settings; saveNow(); }

  buildWeaponGrid(); buildKeyList(); refreshUIFromSave();

  // 시작 시 메뉴 표시
  showStartMenu();
})();
</script>
</body>
</html>
