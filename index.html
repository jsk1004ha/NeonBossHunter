<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>NEON BOSS HUNTER â€” Bullet Hell + Action</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0a0f1f;
    --panel:#0f1630;
    --txt:#e6f3ff;
    --accent:#49f3ff;
    --accent2:#ff71ff;
    --danger:#ff3b5c;
    --ok:#5bff8c;
    --warn:#ffd24a;
    --neonShadow: 0 0 10px var(--accent), 0 0 20px var(--accent2);
    --font-clean: 'Orbitron', monospace;
  }
  body{margin:0;background:radial-gradient(1200px 600px at 50% 30%,#101836 0%,#0a0f1f 50%,#050811 100%);color:var(--txt);font-family:var(--font-clean);overscroll-behavior:none;}
  #uiLayer{position:fixed;inset:0;pointer-events:none;}
  canvas{display:block;margin:40px auto 0;max-width:100vw;max-height:calc(100vh - 40px);touch-action:none;image-rendering: pixelated;}
  .topbar{position:fixed;left:0;right:0;top:0;display:flex;justify-content:center;gap:12px;padding:8px 12px;pointer-events:auto;background:rgba(16,24,48,.9);backdrop-filter: blur(6px);border-bottom:1px solid rgba(120,160,255,.25);z-index:1000}
  .pill{background:rgba(16,24,48,.7);backdrop-filter: blur(6px);border:1px solid rgba(80,140,255,.25);border-radius:2px;padding:6px 12px;box-shadow: var(--neonShadow);display:flex;align-items:center;gap:8px;}
  .btn{pointer-events:auto;cursor:pointer;user-select:none}
  .btn:hover{filter:brightness(1.1)}
  .menu{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(3,8,16,.75), rgba(3,8,16,.9));backdrop-filter: blur(6px);pointer-events:auto}
  .card{width:min(980px,92vw);max-height:86vh;overflow:auto;background:var(--panel);border:1px solid rgba(120,160,255,.25);border-radius:4px;padding:18px 18px 22px;box-shadow:0 10px 40px rgba(0,0,0,.45), 0 0 30px rgba(120,160,255,.15);}
  h1{margin:0 0 10px 0;font-size:28px;font-weight:900;text-shadow:0 0 20px var(--accent);}
  h2{margin:12px 0 8px 0;font-size:20px;font-weight:700;}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:12px}
  .weapon{border:1px solid rgba(120,160,255,.3);border-radius:2px;padding:12px;background:rgba(12,18,40,.8);display:flex;flex-direction:column;gap:8px}
  .weapon.sel{outline:2px solid var(--accent);box-shadow:0 0 20px rgba(73,243,255,.35) inset}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .chip{border:1px solid rgba(120,160,255,.25);background:rgba(12,18,40,.7);border-radius:2px;padding:4px 10px}
  .kbd{font-family:ui-monospace,Menlo,Consolas,monospace;border:1px solid rgba(255,255,255,.2);background:#0b1226;border-radius:2px;padding:2px 6px}
  .floating{position:fixed;right:12px;bottom:12px;display:flex;flex-direction:column;gap:8px}
  .floating .btn{border:1px solid rgba(120,160,255,.25);background:rgba(12,18,40,.8);border-radius:2px;padding:10px 12px}
  .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);backdrop-filter: blur(2px);pointer-events:auto}
  .modal .card{width:min(720px,92vw)}
  .hpbar{position:fixed;left:50%;transform:translateX(-50%);top:60px;width:min(880px,92vw);height:16px;background:rgba(20,28,55,.8);border-radius:2px;border:1px solid rgba(120,160,255,.3);overflow:hidden}
  .hpfill{height:100%;background:linear-gradient(90deg,#ff4d7e,#ffd24a);box-shadow:0 0 12px rgba(255,77,126,.6) inset}
  .stageNote{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);font-size:28px;padding:10px 16px;background:rgba(0,0,0,.35);border:1px solid rgba(120,160,255,.3);border-radius:2px;display:none;font-weight:700;text-shadow:0 0 15px var(--accent);}
  /* ëª¨ë°”ì¼ ì¡°ì´ìŠ¤í‹± */
  .stick{position:fixed;bottom:18px;width:140px;height:140px;border-radius:50%;border:1px solid rgba(120,160,255,.25);background:rgba(12,18,40,.55);backdrop-filter: blur(4px);pointer-events:auto;touch-action:none}
  .stick .knob{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:72px;height:72px;border-radius:50%;background:rgba(73,243,255,.35);border:2px solid rgba(73,243,255,.65);box-shadow:0 0 16px rgba(73,243,255,.5) inset}
  #stickMove{left:18px}
  #stickAim{right:18px}
  .attackBtn{position:fixed;right:22px;bottom:172px;width:92px;height:92px;border-radius:2px;border:2px solid rgba(255,113,255,.7);background:rgba(255,113,255,.2);backdrop-filter: blur(2px);pointer-events:auto;display:flex;align-items:center;justify-content:center;font-weight:700}
  .lvlup{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.6)}
  .cards{display:grid;grid-template-columns:repeat(3,1fr);gap:14px;width:min(980px,92vw)}
  .cardOpt{border:1px solid rgba(120,160,255,.35);background:rgba(10,18,40,.95);padding:16px;border-radius:2px;cursor:pointer}
  .cardOpt:hover{box-shadow:0 0 18px rgba(73,243,255,.25) inset}
  .hint{opacity:.8;font-size:12px}
  .tiny{font-size:11px;opacity:.8}
  .hidden{display:none !important}
</style>
</style>
</head>
<body>
<canvas id="game" width="1280" height="720"></canvas>
<div id="uiLayer" aria-hidden="true"></div>

<!-- ìƒë‹¨ HP/íŒ¨ë„ -->
<div class="hpbar" id="bossHp" style="display:none">
  <div id="bossName" style="position:absolute;left:10px;top:50%;transform:translateY(-50%);font-size:12px;font-weight:bold;"></div>
  <div class="hpfill" id="bossHpFill" style="width:100%"></div>
</div>
<div class="topbar">
  <div class="pill">â¤ï¸ <span id="playerHpLabel">3</span></div>
  <div class="pill">ìŠ¤í…Œì´ì§€ <span id="stageLabel">1-1</span></div>
  <div class="pill">ì½”ì–´ <span id="coreLabel">0</span></div>
  <div class="pill btn" id="btnSettings">ì„¤ì •</div>
  <div class="pill btn" id="btnDebug">ë””ë²„ê·¸</div>
</div>

<!-- ì‹œì‘ ë©”ë‰´: ë¬´ê¸° ì„ íƒ -->
<div class="menu" id="menuStart">
  <div class="card">
    <h1>NEON BOSS HUNTER</h1>
    <div class="tiny">íƒ‘ë‹¤ìš´ íƒ„ë§‰+ì•¡ì…˜ â€¢ PC/ëª¨ë°”ì¼ â€¢ ë„¤ì˜¨ í…Œë§ˆ â€¢ ë‹¨ì¼ HTML</div>
    <h2>ë¬´ê¸° ì„ íƒ</h2>
    <div class="grid" id="weaponGrid"></div>
    <div class="row" style="margin-top:12px">
      <span class="chip">ì¡°ì‘: WASD ì´ë™, ë§ˆìš°ìŠ¤ ì¡°ì¤€/ì‚¬ê²© â€¢ ëª¨ë°”ì¼ ë“€ì–¼ ì¡°ì´ìŠ¤í‹±</span>
    </div>
    <div style="margin-top:12px" class="row">
      <div class="btn pill" id="btnStart">ê²Œì„ ì‹œì‘</div>
      <div class="pill">ìµœê³  ê¸°ë¡: <span id="bestLabel">-</span></div>
    </div>
  </div>
</div>

<!-- ë ˆë²¨ì—… ì¹´ë“œ -->
<div class="lvlup" id="lvlup">
  <div class="cards" id="cardHolder"></div>
</div>

<!-- ì„¤ì • ëª¨ë‹¬ -->
<div class="modal" id="modalSettings">
  <div class="card">
    <h2>ì„¤ì •</h2>
    <div class="grid">
      <div class="weapon">
        <b>í‚¤ ë¦¬ë§µ</b>
        <div class="tiny">ë³€ê²½í•  í‚¤ í•­ëª©ì„ ëˆŒëŸ¬ ìƒˆ í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš”.</div>
        <div id="keyList"></div>
      </div>
      <div class="weapon">
        <b>ê·¸ë˜í”½ ì„¤ì •</b>
        <label>ê·¸ë˜í”½ ëª¨ë“œ:</label>
        <select id="optGraphicsMode">
          <option value="fancy">í™”ë ¤í•¨ (ëª¨ë“  íš¨ê³¼)</option>
          <option value="simple">ë‹¨ìˆœí•¨ (ê¸°ë³¸ íš¨ê³¼)</option>
          <option value="performance">ìµœì í™” (ìµœì†Œ íš¨ê³¼)</option>
        </select>
        <div class="tiny">í™”ë ¤í•¨: ëª¨ë“  íŒŒí‹°í´ê³¼ ì‹œê° íš¨ê³¼, ë‹¨ìˆœí•¨: ê¸°ë³¸ íš¨ê³¼ë§Œ, ìµœì í™”: ì„±ëŠ¥ ìš°ì„ </div><br/>
        
        <label>ìƒ‰ì•½ ë³´ì¡°:</label>
        <select id="optColorBlindMode">
          <option value="none">ì—†ìŒ</option>
          <option value="protanopia">ì ìƒ‰ë§¹ (Protanopia)</option>
          <option value="deuteranopia">ë…¹ìƒ‰ë§¹ (Deuteranopia)</option>
          <option value="tritanopia">ì²­ìƒ‰ë§¹ (Tritanopia)</option>
          <option value="high_contrast">ê³ ëŒ€ë¹„ ëª¨ë“œ</option>
        </select>
        <div class="tiny">ìƒ‰ìƒ êµ¬ë¶„ì´ ì–´ë ¤ìš´ ê²½ìš° ëŒ€ì²´ ìƒ‰ìƒìœ¼ë¡œ í‘œì‹œí•©ë‹ˆë‹¤</div>
      </div>
      <div class="weapon">
        <b>ê¸°íƒ€ ì˜µì…˜</b>
        <label><input type="checkbox" id="optShowHitbox"> íˆíŠ¸ë°•ìŠ¤ í‘œì‹œ</label><br/>
        <label><input type="checkbox" id="optShowFps"> FPS í‘œì‹œ</label><br/>
        <label><input type="checkbox" id="optVibrate"> ëª¨ë°”ì¼ ì§„ë™(Hit/í”¼ê²©)</label>
      </div>
      <div class="weapon">
        <b>ì €ì¥</b>
        <div>ë¡œì»¬ ì €ì¥ì—ëŠ” ìµœê³  ê¸°ë¡, ì„¤ì •, í•´ê¸ˆì´ í¬í•¨ë©ë‹ˆë‹¤.</div>
        <div class="row" style="margin-top:8px">
          <div class="btn pill" id="btnResetSave">ì €ì¥ ì´ˆê¸°í™”</div>
          <div class="btn pill" id="btnCloseSettings">ë‹«ê¸°</div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- ìŠ¤í…Œì´ì§€ ì•ˆë‚´ -->
<div class="stageNote" id="stageNote">STAGE 1</div>

<!-- ëª¨ë°”ì¼ ì¡°ì´ìŠ¤í‹±/ë²„íŠ¼ -->
<div id="stickMove" class="stick hidden"><div class="knob"></div></div>
<div id="stickAim" class="stick hidden"><div class="knob"></div></div>
<div id="btnAttack" class="attackBtn hidden">ê³µê²©</div>

<!-- í”Œë¡œíŒ… ë²„íŠ¼ -->
<div class="floating">
  <div class="btn" id="btnPause">â¸ ì¼ì‹œì •ì§€</div>
</div>

<script>
/**
 * NEON BOSS HUNTER â€” ë‹¨ì¼ íŒŒì¼ ì™„ì„±ë³¸
 * ìŠ¤í™:
 * - 1280x720 Canvas, íƒ‘ë‹¤ìš´, PC+ëª¨ë°”ì¼
 * - ë¬´ê¸°: ë ˆì´ì €/ì‚°íƒ„/ë¡œì¼“/ê¸°ê´€ì´(ì›ê±°ë¦¬), ê²€/ëŒ€ê²€/ë§ì¹˜(ê·¼ì ‘)
 * - ë ˆë²¨ì—… ì¹´ë“œ 3ì¤‘ íƒ1 (ê³µê²©ë ¥/ì—°ì‚¬/íƒ„ì†/ì‚¬ê±°ë¦¬/íŠ¹ìˆ˜ ë“±)
 * - ìŠ¤í…Œì´ì§€ ë°©ì‹, ë³´ìŠ¤ 1ëª…ì”©. ê° 2~3 í˜ì´ì¦ˆ
 * - ìƒ‰ì•½ ë³´ì¡°, íˆíŠ¸ë°•ìŠ¤/FPS í† ê¸€, í‚¤ ë¦¬ë§µ, ì§„ë™(ì˜µì…˜), ë¡œì»¬ ì €ì¥
 * - íˆíŠ¸ìŠ¤í†± 100ms, í”¼ê²© í›„ ë¬´ì  1ì´ˆ, í”Œë ˆì´ì–´ ì²´ë ¥ 3, ë¬´ê¸°ë³„ ì´ë™ì†ë„ ìƒì´
 */

(() => {
  // ===== ìœ í‹¸ =====
  const TAU = Math.PI*2;
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const rand = (a,b)=>Math.random()*(b-a)+a;
  const chance = (p)=>Math.random()<p;
  const now = ()=>performance.now();
  const dist2 = (ax,ay,bx,by)=>{let dx=ax-bx, dy=ay-by;return dx*dx+dy*dy;}
  const angleTo = (ax,ay,bx,by)=>Math.atan2(by-ay,bx-ax);
  const vec2 = (a)=>({x:Math.cos(a),y:Math.sin(a)});
  const vibrate = (ms)=>{try{ if(settings.vibrate && navigator.vibrate) navigator.vibrate(ms);}catch{}}

  // ===== ì €ì¥ =====
  const SAVE_KEY='neon_boss_hunter_v1';
  
  // ===========================================
  // ë””ë²„ê·¸ ëª¨ë“œ í™œì„±í™” ë°©ë²•:
  // debugMode: falseë¥¼ debugMode: trueë¡œ ë³€ê²½
  // íš¨ê³¼:
  // - í”Œë ˆì´ì–´ê°€ ë¬´ì ì´ ë˜ì–´ ëª¨ë“  ë°ë¯¸ì§€ë¥¼ ë¬´ì‹œí•©ë‹ˆë‹¤
  // - ë””ë²„ê·¸ ìºë…¼ ë¬´ê¸°ê°€ ë¬´ê¸° ì„ íƒì°½ì— ë‚˜íƒ€ë‚©ë‹ˆë‹¤
  // - ë””ë²„ê·¸ ìºë…¼: ê·¹ë„ë¡œ ê°•ë ¥í•œ ë°ë¯¸ì§€ (1000), ë¬´í•œ ê´€í†µ, ì´ˆê³ ì† ì—°ì‚¬
  // ===========================================
  
  const defaultSave = {
    bestTimeSec:null,
    bestStage:0,
    settings:{
      colorBlind:false, showHitbox:false, showFps:false, vibrate:true,
      debugMode:false, // ë””ë²„ê·¸ ëª¨ë“œ - ë¬´ì  (ì½”ë“œì—ì„œë§Œ ë³€ê²½ ê°€ëŠ¥)
      graphicsMode:'fancy', // 'fancy', 'simple', 'performance'
      colorBlindMode:'none', // 'none', 'protanopia', 'deuteranopia', 'tritanopia', 'high_contrast'
      keys:{up:'KeyW',down:'KeyS',left:'KeyA',right:'KeyD',fire:'MouseLeft',dash:'ShiftLeft',pause:'Escape'}
    },
    unlockedWeapons:{ LASER:true, SHOTGUN:true, ROCKET:true, MINIGUN:true, PLASMA:true, BOOMERANG:true, SMG:true, SNIPER:true, DEBUG_CANNON:true }
  };
  let save = loadSave();

  function loadSave(){
    try{
      const s = JSON.parse(localStorage.getItem(SAVE_KEY));
      if(!s) return structuredClone(defaultSave);
      // í•©ì¹˜ê¸°(ì‹ ê·œ í•„ë“œ ë³´ì •)
      return deepMerge(structuredClone(defaultSave), s);
    }catch{ return structuredClone(defaultSave); }
  }
  function deepMerge(a,b){
    for(const k in b){
      if(b[k] && typeof b[k]==='object' && !Array.isArray(b[k])){
        a[k] = deepMerge(a[k] ?? {}, b[k]);
      }else a[k]=b[k];
    }
    return a;
  }
  function saveNow(){
    localStorage.setItem(SAVE_KEY, JSON.stringify(save));
    refreshUIFromSave();
  }

  // ===== ì„¤ì • ì „ì—­ =====
  let settings = save.settings;
  function refreshUIFromSave(){
    // ê¸°ì¡´ ì„¤ì •ë“¤
    document.getElementById('optShowHitbox').checked = settings.showHitbox;
    document.getElementById('optShowFps').checked = settings.showFps;
    document.getElementById('optVibrate').checked = settings.vibrate;
    
    // ìƒˆë¡œìš´ ê·¸ë˜í”½ ë° ìƒ‰ì•½ ë³´ì¡° ì„¤ì •
    document.getElementById('optGraphicsMode').value = settings.graphicsMode || 'fancy';
    document.getElementById('optColorBlindMode').value = settings.colorBlindMode || 'none';
    
    document.getElementById('bestLabel').textContent = save.bestTimeSec ? `${save.bestTimeSec.toFixed(1)}s (Stage ${save.bestStage})` : '-';
  }

  // ===== ìƒ‰ì•½ ë³´ì¡° ë° ê·¸ë˜í”½ ëª¨ë“œ í•¨ìˆ˜ë“¤ =====
  function getColorBlindSafeColor(originalColor, colorType = 'bullet') {
    if (settings.colorBlindMode === 'none') return originalColor;
    
    // ìƒ‰ìƒë³„ ìƒ‰ì•½ ë³´ì¡° ë§¤í•‘
    const colorMaps = {
      'protanopia': {
        '#ff71ff': '#4da6ff', // ë§ˆì  íƒ€ -> íŒŒë‘
        '#49f3ff': '#ffff66', // ì‹œì•„ì•ˆ -> ë…¸ë‘
        '#ffd24a': '#66ff66', // ë…¸ë‘ -> ë°ì€ ì´ˆë¡
        '#ff3b5c': '#0080ff', // ë¹¨ê°• -> íŒŒë‘
        '#8B00FF': '#0066cc', // ë³´ë¼ -> ì§„í•œ íŒŒë‘
        '#4B0082': '#003399'  // ë‚¨ìƒ‰ -> ë” ì§„í•œ íŒŒë‘
      },
      'deuteranopia': {
        '#ff71ff': '#ff9933', // ë§ˆì  íƒ€ -> ì£¼í™©
        '#49f3ff': '#3366ff', // ì‹œì•„ì•ˆ -> íŒŒë‘
        '#ffd24a': '#ffff00', // ë…¸ë‘ -> ìˆœìˆ˜ ë…¸ë‘
        '#ff3b5c': '#ff6600', // ë¹¨ê°• -> ì£¼í™©
        '#8B00FF': '#6600cc', // ë³´ë¼ -> ì§„í•œ ë³´ë¼
        '#4B0082': '#330099'  // ë‚¨ìƒ‰ -> ì§„í•œ ë³´ë¼
      },
      'tritanopia': {
        '#ff71ff': '#ff3366', // ë§ˆì  íƒ€ -> ë¶„í™
        '#49f3ff': '#66ffcc', // ì‹œì•„ì•ˆ -> ë°ì€ ì´ˆë¡
        '#ffd24a': '#ff9900', // ë…¸ë‘ -> ì£¼í™©
        '#ff3b5c': '#cc0033', // ë¹¨ê°• -> ì§„í•œ ë¹¨ê°•
        '#8B00FF': '#990066', // ë³´ë¼ -> ì§„í•œ ë¶„í™
        '#4B0082': '#660033'  // ë‚¨ìƒ‰ -> ì§„í•œ ìì£¼
      },
      'high_contrast': {
        '#ff71ff': '#ffffff', // í°ìƒ‰
        '#49f3ff': '#ffff00', // ë…¸ë‘
        '#ffd24a': '#ff0000', // ë¹¨ê°•
        '#ff3b5c': '#00ff00', // ì´ˆë¡
        '#8B00FF': '#ffffff', // í°ìƒ‰
        '#4B0082': '#ff00ff', // ë§ˆì  íƒ€
        '#ffaa00': '#00ffff', // ì‹œì•„ì•ˆ
        '#ff4444': '#ffffff'  // í°ìƒ‰
      }
    };
    
    const map = colorMaps[settings.colorBlindMode];
    return map && map[originalColor] ? map[originalColor] : originalColor;
  }
  
  function shouldShowEffect(effectType) {
    if (settings.graphicsMode === 'performance') {
      // ì„±ëŠ¥ ëª¨ë“œ: ìµœì†Œí•œì˜ íš¨ê³¼ë§Œ
      return ['basic_bullet', 'basic_explosion'].includes(effectType);
    } else if (settings.graphicsMode === 'simple') {
      // ë‹¨ìˆœ ëª¨ë“œ: ê¸°ë³¸ íš¨ê³¼ë“¤
      return !['advanced_particles', 'complex_shadows', 'distortion_effects'].includes(effectType);
    }
    // í™”ë ¤í•¨ ëª¨ë“œ: ëª¨ë“  íš¨ê³¼
    return true;
  }
  
  function getEffectIntensity() {
    switch(settings.graphicsMode) {
      case 'performance': return 0.3;
      case 'simple': return 0.6;
      default: return 1.0; // fancy
    }
  }

  // ===== ìº”ë²„ìŠ¤/ìŠ¤ì¼€ì¼ =====
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');
  let W=cvs.width, H=cvs.height;
  function fitCanvas(){
    // CSSë¡œë§Œ ë°˜ì‘í˜• â€” ë‚´ë¶€ í•´ìƒë„ ê³ ì •(1280x720)
    // ëª¨ë°”ì¼ì¼ ë•Œ ì¡°ì´ìŠ¤í‹± í‘œì‹œ
    const isTouch = matchMedia('(pointer:coarse)').matches;
    toggleMobileUI(isTouch);
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

  // ===== ì…ë ¥ =====
  const keyState = new Set();
  const mouse = {x:W/2,y:H/2,down:false};
  let aimDir = 0; // ë§ˆìš°ìŠ¤/ìš°ì¸¡ ìŠ¤í‹± ê°ë„

  // í‚¤ ë§¤í•‘
  function isKey(code, action){
    const map = settings.keys;
    const target = map[action];
    if(code===target) return true;
    // íŠ¹ë³„ ì²˜ë¦¬: MouseLeft
    if(action==='fire' && code==='MouseLeft' && mouse.down) return true;
    return false;
  }

  addEventListener('keydown', e=>{
    keyState.add(e.code);
    if(isKey(e.code,'pause')) { togglePause(); e.preventDefault(); }
  });
  addEventListener('keyup', e=>{ keyState.delete(e.code); });
  cvs.addEventListener('mousedown', e=>{ mouse.down=true; });
  addEventListener('mouseup', e=>{ mouse.down=false; });
  cvs.addEventListener('mousemove', e=>{
    const rect=cvs.getBoundingClientRect();
    mouse.x = (e.clientX-rect.left)*W/rect.width;
    mouse.y = (e.clientY-rect.top)*H/rect.height;
    if(player) aimDir = angleTo(player.x,player.y,mouse.x,mouse.y);
  });

  // ===== ëª¨ë°”ì¼ ì¡°ì´ìŠ¤í‹± =====
  const stickMove = setupStick('stickMove');
  const stickAim  = setupStick('stickAim');
  const btnAttack = document.getElementById('btnAttack');
  let mobileAttack=false;

  btnAttack.addEventListener('touchstart', e=>{ e.preventDefault(); mobileAttack=true;});
  btnAttack.addEventListener('touchend', e=>{ e.preventDefault(); mobileAttack=false;});

  function setupStick(id){
    const el = document.getElementById(id);
    const knob = el.querySelector('.knob');
    const state = {active:false, vx:0, vy:0, angle:0, mag:0};
    let base={x:0,y:0};
    function setKnob(dx,dy){
      const r=55; // half range
      const m = Math.hypot(dx,dy);
      const cl = m>r ? r/m : 1;
      knob.style.left = (50 + (dx*cl)/1.4)+'%';
      knob.style.top  = (50 + (dy*cl)/1.4)+'%';
    }
    function onStart(cx,cy){
      state.active=true;
      base={x:cx,y:cy};
    }
    function onMove(cx,cy){
      if(!state.active) return;
      const dx=cx-base.x, dy=cy-base.y;
      const m=Math.hypot(dx,dy);
      state.mag = clamp(m/70,0,1);
      state.angle = Math.atan2(dy,dx);
      state.vx = Math.cos(state.angle)*state.mag;
      state.vy = Math.sin(state.angle)*state.mag;
      setKnob(dx,dy);
    }
    function onEnd(){
      state.active=false; state.vx=state.vy=state.mag=0;
      knob.style.left='50%'; knob.style.top='50%';
    }
    el.addEventListener('touchstart', e=>{
      e.preventDefault();
      const t=e.changedTouches[0];
      onStart(t.clientX,t.clientY);
    }, {passive:false});
    el.addEventListener('touchmove', e=>{
      e.preventDefault();
      const t=e.changedTouches[0];
      onMove(t.clientX,t.clientY);
    }, {passive:false});
    el.addEventListener('touchend', e=>{ e.preventDefault(); onEnd(); }, {passive:false});
    return state;
  }
  function toggleMobileUI(show){
    document.getElementById('stickMove').classList.toggle('hidden', !show);
    document.getElementById('stickAim').classList.toggle('hidden', !show);
    document.getElementById('btnAttack').classList.toggle('hidden', !show);
  }

  // ===== ê²Œì„ ìƒíƒœ =====
  const STATE = { MENU:0, PLAY:1, PAUSE:2, LEVELUP:3, STAGECLEAR:4, GAMEOVER:5 };
  let gameState = STATE.MENU;
  let stageIndex = 0; // 0..(bosses.length-1)
  let stageStartTime=0;
  let totalTime=0;
  let cores=0;
  let portal = null;

  // ===== í”Œë ˆì´ì–´/ë¬´ê¸° =====
  let player=null;
  const weapons = [
    {id:'LASER', name:'ë ˆì´ì €', desc:'ê´€í†µ ì§€ì†ë¹”, ê³¼ì—´ ê²Œì´ì§€', type:'ranged', move:1.00},
    {id:'SHOTGUN', name:'ì‚°íƒ„', desc:'í™•ì‚° ë‹¤ì¤‘íƒ„, ê·¼ì ‘ ê³ íš¨ìœ¨', type:'ranged', move:1.00},
    {id:'ROCKET', name:'ë¡œì¼“', desc:'í­ë°œ ë²”ìœ„ í”¼í•´/ë„‰ë°±', type:'ranged', move:0.95},
    {id:'MINIGUN', name:'ê¸°ê´€ì´', desc:'ê³ ì—°ì‚¬ ì €ë°˜ë™, ê³¼ì—´', type:'ranged', move:1.05},
    {id:'PLASMA', name:'í”Œë¼ì¦ˆë§ˆ', desc:'ì¶©ì „ì‹ ê³ ìœ„ë ¥ ê´€í†µíƒ„', type:'ranged', move:0.90},
    {id:'BOOMERANG', name:'ë¶€ë©”ë‘', desc:'ë˜ëŒì•„ì˜¤ëŠ” ê³¡ì„  íˆ¬ì‚¬ì²´', type:'ranged', move:1.05},
    {id:'SMG', name:'ê¸°ê´€ë‹¨ì´', desc:'ì´ˆê³ ì† ì—°ì‚¬, ê¸°ë™ì„± íŠ¹í™”', type:'ranged', move:1.25},
    {id:'SNIPER', name:'ì €ê²©ì´', desc:'ì¥ê±°ë¦¬ ê³ ìœ„ë ¥, ì •ë°€ ì‚¬ê²©', type:'ranged', move:0.75},
    {id:'DEBUG_CANNON', name:'ğŸ”§ ë””ë²„ê·¸ ìºë…¼', desc:'[DEV] ë¬´í•œ ê´€í†µ ì´ˆê³ ìœ„ë ¥ ë ˆì´ì €', type:'ranged', move:1.50, debug:true}
  ];
  let chosenWeapon = 'LASER';

  // ì—…ê·¸ë ˆì´ë“œ ê°€ëŠ¥í•œ ìŠ¤íƒ¯
  const playerUp = {
    dmg:1, rof:1, projSpeed:1, range:1, survivability:1, special: {}
  };

  // ===== ë³´ìŠ¤ ë°ì´í„°(ìŠ¤í…Œì´ì§€ì‹: ê° ë³´ìŠ¤ 1ëª…) =====
  // ê° ë³´ìŠ¤ëŠ” phases: [{pattern(time), hpRatioStart, hpRatioEnd}]
  const BOSSES = [
    {
      id:'RING_SENTINEL',
      name:'ë§ ì„¼í‹°ë„¬',
      color:'#49f3ff',
      baseHP:1000, // 2~5ë¶„ ë°¸ëŸ°ìŠ¤: ì‹¤ì œ ì „íˆ¬ëŠ” ë‚œì´ë„/ë¬´ê¸° ì—…ê¸€ì— ë”°ë¼ ë³€ë™
      phases:[
        { name:'Opening Rings',  until:0.66,  script:'rings' },
        { name:'Spiral+Target',  until:0.33,  script:'spiral_target' },
        { name:'Laser Sweep',    until:0.00,  script:'laser_sweep' }
      ]
    },
    {
      id:'HYDRA_CORE',
      name:'í•˜ì´ë“œë¼ ì½”ì–´',
      color:'#ff71ff',
      baseHP:1300,
      phases:[
        { name:'Orbit Orbs',     until:0.5,   script:'orbits' },
        { name:'Spawn Drones',   until:0.2,   script:'drones' },
        { name:'Frenzy Spiral',  until:0.0,   script:'frenzy' }
      ]
    },
    {
      id:'TITAN_FORGE',
      name:'íƒ€ì´íƒ„ í¬ì§€',
      color:'#ffd24a',
      baseHP:1600,
      phases:[
        { name:'Meteor Hammers', until:0.6,   script:'meteors' },
        { name:'Hammer Barrage', until:0.3,   script:'hammer_barrage' },
        { name:'Desperation',    until:0.0,   script:'desperate' }
      ]
    },
    {
      id:'VOID_REAPER',
      name:'ë³´ì´ë“œ ë¦¬í¼',
      color:'#8B00FF',
      baseHP:2000,
      phases:[
        { name:'Shadow Walls',   until:0.65,  script:'shadow_walls' },
        { name:'Space Distortion', until:0.30, script:'space_distortion' },
        { name:'Dimensional Collapse', until:0.0, script:'dimensional_collapse' }
      ]
    }
  ];

  // ===== ì—”í‹°í‹° í’€ =====
  const bullets=[]; const bulletPool=[];
  const parts=[]; const partPool=[];
  const orbs=[];  // ê²½í—˜ì¹˜ ì½”ì–´

  function spawnBullet(b){
    const o = bulletPool.pop() || {};
    
    // ìƒ‰ì•½ ë³´ì¡° ìƒ‰ìƒ ì ìš©
    const safeColor = getColorBlindSafeColor(b.color || '#ffffff', 'bullet');
    
    Object.assign(o,b,{alive:true,ttl:b.ttl??6,color:safeColor});
    bullets.push(o);

    // ì´í™íŠ¸ ê°•í™”: ë³´ìŠ¤ íƒ„í™˜ ë°œì‚¬ ì‹œ íŒŒí‹°í´ íš¨ê³¼ ì¶”ê°€ (ê·¸ë˜í”½ ëª¨ë“œ ê³ ë ¤)
    if (b.hostile && shouldShowEffect('bullet_spawn')) {
      const intensity = getEffectIntensity();
      const particleCount = Math.floor(2 * intensity);
      
      for(let i=0; i<particleCount; i++) {
        spawnPart({
          x: b.x, y: b.y,
          ttl: rand(0.1, 0.3) * intensity,
          color: safeColor,
          sz: rand(2, 4) * intensity,
          vx: (b.vx || 0) * 0.1 + rand(-30, 30),
          vy: (b.vy || 0) * 0.1 + rand(-30, 30)
        });
      }
    }

    return o;
  }
  function spawnPart(p){
    // ê·¸ë˜í”½ ëª¨ë“œì— ë”°ë¥¸ íŒŒí‹°í´ ì œí•œ
    if(settings.graphicsMode === 'performance' && Math.random() > 0.3) {
      return null; // 70% íŒŒí‹°í´ ì œê±°
    } else if(settings.graphicsMode === 'simple' && Math.random() > 0.6) {
      return null; // 40% íŒŒí‹°í´ ì œê±°
    }
    
    const o = partPool.pop() || {};
    const safeColor = getColorBlindSafeColor(p.color || '#ffffff', 'particle');
    const intensity = getEffectIntensity();
    
    Object.assign(o, p, {
      alive: true,
      ttl: (p.ttl ?? 0.6) * intensity,
      color: safeColor,
      sz: (p.sz || 3) * intensity
    });
    parts.push(o);
    return o;
  }
  function spawnOrb(x,y,amt=1){
    orbs.push({x,y,vx:rand(-50,50),vy:rand(-50,50),r:5,amt,alive:true,ttl:10});
  }

  function clearEntities() {
    bullets.length = 0;
    bulletPool.length = 0;
    parts.length = 0;
    partPool.length = 0;
    orbs.length = 0;
  }

  // ===== í”Œë ˆì´ì–´/ë³´ìŠ¤ í´ë˜ìŠ¤ =====
  class Player{
    constructor(){
      this.x=W*0.5; this.y=H*0.75;
      this.r=12; this.hp=3; this.hpMax=3; this.ifr=0;
      this.moveSpd=220; // base, weaponë³„ ê³„ìˆ˜ ì ìš©
      this.fireCd=0; this.meleeCd=0; this.dashCd=0; this.overheat=0;
      this.weapon=chosenWeapon;
      this.aim=0;
      this.alive=true;
      // í”Œë¼ì¦ˆë§ˆ ìºë…¼ìš©
      this.chargeTime=0;
      this.isCharging=false;
      // ì €ê²©ì´ íƒ„ì°½ ì‹œìŠ¤í…œ
      this.sniperAmmo=5;
      this.sniperMaxAmmo=5;
      this.sniperReloading=false;
      this.sniperReloadTime=0;
      this.sniperMaxReloadTime=7.5;
      // ë¡œì¼“ íƒ„ì°½ ì‹œìŠ¤í…œ
      this.rocketAmmo=4;
      this.rocketMaxAmmo=4;
      this.rocketReloading=false;
      this.rocketReloadTime=0;
      this.rocketMaxReloadTime=10.0; // ëŠë¦° ì¬ì¥ì „
      // ëŒ€ì‰¬ ì‹œìŠ¤í…œ
      this.isDashPreviewing=false;
      this.dashPreviewX=0;
      this.dashPreviewY=0;
      this.dashDistance=120;
      this.dashCooldown=2.0;
    }
    speed(){
      const w=weapons.find(w=>w.id===this.weapon);
      return this.moveSpd*(w?.move||1);
    }
    update(dt){
      if(!this.alive) return;
      
      // ëŒ€ì‰¬ ì¿¨ë‹¤ìš´ ê°ì†Œ
      this.dashCd = Math.max(0, this.dashCd - dt);
      
      // ì €ê²©ì´ ì¬ì¥ì „ ì²˜ë¦¬
      if(this.sniperReloading) {
        this.sniperReloadTime -= dt;
        if(this.sniperReloadTime <= 0) {
          this.sniperReloading = false;
          this.sniperAmmo = this.sniperMaxAmmo;
        }
      }
      
      // ë¡œì¼“ ì¬ì¥ì „ ì²˜ë¦¬
      if(this.rocketReloading) {
        this.rocketReloadTime -= dt;
        if(this.rocketReloadTime <= 0) {
          this.rocketReloading = false;
          this.rocketAmmo = this.rocketMaxAmmo;
        }
      }
      
      // ëŒ€ì‰¬ ì…ë ¥ ì²˜ë¦¬ (Left Shift)
      const isDashPressed = keyState.has('ShiftLeft');
      
      if(isDashPressed && this.dashCd === 0) {
        // ëŒ€ì‰¬ ë¯¸ë¦¬ë³´ê¸° - ì§€ì†ì ìœ¼ë¡œ í˜„ì¬ ìœ„ì¹˜ì™€ ì¡°ì¤€ ë°©í–¥ ê¸°ì¤€ìœ¼ë¡œ ì—…ë°ì´íŠ¸
        this.isDashPreviewing = true;
        const dashAngle = this.aim;
        this.dashPreviewX = clamp(this.x + Math.cos(dashAngle) * this.dashDistance, 20, W-20);
        this.dashPreviewY = clamp(this.y + Math.sin(dashAngle) * this.dashDistance, 20, H-20);
      } else if(!isDashPressed && this.isDashPreviewing) {
        // ëŒ€ì‰¬ ì‹¤í–‰
        this.x = this.dashPreviewX;
        this.y = this.dashPreviewY;
        this.dashCd = this.dashCooldown;
        this.isDashPreviewing = false;
        this.ifr = 0.3; // ëŒ€ì‰¬ í›„ ì§§ì€ ë¬´ì  ì‹œê°„
        
        // ëŒ€ì‰¬ ì´í™íŠ¸
        for(let i=0; i<12; i++) {
          spawnPart({
            x: this.x + rand(-15, 15),
            y: this.y + rand(-15, 15),
            ttl: 0.4,
            color: '#00ff88',
            sz: rand(3, 8)
          });
        }
      } else if(!isDashPressed) {
        // Shiftë¥¼ ëˆ„ë¥´ì§€ ì•Šìœ¼ë©´ ë¯¸ë¦¬ë³´ê¸° í•´ì œ
        this.isDashPreviewing = false;
      }
      
      // ì´ë™ ì…ë ¥
      let ix=0, iy=0;
      // ëª¨ë°”ì¼ ìš°ì„ 
      if(stickMove.mag>0.01){ ix+=stickMove.vx; iy+=stickMove.vy; }
      else {
        if(keyState.has(settings.keys.left)) ix-=1;
        if(keyState.has(settings.keys.right)) ix+=1;
        if(keyState.has(settings.keys.up)) iy-=1;
        if(keyState.has(settings.keys.down)) iy+=1;
      }
      const n = Math.hypot(ix,iy);
      if(n>0){ ix/=n; iy/=n; }
      const s=this.speed();
      this.x=clamp(this.x+ix*s*dt, 20, W-20);
      this.y=clamp(this.y+iy*s*dt, 20, H-20);

      // ì¡°ì¤€ ê°
      if(stickAim.mag>0.01){
        this.aim = stickAim.angle;
      }else{
        this.aim = aimDir;
      }

      // ë¬´ì  í”„ë ˆì„
      this.ifr = Math.max(0,this.ifr-dt);

      // ì‚¬ê²©/ê³µê²©
      this.fireCd=Math.max(0,this.fireCd-dt);

      const wantsFire = mouse.down || stickAim.mag>0.2 || keyState.has(settings.keys.fire);

      handleWeaponFire(this, dt, wantsFire);
    }
    draw(g){
      // ëŒ€ì‰¬ ë¯¸ë¦¬ë³´ê¸° ê·¸ë¦¬ê¸°
      if(this.isDashPreviewing) {
        g.save();
        g.globalAlpha = 0.6;
        g.strokeStyle = '#00ff88';
        g.setLineDash([5, 5]);
        g.lineWidth = 2;
        g.beginPath();
        g.moveTo(this.x, this.y);
        g.lineTo(this.dashPreviewX, this.dashPreviewY);
        g.stroke();
        g.setLineDash([]);
        
        // ëª©í‘œ ìœ„ì¹˜ í‘œì‹œ
        g.fillStyle = '#00ff8866';
        g.beginPath();
        g.arc(this.dashPreviewX, this.dashPreviewY, this.r, 0, TAU);
        g.fill();
        g.strokeStyle = '#00ff88';
        g.lineWidth = 2;
        g.stroke();
        g.restore();
      }
      
      // í”Œë ˆì´ì–´ â€” í”½ì…€ ì•„íŠ¸ ìŠ¤íƒ€ì¼
      if(this.ifr > 0 && Math.floor(now() / 100) % 2) return; // í”¼ê²© ì‹œ ê¹œë¹¡ì„
      drawPixelPlayer(this.x, this.y, this.r, this.aim);
      
      if(settings.showHitbox){
        g.save();
        g.strokeStyle='#ffffff66'; g.setLineDash([3,3]);
        g.beginPath(); g.arc(this.x, this.y, this.r, 0, TAU); g.stroke(); g.setLineDash([]);
        g.restore();
      }
    }
    hit(dmg){
      // ë””ë²„ê·¸ ëª¨ë“œì—ì„œëŠ” ë¬´ì 
      if(settings.debugMode) {
        console.log('DEBUG MODE: Damage ignored -', dmg);
        return;
      }
      
      if(this.ifr>0 || !this.alive) return;
      this.hp = Math.max(0, Math.floor(this.hp - dmg)); this.ifr=1.0;
      vibrate(40);
      hitstop(100);
      for(let i=0;i<15;i++) spawnPart({x:this.x+rand(-10,10),y:this.y+rand(-10,10),ttl:rand(0.3,0.6),color:'#ff3b5c',sz:rand(4,9)});
      if(this.hp<=0){ this.alive=false; gameOver(); }
      document.getElementById('playerHpLabel').textContent = Math.floor(this.hp);
    }
  }

  class Boss{
    constructor(cfg){
      this.cfg=cfg;
      this.x=W*0.5; this.y=H*0.28;
      this.r=42;
      this.hpMax=cfg.baseHP*(1+stageIndex*0.2);
      this.hp=this.hpMax;
      this.phaseIndex=0;
      this.timer=0;
      this.laserTimer=0;
      this.alive=true;
      this.color=cfg.color;
      this.script = cfg.phases[0].script;
      this.moveSpeed = 80;
      this.moveTimer = 0;
      this.moveTargetX = this.x;
      this.moveTargetY = this.y;
    }
    get hpRatio(){ return this.hp/this.hpMax; }
    update(dt){
      if(!this.alive) return;
      this.timer+=dt;

      // ë³´ìŠ¤ ì´ë™
      this.moveTimer -= dt;
      if (this.moveTimer <= 0) {
        this.moveTimer = rand(2, 4); // 2-4ì´ˆë§ˆë‹¤ ë°©í–¥ ë³€ê²½
        this.moveTargetX = W * 0.5 + rand(-200, 200);
        this.moveTargetY = H * 0.28 + rand(-100, 100);
      }

      const moveAngle = angleTo(this.x, this.y, this.moveTargetX, this.moveTargetY);
      const distToTarget = dist2(this.x, this.y, this.moveTargetX, this.moveTargetY);

      if (distToTarget > 25*25) {
          this.x += Math.cos(moveAngle) * this.moveSpeed * dt;
          this.y += Math.sin(moveAngle) * this.moveSpeed * dt;
      }

      // í˜ì´ì¦ˆ ì§„í–‰
      const p = this.cfg.phases[this.phaseIndex];
      if(this.hpRatio <= p.until){
        if(this.phaseIndex < this.cfg.phases.length-1){
          this.phaseIndex++;
          this.script = this.cfg.phases[this.phaseIndex].script;
          this.timer=0;
          stageNote(`${this.cfg.name} â€” ${this.cfg.phases[this.phaseIndex].name}`);
        }
      }
      // íŒ¨í„´ ì‹¤í–‰
      bossScripts[this.script]?.(this, dt);
    }
    draw(g){
      // ë³´ìŠ¤ â€” í”½ì…€ ì•„íŠ¸ ìŠ¤íƒ€ì¼
      drawPixelBoss(this.x, this.y, this.r, this.color, this.phaseIndex);
      
      if(settings.showHitbox){
        g.save();
        g.strokeStyle='#fff5'; g.setLineDash([4,4]); 
        g.beginPath(); g.arc(this.x, this.y, this.r, 0, TAU); g.stroke(); g.setLineDash([]);
        g.restore();
      }
    }
    take(dmg){
      this.hp-=dmg;
      spawnPart({x:this.x+rand(-this.r,this.r),y:this.y+rand(-this.r,this.r),ttl:0.25,color:this.color,sz:rand(5,10)});
      if(this.hp<=0 && this.alive){
        this.alive=false;
        // ëŒ€í­ë°œ + ì½”ì–´ ë“œë
        for(let i=0;i<60;i++) spawnPart({x:this.x+rand(-40,40),y:this.y+rand(-40,40),ttl:rand(0.5,1.2),color:this.color,sz:rand(8,16)});
        for(let i=0;i<20;i++) spawnOrb(this.x+rand(-30,30),this.y+rand(-30,30), rand(2,4));
        
        // ì²´ë ¥ íšŒë³µ
        player.hp = Math.min(player.hpMax, Math.floor(player.hp + player.hpMax * 0.5)); // 50% ì²´ë ¥ íšŒë³µ (ì •ìˆ˜ë¡œ)
        
        // ì§ì ‘ ì—…ê·¸ë ˆì´ë“œ í™”ë©´ í‘œì‹œ
        setTimeout(() => {
          presentUpgradeChoices();
        }, 500);
      }
    }
  }

  // ===== ë³´ìŠ¤ íŒ¨í„´ ìŠ¤í¬ë¦½íŠ¸ =====
  const bossScripts = {
    // ë§ ì„¼í‹°ë„¬ Phase 1 - í™•ì¥ëœ ë§ íŒ¨í„´
    rings(b,dt){
      if(!b._ring){ b._ring={cd:0, step:0, pattern:0, subTimer:0}; }
      const R=b._ring; R.cd-=dt; R.subTimer+=dt;
      
      // íŒ¨í„´ ë¡œí…Œì´ì…˜ (4ê°€ì§€ íŒ¨í„´)
      if(R.subTimer > 6) { R.pattern = (R.pattern + 1) % 4; R.subTimer = 0; }
      
      if(R.cd<=0){
        R.cd = 1.2 + R.pattern * 0.2; // íŒ¨í„´ë³„ íƒ€ì´ë° ì¡°ì ˆ
        const col = settings.colorBlind? '#00e5ff' : '#49f3ff';
        
        if(R.pattern === 0) { // ê¸°ë³¸ ë™ì‹¬ì› - ê°•í™”
          const N=28; const speed=150;
          for(let i=0;i<N;i++){
            const a=i/N*TAU + (R.step%2?0:TAU/N/2);
            spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, r:8, dmg:1, color:col, hostile:true});
          }
          // ì¶”ê°€ ë‚´ë¶€ ë§
          const N2=16; const speed2=80;
          for(let i=0;i<N2;i++){
            const a=i/N2*TAU + R.step*0.1;
            spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*speed2, vy:Math.sin(a)*speed2, r:6, dmg:1, color:'#00e5ff', hostile:true});
          }
        } else if(R.pattern === 1) { // í„ìŠ¤ ë§ - ê°•í™”
          const N=36; const speed=110 + Math.sin(R.step*0.5)*50;
          for(let i=0;i<N;i++){
            const a=i/N*TAU + R.step*0.1;
            spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, r:7, dmg:1, color:'#ff71ff', hostile:true});
          }
          // ì§€ì—° í„ìŠ¤
          setTimeout(()=>{
            if(!boss || !boss.alive) return;
            for(let i=0;i<N;i++){
              const a=i/N*TAU + R.step*0.1 + TAU/N/2;
              spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*(speed+30), vy:Math.sin(a)*(speed+30), r:5, dmg:1, color:'#ff3b5c', hostile:true});
            }
          }, 300);
        } else if(R.pattern === 2) { // êµì°¨ ë§ - ê°•í™”
          for(let ring=0; ring<3; ring++){
            const N=24; const speed=140 + ring*25;
            for(let i=0;i<N;i++){
              const a=i/N*TAU + ring*TAU/N/3 + R.step*0.15;
              const colors = ['#49f3ff', '#ffd24a', '#ff71ff'];
              spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, r:7, dmg:1, color:colors[ring], hostile:true});
            }
          }
        } else { // ê°€ë³€ ë°€ë„ ë§ - ê°•í™”
          const N=20 + Math.floor(Math.sin(R.step*0.3)*16); const speed=130;
          for(let i=0;i<N;i++){
            const a=i/N*TAU + R.step*0.08;
            const size = 6 + Math.sin(i*0.5 + R.step)*2;
            spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, r:size, dmg:1, color:'#ff3b5c', hostile:true});
          }
          // ë°˜ëŒ€ ë°©í–¥ íšŒì „
          for(let i=0;i<N/2;i++){
            const a=i/(N/2)*TAU - R.step*0.12;
            spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*speed*0.7, vy:Math.sin(a)*speed*0.7, r:5, dmg:1, color:'#00e5ff', hostile:true});
          }
        }
        R.step++;
      }
      
      // ì¶”ê°€ íŒ¨í„´: ì¶”ì  ë¯¸ì‚¬ì¼ - ìˆ˜ëŸ‰ ê°ì†Œ
      if(Math.floor(b.timer*2)%8===0 && chance(0.04)){
        const a = angleTo(b.x,b.y, player.x,player.y) + rand(-0.3,0.3);
        for(let i=0;i<2;i++){
          setTimeout(()=>{
            if(!boss || !boss.alive) return;
            spawnBullet({x:b.x,y:b.y, homing:true, r:8, spd:200, dmg:1, color:'#ff71ff', hostile:true, ttl:4.0, turnRate: 2.2});
          }, i*200);
        }
      }
    },
    // ë§ ì„¼í‹°ë„¬ Phase 2 - ìŠ¤íŒŒì´ëŸ´+íƒ€ê²Ÿ ë‹¤ì–‘í™”
    spiral_target(b,dt){
      if(!b._sp){ b._sp={a:0,cd:0,mode:0,modeTimer:0}; }
      const S=b._sp; S.a+=dt*2.5; S.cd-=dt; S.modeTimer+=dt;
      
      // ëª¨ë“œ ë³€ê²½ (3ê°€ì§€ ëª¨ë“œ)
      if(S.modeTimer > 5) { S.mode = (S.mode + 1) % 3; S.modeTimer = 0; }
      
      if(S.cd<=0){
        S.cd = 0.12 + S.mode * 0.03; // ë°œì‚¬ ê°„ê²© ì¦ê°€ (0.06->0.12, 0.02->0.03)
        const speed=140 + S.mode * 20;
        const a=S.a;
        const col=settings.colorBlind? '#ffd24a' : '#ff71ff';
        
        if(S.mode === 0) { // 2-way ìŠ¤íŒŒì´ëŸ´ - ê°„ê²© ì¦ê°€
          for(let arm=0; arm<2; arm++){
            const baseAngle = a + arm*TAU/2;
            spawnBullet({x:b.x,y:b.y, vx:Math.cos(baseAngle)*speed, vy:Math.sin(baseAngle)*speed, r:7, dmg:1, color:col, hostile:true});
            // ì¶”ê°€ ë¶„ê¸° - ê°œìˆ˜ ê°ì†Œ
            for(let sub=-1; sub<=1; sub+=2){
              if(Math.random() < 0.6) { // 60% í™•ë¥ ë¡œë§Œ ìƒì„±
                spawnBullet({x:b.x,y:b.y, vx:Math.cos(baseAngle+sub*0.3)*speed*0.7, vy:Math.sin(baseAngle+sub*0.3)*speed*0.7, r:4, dmg:1, color:'#00e5ff', hostile:true});
              }
            }
          }
        } else if(S.mode === 1) { // 4-way ìŠ¤íŒŒì´ëŸ´ - ì¤‘ê°„íƒ„ ì œê±°
          for(let i=0;i<4;i++){
            const aa = a + i*TAU/4;
            spawnBullet({x:b.x,y:b.y, vx:Math.cos(aa)*speed, vy:Math.sin(aa)*speed, r:7, dmg:1, color:'#49f3ff', hostile:true});
            // ì¤‘ê°„ ê°ë„ ì¶”ê°€ - í™•ë¥ ì  ìƒì„±
            if(Math.random() < 0.4) { // 40% í™•ë¥ ë¡œë§Œ ìƒì„±
              const midAngle = aa + TAU/8;
              spawnBullet({x:b.x,y:b.y, vx:Math.cos(midAngle)*speed*0.5, vy:Math.sin(midAngle)*speed*0.5, r:4, dmg:1, color:'#ff3b5c', hostile:true});
            }
          }
        } else { // 6-way ê°€ë³€ì†ë„ - ë°˜ëŒ€ë°©í–¥ íƒ„ ê°ì†Œ
          for(let i=0;i<6;i++){
            const aa = a + i*TAU/6;
            const spd = speed + Math.sin(a + i)*40;
            spawnBullet({x:b.x,y:b.y, vx:Math.cos(aa)*spd, vy:Math.sin(aa)*spd, r:7, dmg:1, color:'#ffd24a', hostile:true});
          }
          // ë°˜ëŒ€ ë°©í–¥ 3-way - ê°œìˆ˜ ê°ì†Œ
          if(Math.random() < 0.5) { // 50% í™•ë¥ ë¡œë§Œ ìƒì„±
            for(let i=0;i<2;i++){ // 3ê°œì—ì„œ 2ê°œë¡œ ê°ì†Œ
              const aa = -a + i*TAU/2;
              spawnBullet({x:b.x,y:b.y, vx:Math.cos(aa)*speed*0.6, vy:Math.sin(aa)*speed*0.6, r:5, dmg:1, color:'#ff71ff', hostile:true});
            }
          }
        }
      }
      
      // ì¶”ê°€: ë°”ìš´ì‹± íƒ„ - ë¹ˆë„ ê°ì†Œ
      if(Math.floor(b.timer*3)%12===0 && chance(0.03)){ // ì£¼ê¸° ì¦ê°€ (9->12), í™•ë¥  ê°ì†Œ (0.06->0.03)
        const base=angleTo(b.x,b.y, player.x,player.y);
        for(let i=-2;i<=2;i++){ // ë²”ìœ„ ê°ì†Œ (-3~3 -> -2~2)
          const aa=base+i*0.3; // ê°ë„ ê°„ê²© ì¦ê°€ (0.2->0.3)
          spawnBullet({x:b.x,y:b.y, vx:Math.cos(aa)*180, vy:Math.sin(aa)*180, r:7, dmg:1, color:'#ff3b5c', hostile:true, bounce:3}); // ì†ë„ ê°ì†Œ (200->180), ë°”ìš´ìŠ¤ ê°ì†Œ (4->3)
        }
      }
    },
    // ë§ ì„¼í‹°ë„¬ Phase 3 - ë ˆì´ì € íŒ¨í„´ ê°•í™”
    laser_sweep(b,dt){
      if(!b._lz){ b._lz={cd:0, step:0, warm:0, multiMode:0}; }
      const L=b._lz; L.cd-=dt;
      
      if(L.cd<=0){
        L.cd = 5.0 - L.step * 0.15; // ë ˆì´ì € ê°„ê²© ì¦ê°€ (3.8->5.0, 0.2->0.15)
        L.step++;
        L.multiMode = L.step % 3; // 3ê°€ì§€ ë ˆì´ì € íŒ¨í„´
        
        if(L.multiMode === 0) { // ë‹¨ì¼ ì¶”ì  ë ˆì´ì €
          const target = angleTo(b.x,b.y, player.x,player.y) + rand(-0.3,0.3); // ì •í™•ë„ ì•½ê°„ ê°ì†Œ
          L.warm = 1.2; L.target = target; // ì˜ˆê³  ì‹œê°„ ì¦ê°€
          setTimeout(()=>{
            if(!boss || !boss.alive) return;
            const len=1200, w=10; // ê¸¸ì´ì™€ í­ ê°ì†Œ (1400->1200, 12->10)
            for(let t=0;t<25;t++){ // ë ˆì´ì € ì„¸ê·¸ë¨¼íŠ¸ ê°ì†Œ (30->25)
              const d = (t/25)*len;
              spawnBullet({x:b.x+Math.cos(target)*d, y:b.y+Math.sin(target)*d, vx:0,vy:0, r:w, dmg:2, color:'#ff3b5c', hostile:true, ttl:0.1, laser:true}); // ttl ê°ì†Œ
            }
          }, 1200);
        } else if(L.multiMode === 1) { // 2-way ë ˆì´ì € (3-wayì—ì„œ ê°ì†Œ)
          for(let i=-0.5;i<=0.5;i+=1){ // 3ê°œì—ì„œ 2ê°œë¡œ ê°ì†Œ
            const target = angleTo(b.x,b.y, player.x,player.y) + i*0.8; // ê°ë„ ê°„ê²© ì¦ê°€
            L.warm = 1.4; // ì˜ˆê³  ì‹œê°„ ì¦ê°€
            setTimeout(()=>{
              if(!boss || !boss.alive) return;
              const len=1000, w=8; // ê¸¸ì´ì™€ í­ ê°ì†Œ (1200->1000, 10->8)
              for(let t=0;t<20;t++){ // ì„¸ê·¸ë¨¼íŠ¸ ê°ì†Œ (25->20)
                const d = (t/20)*len;
                spawnBullet({x:b.x+Math.cos(target)*d, y:b.y+Math.sin(target)*d, vx:0,vy:0, r:w, dmg:1.5, color:'#ffd24a', hostile:true, ttl:0.08, laser:true});
              }
            }, 1400);
          }
        } else { // íšŒì „ ë ˆì´ì € - íšŒì „ ìˆ˜ ê°ì†Œ
          const baseAngle = angleTo(b.x,b.y, player.x,player.y);
          L.warm = 1.8; // ì˜ˆê³  ì‹œê°„ ì¦ê°€
          for(let rot=0; rot<3; rot++){ // 5ê°œì—ì„œ 3ê°œë¡œ ê°ì†Œ
            setTimeout(()=>{
              if(!boss || !boss.alive) return;
              const target = baseAngle + rot*0.5; // ê°ë„ ê°„ê²© ì¦ê°€
              const len=1100, w=6; // ê¸¸ì´ì™€ í­ ê°ì†Œ (1300->1100, 8->6)
              for(let t=0;t<28;t++){
                const d = (t/28)*len;
                spawnBullet({x:b.x+Math.cos(target)*d, y:b.y+Math.sin(target)*d, vx:0,vy:0, r:w, dmg:1, color:'#49f3ff', hostile:true, ttl:0.08, laser:true});
              }
            }, 1500 + rot*200);
          }
        }
      }
      if(L.warm>0) L.warm-=dt;
      
      // ì¶”ê°€: ë ˆì´ì € ê°„ê²©ì— ì†Œí˜• íƒ„ë§‰
      if(L.warm <= 0 && chance(0.02)){
        const N=8; const speed=100;
        for(let i=0;i<N;i++){
          const a = i/N*TAU + b.timer;
          spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, r:3, dmg:1, color:'#ff71ff', hostile:true});
        }
      }
    },
    // í•˜ì´ë“œë¼ ì½”ì–´ Phase 1 - ì˜¤ë¹„íŠ¸ íŒ¨í„´ ê°•í™”
    orbits(b,dt){
      if(!b._orb){ b._orb={t:0, pattern:0, switchTimer:0}; }
      b._orb.t+=dt; b._orb.switchTimer+=dt;
      
      // íŒ¨í„´ ë³€ê²½ (4ê°€ì§€)
      if(b._orb.switchTimer > 7) { b._orb.pattern = (b._orb.pattern + 1) % 4; b._orb.switchTimer = 0; }
      
      const patterns = [
        {N:6, speed:120, rad:90, fireRate:0.02}, // ê¸°ë³¸
        {N:8, speed:100, rad:70, fireRate:0.03}, // ë°€ì§‘
        {N:4, speed:160, rad:110, fireRate:0.015}, // ë¹ ë¥¸ 4ê°œ
        {N:10, speed:80, rad:60, fireRate:0.04} // ëŠë¦° ë‹¤ìˆ˜
      ];
      
      const p = patterns[b._orb.pattern];
      
      for(let i=0;i<p.N;i++){
        const a = b._orb.t*1.2 + i/p.N*TAU;
        const px=b.x+Math.cos(a)*p.rad, py=b.y+Math.sin(a)*p.rad;
        
        if(Math.floor((b._orb.t+i*0.3)*5)%5===0 && chance(p.fireRate)){
          const aim=angleTo(px,py, player.x,player.y);
          const colors = ['#49f3ff', '#ff71ff', '#ffd24a', '#ff3b5c'];
          spawnBullet({x:px,y:py,vx:Math.cos(aim)*p.speed,vy:Math.sin(aim)*p.speed,r:4,dmg:1,color:colors[b._orb.pattern],hostile:true});
        }
      }
      
      // ì¶”ê°€: ì¤‘ì•™ì—ì„œ í„ìŠ¤ ë§
      if(Math.floor(b._orb.t*2)%6===0 && chance(0.05)){
        const N=12; const speed=90;
        for(let i=0;i<N;i++){
          const a = i/N*TAU + b._orb.t*0.5;
          spawnBullet({x:b.x,y:b.y, vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, r:3, dmg:1, color:'#ff71ff', hostile:true});
        }
      }
    },
    // í•˜ì´ë“œë¼ ì½”ì–´ Phase 2 - ë“œë¡  ì‹œìŠ¤í…œ í™•ì¥
    drones(b,dt){
      if(!b._dr){ b._dr={cd:0, list:[], formation:0, formationTimer:0}; }
      const D=b._dr; D.cd-=dt; D.formationTimer+=dt;
      
      // í¬ë©”ì´ì…˜ ë³€ê²½ (3ê°€ì§€)
      if(D.formationTimer > 8) { D.formation = (D.formation + 1) % 3; D.formationTimer = 0; }
      
      if(D.cd<=0 && D.list.length<6){
        D.cd = 2.8 - D.formation * 0.3;
        let newDrone;
        
        if(D.formation === 0) { // ëœë¤ ë°°ì¹˜
          newDrone = {x:b.x+rand(-120,120), y:b.y+rand(-60,60), hp:8, t:0, type:'basic'};
        } else if(D.formation === 1) { // ì›í˜• ë°°ì¹˜
          const angle = D.list.length * TAU/6;
          newDrone = {x:b.x+Math.cos(angle)*100, y:b.y+Math.sin(angle)*80, hp:6, t:0, type:'orbiter'};
        } else { // ë¼ì¸ ë°°ì¹˜
          newDrone = {x:b.x + (D.list.length-2.5)*40, y:b.y-80, hp:10, t:0, type:'heavy'};
        }
        D.list.push(newDrone);
      }
      
      for(const d of D.list){
        if(!d.alive && d.hp<=0) continue;
        d.t+=dt;
        
        // ë“œë¡  íƒ€ì…ë³„ í–‰ë™
        if(d.type === 'basic') {
          d.x += Math.cos(d.t*2)*30*dt;
          d.y += Math.sin(d.t*2.2)*20*dt;
        } else if(d.type === 'orbiter') {
          const angle = d.t*1.5 + D.list.indexOf(d)*TAU/6;
          d.x = b.x + Math.cos(angle)*100;
          d.y = b.y + Math.sin(angle)*80;
        } else { // heavy
          d.x += Math.sin(d.t*1.5)*15*dt;
          d.y += Math.cos(d.t*1.8)*10*dt;
        }
        
        // ê³µê²© íŒ¨í„´
        const fireChance = d.type === 'heavy' ? 0.08 : 0.05;
        if(Math.floor(d.t*5)%5===0 && chance(fireChance)){
          const a=angleTo(d.x,d.y, player.x,player.y);
          if(d.type === 'heavy') {
            // 3-way ê³µê²©
            for(let i=-1;i<=1;i++){
              const aa = a + i*0.2;
              spawnBullet({x:d.x,y:d.y,vx:Math.cos(aa)*220,vy:Math.sin(aa)*220,r:5,dmg:1,color:'#ffd24a',hostile:true});
            }
          } else {
            spawnBullet({x:d.x,y:d.y,vx:Math.cos(a)*200,vy:Math.sin(a)*200,r:4,dmg:1,color:'#ff71ff',hostile:true});
          }
        }
        
        // í”¼ê²© ì²˜ë¦¬
        for(const k of bullets){
          if(!k.alive||k.hostile) continue;
          if(dist2(d.x,d.y,k.x,k.y) < (8+k.r)*(8+k.r)){
            d.hp-=k.dmg||1; k.alive=false;
            spawnPart({x:d.x,y:d.y,ttl:0.2,color:'#ff71ff',sz:6});
            if(d.hp<=0){ d.alive=false; spawnOrb(d.x,d.y, rand(2,4)); }
          }
        }
      }
      D.list = D.list.filter(d=>d.alive!==false);
    },
    // í•˜ì´ë“œë¼ ì½”ì–´ Phase 3 - ê´‘ë€ íŒ¨í„´ ì—…ê·¸ë ˆì´ë“œ
    frenzy(b,dt){
      if(!b._fz){ b._fz={cd:0,a:0,intensity:1,burstTimer:0}; }
      const F=b._fz; F.cd-=dt; F.a+=dt*4; F.burstTimer+=dt;
      
      // ê°•ë„ ì¦ê°€
      F.intensity = 1 + Math.floor(F.burstTimer/5) * 0.5;
      
      if(F.cd<=0){
        F.cd = 0.05 / F.intensity;
        const speed=180 + F.intensity*20;
        const a=F.a;
        const col=settings.colorBlind? '#ffd24a' : '#ff71ff';
        
        // ê¸°ë³¸ 3-way
        for(let i=0;i<3;i++){
          const aa=a+i*(TAU/3);
          spawnBullet({x:b.x,y:b.y,vx:Math.cos(aa)*speed,vy:Math.sin(aa)*speed,r:4,dmg:1,color:col,hostile:true});
        }
        
        // ê°•ë„ì— ë”°ë¥¸ ì¶”ê°€ íŒ¨í„´
        if(F.intensity >= 2) {
          // 6-way ì¶”ê°€
          for(let i=0;i<6;i++){
            const aa=a+i*(TAU/6)+TAU/12;
            spawnBullet({x:b.x,y:b.y,vx:Math.cos(aa)*speed*0.7,vy:Math.sin(aa)*speed*0.7,r:3,dmg:1,color:'#49f3ff',hostile:true});
          }
        }
        
        if(F.intensity >= 3) {
          // ì¶”ì  íƒ„í™˜ ì¶”ê°€ - ë°œìƒ í™•ë¥  ê°ì†Œ
          if(chance(0.05)){
            spawnBullet({x:b.x,y:b.y, homing:true, r:6, spd:120, dmg:1, color:'#ff3b5c',hostile:true, ttl:8});
          }
        }
      }
      
      // ë²„ìŠ¤íŠ¸ ê³µê²©
      if(Math.floor(F.burstTimer)%4===0 && chance(0.03)){
        for(let ring=0;ring<2;ring++){
          const N=20; const speed=100+ring*50;
          for(let i=0;i<N;i++){
            const aa = i/N*TAU + ring*TAU/N/2;
            spawnBullet({x:b.x,y:b.y,vx:Math.cos(aa)*speed,vy:Math.sin(aa)*speed,r:4,dmg:1,color:'#ffd24a',hostile:true});
          }
        }
      }
    },
    // íƒ€ì´íƒ„ í¬ì§€ Phase 2 - í•´ë¨¸ ì—°íƒ€ íŒ¨í„´ (ë‚œì´ë„ ì¦ê°€)
    hammer_barrage(b,dt){
      if(!b._hm){ b._hm={cd:1.0, pattern:0, comboTimer:0, targetX:W*0.5, targetY:H*0.6}; } // ì´ˆê¸° ë”œë ˆì´ ê°ì†Œ
      const HM=b._hm; HM.cd-=dt; HM.comboTimer+=dt;
      
      // íŒ¨í„´ ë³€ê²½ (3ê°€ì§€) - ë” ë¹ ë¥¸ ë³€ê²½
      if(HM.comboTimer > 6) { HM.pattern = (HM.pattern + 1) % 3; HM.comboTimer = 0; }
      
      if(HM.cd<=0){
        HM.cd = 1.2 + HM.pattern * 0.2; // íŒ¨í„´ë³„ ê°„ê²© ê°ì†Œ (1.8->1.2)
        
        if(HM.pattern === 0) { // ì§ì„  í•´ë¨¸ ìŠ¤íŠ¸ë¼ì´í¬ - ê°•í™”
          // í”Œë ˆì´ì–´ë¥¼ í–¥í•´ í•´ë¨¸ ë°œì‚¬
          const angle = angleTo(b.x, b.y, player.x, player.y);
          for(let i=0; i<5; i++) { // 3ë°œ -> 5ë°œ
            setTimeout(() => {
              if(boss && boss.alive) {
                const spread = (i-2) * 0.15; // 5ë°œ í™•ì‚°
                spawnBullet({
                  x: b.x + Math.cos(angle) * 30,
                  y: b.y + Math.sin(angle) * 30,
                  vx: Math.cos(angle + spread) * 320, // ì†ë„ ì¦ê°€ (250->320)
                  vy: Math.sin(angle + spread) * 320,
                  r: 8, // í¬ê¸° ì¦ê°€ (7->8)
                  dmg: 1.5, // ë°ë¯¸ì§€ ì¦ê°€
                  color: '#ffd24a',
                  hostile: true,
                  ttl: 2.5
                });
              }
            }, i * 120); // ë”œë ˆì´ ê°ì†Œ (200->120)
          }
        } else if(HM.pattern === 1) { // êµì°¨ í•´ë¨¸ - ê°•í™”
          // Xì íŒ¨í„´ìœ¼ë¡œ 8ë°©í–¥ ë°œì‚¬ (4->8)
          for(let i=0; i<8; i++) {
            const angle = (i * TAU/8); // 8ë°©í–¥
            spawnBullet({
              x: b.x,
              y: b.y,
              vx: Math.cos(angle) * 280, // ì†ë„ ì¦ê°€ (200->280)
              vy: Math.sin(angle) * 280,
              r: 9, // í¬ê¸° ì¦ê°€ (8->9)
              dmg: 2, // ë°ë¯¸ì§€ ì¦ê°€ (1.5->2)
              color: '#ff9b3b',
              hostile: true,
              ttl: 3.0
            });
          }
        } else { // ë§ì¹˜ í­ê²© - ê°•í™”
          // ëœë¤ ìœ„ì¹˜ì— ë§ì¹˜ë“¤ì´ ë–¨ì–´ì§
          for(let i=0; i<6; i++) { // ê°œìˆ˜ ì¦ê°€ (4->6)
            setTimeout(() => {
              if(boss && boss.alive) {
                const targetX = rand(100, W-100); // ë²”ìœ„ í™•ëŒ€
                const targetY = rand(H*0.4, H-100);
                
                // ê²½ê³  í‘œì‹œ íŒŒí‹°í´
                for(let j=0; j<8; j++) { // ê²½ê³  íŒŒí‹°í´ ì¦ê°€
                  spawnPart({
                    x: targetX + rand(-25, 25),
                    y: targetY + rand(-25, 25),
                    ttl: 0.8, // ê²½ê³  ì‹œê°„ ê°ì†Œ (1.0->0.8)
                    color: '#ff3b5c',
                    sz: rand(4, 8)
                  });
                }
                
                // 0.8ì´ˆ í›„ ë§ì¹˜ íˆ¬í•˜
                setTimeout(() => {
                  if(boss && boss.alive) {
                    spawnBullet({
                      x: targetX,
                      y: targetY - 50,
                      vx: 0,
                      vy: 450, // ì†ë„ ì¦ê°€ (350->450)
                      r: 12, // í¬ê¸° ì¦ê°€ (10->12)
                      dmg: 3, // ë°ë¯¸ì§€ ì¦ê°€ (2->3)
                      color: '#ffd24a',
                      hostile: true,
                      ttl: 2.0
                    });
                  }
                }, 800); // ê²½ê³  ì‹œê°„ ê°ì†Œ
              }
            }, i * 200); // ê°„ê²© ê°ì†Œ (300->200)
          }
        }
      }
      
      // ì¶”ê°€: ì‘ì€ íŒŒí¸ í©ë¿Œë¦¬ê¸° - ë¹ˆë„ ì¦ê°€
      if(Math.floor(HM.comboTimer*2)%6===0 && chance(0.08)){ // ë¹ˆë„ ì¦ê°€ (%10->%6, 0.03->0.08)
        const N=10; const speed=120; // ê°œìˆ˜, ì†ë„ ì¦ê°€ (6->10, 80->120)
        for(let i=0;i<N;i++){
          const a = i/N*TAU + Math.random()*0.4;
          spawnBullet({
            x: b.x + rand(-25, 25),
            y: b.y + rand(-25, 25),
            vx: Math.cos(a) * speed,
            vy: Math.sin(a) * speed,
            r: 4, // í¬ê¸° ì¦ê°€ (3->4)
            dmg: 1, // ë°ë¯¸ì§€ ì¦ê°€ (0.5->1)
            color: '#ffaa44',
            hostile: true,
            ttl: 1.5
          });
        }
      }
    },
    // íƒ€ì´íƒ„ í¬ì§€ Phase 2 - ë©”í…Œì˜¤ íŒ¨í„´ ê°•í™”
    meteors(b,dt){
      if(!b._mt){ b._mt={cd:0, pattern:0, salvoTimer:0}; }
      const M=b._mt; M.cd-=dt; M.salvoTimer+=dt;
      
      // íŒ¨í„´ ë³€ê²½ (3ê°€ì§€)
      if(M.salvoTimer > 8) { M.pattern = (M.pattern + 1) % 3; M.salvoTimer = 0; }
      
      if(M.cd<=0){
        if(M.pattern === 0) { // ë‹¨ë°œ ì¶”ì 
          M.cd = 1.0;
          const x = rand(40,W-40), y=-20;
          const a = angleTo(x,y, player.x+rand(-80,80), player.y);
          spawnBullet({x,y, vx:Math.cos(a)*260, vy:Math.sin(a)*260, r:9, dmg:2, color:'#ff9b3b',hostile:true});
        } else if(M.pattern === 1) { // 3ì—°ë°œ
          M.cd = 1.8;
          for(let i=0;i<3;i++){
            setTimeout(()=>{
              if(!boss || !boss.alive) return;
              const x = rand(40,W-40), y=-20;
              const a = angleTo(x,y, player.x+rand(-60,60), player.y);
              spawnBullet({x,y, vx:Math.cos(a)*240, vy:Math.sin(a)*240, r:8, dmg:1.5, color:'#ffd24a',hostile:true});
            }, i*400);
          }
        } else { // ê´‘ì—­ í­ê²©
          M.cd = 2.5;
          for(let i=0;i<6;i++){
            setTimeout(()=>{
              if(!boss || !boss.alive) return;
              const x = rand(60,W-60), y=-20;
              const targetX = rand(100,W-100), targetY = rand(200,H-100);
              const a = angleTo(x,y, targetX, targetY);
              spawnBullet({x,y, vx:Math.cos(a)*220, vy:Math.sin(a)*220, r:7, dmg:1, color:'#ff71ff',hostile:true});
            }, i*200);
          }
        }
      }
      
      // ì¶”ê°€: ìš©ì•” ë¶„ì¶œ (ìœ„ì—ì„œ ë‚´ë ¤ì˜¤ëŠ” íƒ„ë§‰)
      if(chance(0.01)){
        const N=8;
        for(let i=0;i<N;i++){
          const x = rand(50,W-50);
          spawnBullet({x, y:-10, vx:rand(-30,30), vy:150, r:5, dmg:1, color:'#ff3b5c', hostile:true});
        }
      }
    },
    // íƒ€ì´íƒ„ í¬ì§€ Phase 3 - ì ˆë§ íŒ¨í„´ ì™„ì „ì²´ (ë‚œì´ë„ ëŒ€í­ ì¦ê°€)
    desperate(b,dt){
      if(!b._dp){ 
        b._dp={
          t:0, 
          chaos:1, 
          lastBurst:0, 
          meteorTimer:0, 
          waveTimer:0,
          laserTimer:0,
          intensity:1
        }; 
      }
      const D=b._dp; 
      D.t+=dt; 
      D.chaos = Math.min(3, 1 + D.t*0.15); // í˜¼ëˆ ìˆ˜ì¹˜ ì¦ê°€ ì†ë„ ì¦ê°€
      D.intensity = 1 + D.t * 0.2; // ê°•ë„ ì¦ê°€

      // 1. ë©”í…Œì˜¤ ë ˆì¸ - ëŒ€í­ ê°•í™”
      D.meteorTimer -= dt;
      if(D.meteorTimer <= 0){
        D.meteorTimer = Math.max(0.3, 1.2 - D.chaos*0.2); // ê°„ê²© ëŒ€í­ ê°ì†Œ
        
        // ë™ì‹œì— ì—¬ëŸ¬ ìœ„ì¹˜ì— ë©”í…Œì˜¤
        const meteorCount = Math.floor(2 + D.chaos * 2); // 2~8ê°œ
        for(let i=0; i<meteorCount; i++){
          const px = rand(80, W-80);
          const py = rand(H*0.3, H-80);
          
          // ê²½ê³  ì´í™íŠ¸ ê°•í™”
          for(let j=0; j<12; j++){
            spawnPart({
              x: px + rand(-30, 30),
              y: py + rand(-30, 30),
              ttl: 0.6, // ê²½ê³  ì‹œê°„ ê°ì†Œ
              color: '#ff3b5c',
              sz: rand(6, 12)
            });
          }
          
          setTimeout(()=>{
            if(boss && boss.alive){
              spawnBullet({
                x: px, y: py-60,
                vx: rand(-50, 50), vy: 400 + D.chaos*50, // ì†ë„ ì¦ê°€
                r: 8 + D.chaos, dmg: 2 + D.chaos*0.5, // í¬ê¸°, ë°ë¯¸ì§€ ì¦ê°€
                color: '#ffd24a',
                hostile: true,
                ttl: 3.0
              });
            }
          }, 600);
        }
      }

      // 2. ìŠ¤íŒŒì´ëŸ´ ì›¨ì´ë¸Œ - ì ë‹¹íˆ ì¡°ì •
      D.waveTimer -= dt;
      if(D.waveTimer <= 0){
        D.waveTimer = Math.max(0.4, 1.2 - D.chaos*0.2); // ê°„ê²© ì¡°ì • (0.2->0.4, 0.8->1.2)
        
        const N = Math.floor(16 + D.chaos*4); // íƒ„í™˜ ìˆ˜ ê°ì†Œ (24+8 -> 16+4)
        const layers = Math.floor(1 + D.chaos*0.3); // ë ˆì´ì–´ ìˆ˜ ê°ì†Œ (0.5->0.3)
        
        for(let layer=0; layer<layers; layer++){
          for(let i=0; i<N; i++){
            const a = i/N*TAU + D.t*(1+layer*0.5) + layer*TAU/N/2;
            const speed = 120 + D.chaos*20 + layer*15; // ì†ë„ ê°ì†Œ (140+30 -> 120+20, 20->15)
            const size = 5 + layer*1.5; // í¬ê¸° ê°ì†Œ
            
            spawnBullet({
              x: b.x + Math.cos(a)*30,
              y: b.y + Math.sin(a)*30,
              vx: Math.cos(a)*speed,
              vy: Math.sin(a)*speed,
              r: size,
              dmg: 1 + layer*0.3, // ë°ë¯¸ì§€ ê°ì†Œ
              color: layer === 0 ? '#ff71ff' : '#ffd24a',
              hostile: true,
              ttl: 4.0
            });
          }
        }
      }

      // 3. íšŒì „ íƒ„í™˜ - ì ë‹¹íˆ ì¡°ì • (ê¸°ì¡´ ì¶©ê²©íŒŒ ëŒ€ì‹ )
      if(Math.floor(D.t*3)%4===0 && chance(0.05 * D.chaos)){ // ë¹ˆë„ ê°ì†Œ (4->3)
        const N=12 + D.chaos*2; const speed=180+D.chaos*30; // ê°œìˆ˜ ê°ì†Œ (20+4 -> 12+2)
        for(let i=0;i<N;i++){
          const a = i/N*TAU + D.t*0.8;
          spawnBullet({
            x: b.x,
            y: b.y,
            vx: Math.cos(a)*speed,
            vy: Math.sin(a)*speed,
            r: 6 + D.chaos*0.3, // í¬ê¸° ê°ì†Œ
            dmg: 1.2 + D.chaos*0.2, // ë°ë¯¸ì§€ ê°ì†Œ
            color: '#ffd24a',
            hostile: true,
            ttl: 3.5
          });
        }
      }

      // 4. ìƒˆë¡œìš´ íŒ¨í„´: í˜¼ëˆ ë²„ìŠ¤íŠ¸ - ì ë‹¹íˆ ì¡°ì •
      if(D.t - D.lastBurst > Math.max(3, 5 - D.chaos*0.4)){ // ê°„ê²© ì¡°ì • (2->3, 4->5)
        D.lastBurst = D.t;
        
        // ë™ì‹œ ë‹¤ë°œ ê³µê²© ì¡°ì •
        const N=32 + D.chaos*8; const speed=140; // ê°œìˆ˜ ê°ì†Œ (48+16 -> 32+8)
        for(let i=0;i<N;i++){
          const a = i/N*TAU + Math.random()*0.4;
          setTimeout(()=>{
            if(boss && boss.alive){
              spawnBullet({
                x: b.x + rand(-30, 30), // ë²”ìœ„ ê°ì†Œ
                y: b.y + rand(-30, 30),
                vx: Math.cos(a)*speed,
                vy: Math.sin(a)*speed,
                r: 5 + Math.random()*2, // í¬ê¸° ê°ì†Œ
                dmg: 1.2,
                color: Math.random() > 0.5 ? '#ff71ff' : '#ff3b5c',
                hostile: true,
                ttl: 3.0
              });
            }
          }, Math.random()*1000); // ì‹œê°„ ê°„ê²© ì¡°ì •
        }
        
        // ì¶”ê°€: ë ˆì´ì € ìŠ¤ìœ„í”„
        D.laserTimer = 2.0;
      }

      // 5. ë ˆì´ì € ìŠ¤ìœ„í”„ (ìƒˆë¡œìš´ ê³µê²©)
      if(D.laserTimer > 0){
        D.laserTimer -= dt;
        const progress = (2.0 - D.laserTimer) / 2.0;
        const angle = progress * TAU * 2; // 2ë°”í€´ íšŒì „
        
        // íšŒì „í•˜ëŠ” ë ˆì´ì € ë¹”
        for(let i=0; i<3; i++){ // 3ê°œì˜ ë ˆì´ì €
          const a = angle + i*TAU/3;
          for(let d=40; d<300; d+=15){
            const px = b.x + Math.cos(a)*d;
            const py = b.y + Math.sin(a)*d;
            if(px > 0 && px < W && py > 0 && py < H){
              spawnBullet({
                x: px, y: py,
                vx: 0, vy: 0,
                r: 8,
                dmg: 2,
                color: '#49f3ff',
                hostile: true,
                ttl: 0.1,
                laser: true
              });
            }
          }
        }
      }

      // 6. ì¶”ê°€ íŒ¨í„´: ì¶”ì  ë¯¸ì‚¬ì¼
      if(Math.floor(D.t*1.5)%8===0 && chance(0.06 * D.chaos)){
        const homingCount = Math.floor(2 + D.chaos);
        for(let i=0;i<homingCount;i++){
          setTimeout(()=>{
            if(boss && boss.alive){
              spawnBullet({
                x: b.x + rand(-30, 30),
                y: b.y + rand(-30, 30),
                homing: true,
                r: 8,
                spd: 160 + i*20,
                dmg: 2,
                color: '#ff3b5c',
                hostile: true,
                ttl: 8,
                turnRate: 3.0
              });
            }
          }, i*200);
        }
      }
    },
    
    // ===== VOID_REAPER íŒ¨í„´ë“¤ =====
    
    // Phase 1: Shadow Walls - ëŒ€ì‰¬ í•„ìˆ˜ í™œìš© íŒ¨í„´
    shadow_walls(b,dt){
      if(!b._sw){ 
        b._sw={
          cd:0, 
          wallTimer:0, 
          wallPattern:0, 
          walls:[], 
          warningTime:2.0
        }; 
      }
      const SW=b._sw; 
      SW.cd-=dt; 
      SW.wallTimer-=dt;
      
      // ê¸°ì¡´ ë²½ë“¤ ì—…ë°ì´íŠ¸
      for(let i=SW.walls.length-1; i>=0; i--){
        const wall = SW.walls[i];
        wall.lifetime -= dt;
        
        if(wall.phase === 'warning'){
          // ê²½ê³  ë‹¨ê³„
          if(wall.lifetime <= 0){
            wall.phase = 'moving';
            wall.lifetime = 4.0; // ì´ë™ ì‹œê°„
          }
        } else if(wall.phase === 'moving'){
          // ì´ë™ ë‹¨ê³„
          wall.x += wall.vx * dt;
          wall.y += wall.vy * dt;
          
          // í”Œë ˆì´ì–´ì™€ ì¶©ëŒ ê²€ì‚¬ (ëŒ€ì‰¬ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ)
          if(player && !player.isDashPreviewing && player.ifr <= 0){
            // ë²½ì˜ ì‹¤ì œ ì¶©ëŒ ì˜ì—­ ê³„ì‚°
            const wallHalfWidth = wall.width / 2;
            const wallHalfHeight = wall.height / 2;
            
            // í”Œë ˆì´ì–´ê°€ ë²½ ì•ˆì— ìˆëŠ”ì§€ ì²´í¬ (í‹ˆ ì œì™¸)
            if(player.x > wall.x - wallHalfWidth && 
               player.x < wall.x + wallHalfWidth &&
               player.y > wall.y - wallHalfHeight && 
               player.y < wall.y + wallHalfHeight){
              
              // í‹ˆ ìœ„ì¹˜ì— ìˆëŠ”ì§€ í™•ì¸
              let inGap = false;
              for(const gap of wall.gaps){
                if(player.x > gap.x - gap.width/2 && 
                   player.x < gap.x + gap.width/2 &&
                   player.y > gap.y - gap.height/2 && 
                   player.y < gap.y + gap.height/2){
                  inGap = true;
                  break;
                }
              }
              
              if(!inGap){
                player.hit(3); // ë†’ì€ ë°ë¯¸ì§€
              }
            }
          }
          
          if(wall.lifetime <= 0){
            SW.walls.splice(i, 1);
          }
        }
      }
      
      // ìƒˆë¡œìš´ ë²½ ìƒì„±
      if(SW.cd <= 0){
        SW.cd = 3.5 - SW.wallPattern * 0.3; // ì ì  ë¹¨ë¼ì§
        SW.wallPattern = (SW.wallPattern + 1) % 4;
        
        let newWall;
        const speed = 80 + SW.wallPattern * 20;
        
        if(SW.wallPattern === 0){ // ì„¸ë¡œ ë²½ (ì¢Œâ†’ìš°)
          const startX = -50;
          const targetY = player.y + rand(-100, 100);
          newWall = {
            x: startX,
            y: targetY,
            width: 40,
            height: H * 0.8,
            vx: speed,
            vy: 0,
            gaps: [
              {x: startX, y: targetY + rand(-150, 150), width: 80, height: 120}
            ],
            phase: 'warning',
            lifetime: SW.warningTime,
            color: '#8B00FF'
          };
        } else if(SW.wallPattern === 1){ // ê°€ë¡œ ë²½ (ìœ„â†’ì•„ë˜)
          const startY = -50;
          const targetX = player.x + rand(-150, 150);
          newWall = {
            x: targetX,
            y: startY,
            width: W * 0.7,
            height: 40,
            vx: 0,
            vy: speed,
            gaps: [
              {x: targetX + rand(-200, 200), y: startY, width: 120, height: 80}
            ],
            phase: 'warning',
            lifetime: SW.warningTime,
            color: '#8B00FF'
          };
        } else if(SW.wallPattern === 2){ // ëŒ€ê°ì„  ë²½
          const startX = -50;
          const startY = -50;
          newWall = {
            x: startX,
            y: startY,
            width: Math.hypot(W, H) * 0.8,
            height: 50,
            vx: speed * 0.7,
            vy: speed * 0.7,
            gaps: [
              {x: startX + 200, y: startY + 200, width: 100, height: 100},
              {x: startX + 400, y: startY + 400, width: 100, height: 100}
            ],
            phase: 'warning',
            lifetime: SW.warningTime,
            color: '#8B00FF'
          };
        } else { // Xì êµì°¨ ë²½
          // ë‘ ê°œì˜ ëŒ€ê°ì„  ë²½ ë™ì‹œ ìƒì„±
          newWall = {
            x: -50,
            y: H + 50,
            width: Math.hypot(W, H) * 0.8,
            height: 40,
            vx: speed * 0.7,
            vy: -speed * 0.7,
            gaps: [
              {x: W/2 - 100, y: H/2, width: 200, height: 100}
            ],
            phase: 'warning',
            lifetime: SW.warningTime,
            color: '#8B00FF'
          };
          
          // ë‘ ë²ˆì§¸ ë²½
          SW.walls.push({
            x: -50,
            y: -50,
            width: Math.hypot(W, H) * 0.8,
            height: 40,
            vx: speed * 0.7,
            vy: speed * 0.7,
            gaps: [
              {x: W/2 + 100, y: H/2, width: 200, height: 100}
            ],
            phase: 'warning',
            lifetime: SW.warningTime,
            color: '#8B00FF'
          });
        }
        
        SW.walls.push(newWall);
      }
      
      // ì¶”ê°€ íŒ¨í„´: ê·¸ë¦¼ì íƒ„í™˜
      if(Math.floor(b.timer*2)%8===0 && chance(0.08)){
        const N=12; const speed=140;
        for(let i=0;i<N;i++){
          const a = i/N*TAU + b.timer*0.5;
          spawnBullet({
            x: b.x + Math.cos(a)*60,
            y: b.y + Math.sin(a)*60,
            vx: Math.cos(a)*speed,
            vy: Math.sin(a)*speed,
            r: 5,
            dmg: 1,
            color: '#4B0082',
            hostile: true,
            ttl: 3.0
          });
        }
      }
    },
    
    // Phase 2: Space Distortion - ê³µê°„ ì™œê³¡ íŒ¨í„´
    space_distortion(b,dt){
      if(!b._sd){ 
        b._sd={
          cd:0, 
          teleportTimer:0, 
          distortionFields:[], 
          pattern:0,
          patternTimer:0
        }; 
      }
      const SD=b._sd; 
      SD.cd-=dt; 
      SD.teleportTimer-=dt; 
      SD.patternTimer+=dt;
      
      // íŒ¨í„´ ë³€ê²½
      if(SD.patternTimer > 8) { 
        SD.pattern = (SD.pattern + 1) % 3; 
        SD.patternTimer = 0; 
      }
      
      // ì™œê³¡ í•„ë“œ ì—…ë°ì´íŠ¸
      for(let i=SD.distortionFields.length-1; i>=0; i--){
        const field = SD.distortionFields[i];
        field.lifetime -= dt;
        field.intensity = Math.sin(field.lifetime * 4) * 0.5 + 0.5;
        
        // í”Œë ˆì´ì–´ê°€ ì™œê³¡ í•„ë“œ ì•ˆì— ìˆìœ¼ë©´ íƒ„í™˜ ê¶¤ë„ ì™œê³¡
        if(dist2(player.x, player.y, field.x, field.y) < field.radius * field.radius){
          // í”Œë ˆì´ì–´ ì´ë™ ì €í•´ íš¨ê³¼
          if(player.moveSpd > 100) player.moveSpd = 100;
        }
        
        if(field.lifetime <= 0){
          SD.distortionFields.splice(i, 1);
        }
      }
      
      // í…”ë ˆí¬íŠ¸ ê³µê²©
      if(SD.teleportTimer <= 0){
        SD.teleportTimer = 4.0 - SD.pattern * 0.5;
        
        // ë³´ìŠ¤ í…”ë ˆí¬íŠ¸
        const oldX = b.x, oldY = b.y;
        
        // í…”ë ˆí¬íŠ¸ ì´í™íŠ¸ (ì‚¬ë¼ì§)
        for(let i=0; i<20; i++){
          spawnPart({
            x: oldX + rand(-30, 30),
            y: oldY + rand(-30, 30),
            vx: rand(-100, 100),
            vy: rand(-100, 100),
            ttl: 0.5,
            color: '#8B00FF',
            sz: rand(4, 8)
          });
        }
        
        // ìƒˆ ìœ„ì¹˜ë¡œ í…”ë ˆí¬íŠ¸
        if(SD.pattern === 0){
          // í”Œë ˆì´ì–´ ê·¼ì²˜ë¡œ
          const angle = rand(0, TAU);
          b.x = player.x + Math.cos(angle) * 200;
          b.y = player.y + Math.sin(angle) * 200;
        } else if(SD.pattern === 1){
          // í™”ë©´ ëª¨ì„œë¦¬ë¡œ
          const side = Math.floor(rand(0, 4));
          if(side === 0) { b.x = 100; b.y = rand(100, H-100); }
          else if(side === 1) { b.x = W-100; b.y = rand(100, H-100); }
          else if(side === 2) { b.x = rand(100, W-100); b.y = 100; }
          else { b.x = rand(100, W-100); b.y = H-100; }
        } else {
          // ëœë¤ ìœ„ì¹˜
          b.x = rand(150, W-150);
          b.y = rand(100, H*0.6);
        }
        
        // ê²½ê³„ ì²´í¬
        b.x = clamp(b.x, 80, W-80);
        b.y = clamp(b.y, 80, H-80);
        
        // í…”ë ˆí¬íŠ¸ ì´í™íŠ¸ (ë‚˜íƒ€ë‚¨)
        for(let i=0; i<20; i++){
          spawnPart({
            x: b.x + rand(-30, 30),
            y: b.y + rand(-30, 30),
            vx: rand(-100, 100),
            vy: rand(-100, 100),
            ttl: 0.5,
            color: '#8B00FF',
            sz: rand(4, 8)
          });
        }
        
        // í…”ë ˆí¬íŠ¸ í›„ ì¦‰ì‹œ ê³µê²©
        const attackType = Math.floor(rand(0, 3));
        if(attackType === 0){
          // ì™œê³¡ëœ íƒ„ë§‰
          const N=16; const speed=180;
          for(let i=0;i<N;i++){
            const a = i/N*TAU;
            setTimeout(()=>{
              if(boss && boss.alive){
                spawnBullet({
                  x: b.x + Math.cos(a)*40,
                  y: b.y + Math.sin(a)*40,
                  vx: Math.cos(a)*speed,
                  vy: Math.sin(a)*speed,
                  r: 6,
                  dmg: 1.5,
                  color: '#9932CC',
                  hostile: true,
                  ttl: 3.0,
                  distorted: true
                });
              }
            }, i*50);
          }
        } else if(attackType === 1){
          // ì¶”ì  ë³´ë¼ìƒ‰ êµ¬ì²´
          for(let i=0;i<4;i++){
            setTimeout(()=>{
              if(boss && boss.alive){
                spawnBullet({
                  x: b.x,
                  y: b.y,
                  homing: true,
                  r: 8,
                  spd: 150,
                  dmg: 2,
                  color: '#8B00FF',
                  hostile: true,
                  ttl: 6,
                  turnRate: 2.5
                });
              }
            }, i*300);
          }
        } else {
          // ì™œê³¡ í•„ë“œ ìƒì„±
          SD.distortionFields.push({
            x: b.x,
            y: b.y,
            radius: 120,
            intensity: 1,
            lifetime: 6.0,
            color: '#8B00FF'
          });
        }
      }
      
      // ì§€ì†ì ì¸ ê³µê°„ ì™œê³¡ íƒ„í™˜
      if(SD.cd <= 0){
        SD.cd = 0.4 + SD.pattern * 0.1;
        
        const aim = angleTo(b.x, b.y, player.x, player.y);
        const spread = 0.3;
        
        for(let i=-1; i<=1; i++){
          const a = aim + i*spread;
          spawnBullet({
            x: b.x + Math.cos(a)*25,
            y: b.y + Math.sin(a)*25,
            vx: Math.cos(a)*200,
            vy: Math.sin(a)*200,
            r: 5,
            dmg: 1,
            color: '#9370DB',
            hostile: true,
            ttl: 4.0
          });
        }
      }
    },
    
    // Phase 3: Dimensional Collapse - ì°¨ì› ë¶•ê´´ ìµœì¢… íŒ¨í„´
    dimensional_collapse(b,dt){
      if(!b._dc){ 
        b._dc={
          t:0, 
          chaos:1, 
          blackholes:[], 
          rifts:[],
          voidTimer:0,
          collapseTimer:0,
          intensity:1
        }; 
      }
      const DC=b._dc; 
      DC.t+=dt; 
      DC.chaos = Math.min(4, 1 + DC.t*0.2);
      DC.intensity = 1 + DC.t * 0.15;
      DC.voidTimer -= dt;
      DC.collapseTimer -= dt;
      
      // 1. ë¸”ë™í™€ ì‹œìŠ¤í…œ
      if(DC.voidTimer <= 0){
        DC.voidTimer = Math.max(2, 5 - DC.chaos*0.5);
        
        // ìƒˆ ë¸”ë™í™€ ìƒì„±
        if(DC.blackholes.length < 3 + DC.chaos){
          const blackhole = {
            x: rand(120, W-120),
            y: rand(120, H-120),
            radius: 80 + rand(0, 40),
            pullStrength: 200 + DC.chaos*50,
            lifetime: 8 + rand(0, 4),
            growthRate: 10
          };
          DC.blackholes.push(blackhole);
          
          // ë¸”ë™í™€ ìƒì„± ì´í™íŠ¸
          for(let i=0; i<30; i++){
            spawnPart({
              x: blackhole.x + rand(-50, 50),
              y: blackhole.y + rand(-50, 50),
              vx: rand(-150, 150),
              vy: rand(-150, 150),
              ttl: 1.0,
              color: '#000000',
              sz: rand(3, 7)
            });
          }
        }
      }
      
      // ë¸”ë™í™€ ì—…ë°ì´íŠ¸
      for(let i=DC.blackholes.length-1; i>=0; i--){
        const bh = DC.blackholes[i];
        bh.lifetime -= dt;
        bh.radius += bh.growthRate * dt;
        
        // í”Œë ˆì´ì–´ë¥¼ ë¸”ë™í™€ë¡œ ëŒì–´ë‹¹ê¹€
        const distToPlayer = Math.hypot(bh.x - player.x, bh.y - player.y);
        if(distToPlayer < bh.radius*2){
          const pullAngle = angleTo(player.x, player.y, bh.x, bh.y);
          const pullForce = bh.pullStrength / Math.max(1, distToPlayer*0.01);
          
          // ëŒ€ì‰¬ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ ëŒì–´ë‹¹ê¹€
          if(!player.isDashPreviewing){
            player.x += Math.cos(pullAngle) * pullForce * dt * 0.3;
            player.y += Math.sin(pullAngle) * pullForce * dt * 0.3;
          }
          
          // ë„ˆë¬´ ê°€ê¹Œìš°ë©´ ë°ë¯¸ì§€
          if(distToPlayer < bh.radius*0.5){
            player.hit(2);
          }
        }
        
        // íƒ„í™˜ë“¤ë„ ë¸”ë™í™€ë¡œ ëŒì–´ë‹¹ê¹€
        for(const bullet of bullets){
          if(!bullet.hostile) continue;
          const distToBH = Math.hypot(bh.x - bullet.x, bh.y - bullet.y);
          if(distToBH < bh.radius*1.5){
            const pullAngle = angleTo(bullet.x, bullet.y, bh.x, bh.y);
            const pullForce = 100 / Math.max(1, distToBH*0.01);
            bullet.vx += Math.cos(pullAngle) * pullForce * dt;
            bullet.vy += Math.sin(pullAngle) * pullForce * dt;
          }
        }
        
        if(bh.lifetime <= 0){
          // ë¸”ë™í™€ í­ë°œ
          for(let j=0; j<50; j++){
            const a = rand(0, TAU);
            const dist = rand(0, bh.radius);
            spawnBullet({
              x: bh.x + Math.cos(a)*dist,
              y: bh.y + Math.sin(a)*dist,
              vx: Math.cos(a)*(200 + rand(0, 100)),
              vy: Math.sin(a)*(200 + rand(0, 100)),
              r: 6,
              dmg: 2,
              color: '#8B00FF',
              hostile: true,
              ttl: 4.0
            });
          }
          DC.blackholes.splice(i, 1);
        }
      }
      
      // 2. ì°¨ì› ê· ì—´ ì‹œìŠ¤í…œ
      if(DC.collapseTimer <= 0){
        DC.collapseTimer = Math.max(1.5, 4 - DC.chaos*0.3);
        
        // ì°¨ì› ê· ì—´ ìƒì„±
        const riftCount = Math.floor(1 + DC.chaos*0.5);
        for(let i=0; i<riftCount; i++){
          const rift = {
            x: rand(80, W-80),
            y: rand(80, H-80),
            length: 150 + rand(0, 100),
            angle: rand(0, TAU),
            width: 20,
            lifetime: 3 + rand(0, 2),
            phase: 'opening'
          };
          DC.rifts.push(rift);
          
          // ê· ì—´ì—ì„œ íƒ„í™˜ ë°œì‚¬ (íƒ„í™˜ ìˆ˜ ê°ì†Œ)
          setTimeout(()=>{
            if(boss && boss.alive){
              const bulletCount = 4 + Math.floor(DC.chaos*0.5); // 8+DC.chaos*2 -> 4+DC.chaos*0.5ë¡œ ëŒ€í­ ê°ì†Œ
              for(let j=0; j<bulletCount; j++){
                const spreadAngle = rift.angle + (j/(bulletCount-1) - 0.5) * Math.PI * 0.5; // í¼ì§ë„ ê°ì†Œ
                spawnBullet({
                  x: rift.x + Math.cos(rift.angle)*(j-bulletCount/2)*15,
                  y: rift.y + Math.sin(rift.angle)*(j-bulletCount/2)*15,
                  vx: Math.cos(spreadAngle)*250, // ì†ë„ ê°ì†Œ
                  vy: Math.sin(spreadAngle)*250,
                  r: 6,
                  dmg: 2.0,
                  color: '#4B0082',
                  hostile: true,
                  ttl: 4.0
                });
              }
            }
          }, 1000);
        }
      }
      
      // ê· ì—´ ì—…ë°ì´íŠ¸
      for(let i=DC.rifts.length-1; i>=0; i--){
        const rift = DC.rifts[i];
        rift.lifetime -= dt;
        
        if(rift.lifetime <= 0){
          DC.rifts.splice(i, 1);
        }
      }
      
      // 3. ì‹œê³µê°„ ë¶•ê´´ - ì „ì²´ í™”ë©´ íŒ¨í„´ (ë”ìš± ì•ˆì „í•˜ê²Œ ì¡°ì •)
      if(Math.floor(DC.t*0.2)%20===0 && chance(0.03 * DC.chaos)){ // ë” ë‚®ì€ ë¹ˆë„: 0.3->0.2, 15->20, 0.05->0.03
        // í™”ë©´ ì „ì²´ì— ë¬´ì‘ìœ„ íƒ„í™˜ í­ë°œ (ë” ì ê²Œ)
        for(let i=0; i<4 + Math.floor(DC.chaos*1); i++){ // 8+DC.chaos*2 -> 4+DC.chaos*1ë¡œ ì¶”ê°€ ê°ì†Œ
          setTimeout(()=>{
            if(boss && boss.alive){
              // í”Œë ˆì´ì–´ ì£¼ë³€ ì•ˆì „ì§€ëŒ€ í™•ë³´ (ë°˜ê²½ 80px)
              let x, y, attempts = 0;
              do {
                x = rand(100, W-100); // ê²½ê³„ì—ì„œ ë” ë©€ë¦¬
                y = rand(100, H-100);
                attempts++;
              } while(Math.hypot(x - player.x, y - player.y) < 80 && attempts < 10);
              
              // í­ë°œ íƒ„í™˜ë“¤ (ìˆ˜ ë” ê°ì†Œ, ì†ë„ ê°ì†Œ)
              for(let j=0; j<3; j++){ // 4->3ìœ¼ë¡œ ì¶”ê°€ ê°ì†Œ
                const a = j/3*TAU;
                spawnBullet({
                  x: x,
                  y: y,
                  vx: Math.cos(a)*150, // ì†ë„ ë” ê°ì†Œ: 200->150
                  vy: Math.sin(a)*150,
                  r: 3, // í¬ê¸° ë” ê°ì†Œ: 4->3
                  dmg: 1.0, // ë°ë¯¸ì§€ ë” ê°ì†Œ: 1.2->1.0
                  color: '#8B00FF',
                  hostile: true,
                  ttl: 2.0 // TTL ë” ê°ì†Œ: 2.5->2.0
                });
              }
            }
          }, i*200); // ë”œë ˆì´ ë” ì¦ê°€: 150->200
        }
      }
      
      // 4. ë³´ìŠ¤ ì¤‘ì‹¬ ìŠ¤íŒŒì´ëŸ´ (ì§€ì†ì ) - íƒ„í™˜ ìˆ˜ ê°ì†Œ
      if(Math.floor(DC.t*2)%4===0 && chance(0.15)){ // ë¹ˆë„ ì¡°ì •: 3->2, 3->4, 0.2->0.15
        const N=12; const speed=140 + DC.chaos*15; // íƒ„í™˜ ìˆ˜ ê°ì†Œ: 20->12, ì†ë„ ê°ì†Œ
        for(let i=0;i<N;i++){
          const a = i/N*TAU + DC.t*2;
          spawnBullet({
            x: b.x + Math.cos(a)*50,
            y: b.y + Math.sin(a)*50,
            vx: Math.cos(a)*speed,
            vy: Math.sin(a)*speed,
            r: 6,
            dmg: 2,
            color: '#9932CC',
            hostile: true,
            ttl: 4.0
          });
        }
      }
    }
  };

  // ===== ë¬´ê¸° êµ¬í˜„ =====
  function handleWeaponFire(p, dt, wantsFire){
    const bw = p.weapon;
    
    // í”Œë¼ì¦ˆë§ˆ ìºë…¼ì€ ë³„ë„ ì²˜ë¦¬ (fireCd ì²´í¬ ìš°íšŒ)
    if(bw==='PLASMA'){
      if(wantsFire && !p.isCharging && p.fireCd <= 0) {
        p.isCharging = true;
        p.chargeTime = 0;
      }
      
      if(p.isCharging) {
        p.chargeTime += dt * 1.5; // Charge speed increased by 1.5x
        p.chargeTime = Math.min(6.0, p.chargeTime); // ìµœëŒ€ 6ì´ˆ ì¶©ì „ (2ë°° ì¦ê°€)
        
        // ì¶©ì „ ì´í™íŠ¸
        const chargeIntensity = p.chargeTime / 6.0;
        if(Math.random() < chargeIntensity * 0.8) {
          spawnPart({
            x: p.x + rand(-15, 15),
            y: p.y + rand(-15, 15),
            ttl: 0.2,
            color: `hsl(${180 + chargeIntensity * 60}, 100%, ${50 + chargeIntensity * 30}%)`,
            sz: rand(2, 4 + chargeIntensity * 3)
          });
        }
      }
      
      if(!wantsFire && p.isCharging) {
        // ë°œì‚¬!
        const chargeRatio = p.chargeTime / 4.0;
        const size = 6 + chargeRatio * 8; // 6~14
        const damage = (5.0 + chargeRatio * 10.0) * playerUp.dmg * 0.8; // 0.8ë°°ë¡œ ë„ˆí”„: 4.0~12.0ë°°
        const speed = 500 * playerUp.projSpeed;
        const penetration = Math.floor(chargeRatio * 4); // 0~4 ê´€í†µ
        
        spawnBullet({
          x: p.x + Math.cos(p.aim) * 20,
          y: p.y + Math.sin(p.aim) * 20,
          vx: Math.cos(p.aim) * speed,
          vy: Math.sin(p.aim) * speed,
          r: size,
          dmg: damage,
          color: `hsl(${180 + chargeRatio * 60}, 100%, ${60 + chargeRatio * 20}%)`,
          hostile: false,
          ttl: 2.5,
          penetration: penetration,
          plasma: true
        });
        
        // ë°œì‚¬ ì´í™íŠ¸
        for(let i=0; i<15; i++) {
          spawnPart({
            x: p.x,
            y: p.y,
            vx: Math.cos(p.aim + rand(-0.4, 0.4)) * rand(50, 200),
            vy: Math.sin(p.aim + rand(-0.4, 0.4)) * rand(50, 200),
            ttl: rand(0.3, 0.8),
            color: `hsl(${180 + chargeRatio * 60}, 100%, ${60 + chargeRatio * 20}%)`,
            sz: rand(3, 6)
          });
        }
        
        p.isCharging = false;
        p.chargeTime = 0;
        p.fireCd = 0.4 / playerUp.rof;
      }
      return; // í”Œë¼ì¦ˆë§ˆëŠ” ì—¬ê¸°ì„œ ì¢…ë£Œ
    }
    
    // ì›ê±°ë¦¬ ê³µìš©: ì‚¬ê²© (í”Œë¼ì¦ˆë§ˆ ì œì™¸)
    if(wantsFire && p.fireCd<=0){
      if(bw==='LASER'){
        // ì§€ì†ë¹”: ì§§ê²Œ í„ìŠ¤ í˜•íƒœ(ì„±ëŠ¥ìƒ)
        const len=900, seg=22, dmg=1.4*playerUp.dmg; // Damage buffed from 0.8 to 1.4
        for(let i=0;i<seg;i++){
          const d=i/seg*len;
          const px = p.x + Math.cos(p.aim)*d;
          const py = p.y + Math.sin(p.aim)*d;
          const b = spawnBullet({x:px,y:py,vx:0,vy:0,r:6,dmg,color:'#49f3ff',hostile:false,ttl:0.08}); // TTL up
        }
        p.fireCd = 0.15/ playerUp.rof; // Cooldown up
        // í”½ì…€ ìŠ¤íƒ€ì¼ ë ˆì´ì € ì´í™íŠ¸
        for(let i=0;i<4;i++) spawnPart({x:p.x+Math.cos(p.aim)*20+rand(-3,3),y:p.y+Math.sin(p.aim)*20+rand(-3,3),ttl:0.1,color:'#49f3ff',sz:rand(3,6)});
      }
      else if(bw==='SHOTGUN'){
        const K=12, spread=0.22; // íƒ„í™˜ ìˆ˜ 2ë°° ì¦ê°€: 6->12
        const spd=380*playerUp.projSpeed, dmg=2.4*playerUp.dmg; // Damage buffed from 1.8 to 2.4
        for(let i=0;i<K;i++){
          const a=p.aim + rand(-spread,spread);
          spawnBullet({x:p.x+Math.cos(a)*16,y:p.y+Math.sin(a)*16,vx:Math.cos(a)*spd,vy:Math.sin(a)*spd,r:4,dmg,color:'#ff71ff',hostile:false,ttl:1.3}); // TTL increased for range buff
        }
        p.fireCd=0.55/ playerUp.rof; // Cooldown up
        // í”½ì…€ ìŠ¤íƒ€ì¼ ì‚°íƒ„ ë°œì‚¬ ì´í™íŠ¸
        for(let i=0;i<6;i++) spawnPart({x:p.x+Math.cos(p.aim)*12+rand(-4,4),y:p.y+Math.sin(p.aim)*12+rand(-4,4),ttl:0.15,color:'#ff71ff',sz:rand(2,5)});
      }
      else if(bw==='ROCKET'){
        // ë¡œì¼“ ì¬ì¥ì „ ì¤‘ì¸ì§€ í™•ì¸
        if(p.rocketReloading) {
          return; // ì¬ì¥ì „ ì¤‘ì´ë©´ ë°œì‚¬ ë¶ˆê°€
        }
        
        // ë¡œì¼“ íƒ„ì°½ ì‹œìŠ¤í…œ
        if(p.rocketAmmo <= 0) {
          // íƒ„ì°½ì´ ë¹„ì–´ìˆìœ¼ë©´ ê¸´ ì¬ì¥ì „ ì‹œì‘
          p.rocketReloading = true;
          p.rocketReloadTime = p.rocketMaxReloadTime;
          return; // ì´ë²ˆ í”„ë ˆì„ì—ëŠ” ë°œì‚¬í•˜ì§€ ì•ŠìŒ
        }
        
        // íƒ„ì•½ ì†Œëª¨
        p.rocketAmmo--;
        
        // ë§ˆì§€ë§‰ íƒ„í™˜ì„ ìœ ê²½ìš° ìë™ìœ¼ë¡œ ì¬ì¥ì „ ì‹œì‘
        if(p.rocketAmmo <= 0) {
          p.rocketReloading = true;
          p.rocketReloadTime = p.rocketMaxReloadTime;
        }
        
        // ë¹ ë¥¸ ì—°ì‚¬ ì†ë„ (1.5ì´ˆ ê°„ê²©)
        p.fireCd = 1.5 / playerUp.rof;
        
        const a=p.aim, spd=300*playerUp.projSpeed; // Speed up
        spawnBullet({x:p.x+Math.cos(a)*18,y:p.y+Math.sin(a)*18,vx:Math.cos(a)*spd,vy:Math.sin(a)*spd,r:6,dmg:22.5*playerUp.dmg,color:'#ffd24a',hostile:false,ttl:2.4, explode:true}); // 3ë°° ë°ë¯¸ì§€: 7.5 * 3 = 22.5
        // í”½ì…€ ìŠ¤íƒ€ì¼ ë¡œì¼“ ë°œì‚¬ ì´í™íŠ¸
        for(let i=0;i<8;i++) spawnPart({x:p.x+Math.cos(p.aim+Math.PI)*15+rand(-2,2),y:p.y+Math.sin(p.aim+Math.PI)*15+rand(-2,2),ttl:0.2,color:'#ffd24a',sz:rand(3,6)});
      }
      else if(bw==='MINIGUN'){
        p.fireCd = 0.08 / playerUp.rof;
        const a = p.aim + rand(-0.05,0.05);
        const spd = 800*playerUp.projSpeed;
        const dmg = 10*playerUp.dmg;
        const range = 1.3*playerUp.range; // ì‚¬ê±°ë¦¬ 1.3ë°° ì¦ê°€
        spawnBullet({x:p.x,y:p.y,vx:Math.cos(a)*spd*1.1,vy:Math.sin(a)*spd*1.1,r:5,dmg:dmg*0.2,ttl:0.5*range,color:'#ffd24a',hostile:false}); // Damage nerfed from 0.25 to 0.15
      }
      else if(bw==='BOOMERANG'){
        p.fireCd = 1.2 / playerUp.rof;
        const speed = 400 * playerUp.projSpeed;
        const damage = 1.2 * playerUp.dmg; // ë°ë¯¸ì§€ ë„ˆí”„: 2.0 -> 1.2
        
        spawnBullet({
          x: p.x + Math.cos(p.aim) * 15,
          y: p.y + Math.sin(p.aim) * 15,
          vx: Math.cos(p.aim) * speed,
          vy: Math.sin(p.aim) * speed,
          r: 8,
          dmg: damage,
          color: '#00ff88',
          hostile: false,
          ttl: 4.0,
          boomerang: true,
          originX: p.x,
          originY: p.y,
          launched: now(),
          spinAngle: 0
        });
        
        // ë¶€ë©”ë‘ ë°œì‚¬ ì´í™íŠ¸
        for(let i=0; i<8; i++) {
          spawnPart({
            x: p.x,
            y: p.y,
            vx: Math.cos(p.aim + i*TAU/8) * 80,
            vy: Math.sin(p.aim + i*TAU/8) * 80,
            ttl: 0.4,
            color: '#00ff88',
            sz: rand(3, 5)
          });
        }
      }
      else if(bw==='SMG'){
        p.fireCd = 0.05 / playerUp.rof; // ë§¤ìš° ë¹ ë¥¸ ì—°ì‚¬ (0.05ì´ˆ ê°„ê²©)
        const a = p.aim + rand(-0.15, 0.15); // ì‹¬í•œ íƒ„í¼ì§ (0.08 -> 0.15)
        const spd = 650 * playerUp.projSpeed; // ë¹ ë¥¸ íƒ„ì†
        const dmg = 6 * playerUp.dmg; // ë‚®ì€ ê¸°ë³¸ ë°ë¯¸ì§€
        const range = 1.2 * playerUp.range; // ì‚¬ê±°ë¦¬ 2ë°° ì¦ê°€ (0.6 -> 1.2)
        
        spawnBullet({
          x: p.x + Math.cos(a) * 10,
          y: p.y + Math.sin(a) * 10,
          vx: Math.cos(a) * spd,
          vy: Math.sin(a) * spd,
          r: 3, // ì‘ì€ íƒ„í™˜
          dmg: dmg * 0.35, // ìµœì¢… ë°ë¯¸ì§€: ë§¤ìš° ë‚®ìŒ
          ttl: 0.4 * range, // ì‚¬ê±°ë¦¬ 2ë°° ì¦ê°€
          color: '#ffaa00',
          hostile: false
        });
        
        // SMG ë°œì‚¬ ì´í™íŠ¸ (ê°„ë‹¨í•¨)
        for(let i=0; i<2; i++) {
          spawnPart({
            x: p.x + Math.cos(p.aim) * 8 + rand(-2, 2),
            y: p.y + Math.sin(p.aim) * 8 + rand(-2, 2),
            ttl: 0.1,
            color: '#ffaa00',
            sz: rand(2, 4)
          });
        }
      }
      else if(bw==='SNIPER'){
        // ì €ê²©ì´ ì¬ì¥ì „ ì¤‘ì¸ì§€ í™•ì¸
        if(p.sniperReloading) {
          return; // ì¬ì¥ì „ ì¤‘ì´ë©´ ë°œì‚¬ ë¶ˆê°€
        }
        
        // ì €ê²©ì´ íƒ„ì°½ ì‹œìŠ¤í…œ
        if(p.sniperAmmo <= 0) {
          // íƒ„ì°½ì´ ë¹„ì–´ìˆìœ¼ë©´ ê¸´ ì¬ì¥ì „ ì‹œì‘
          p.sniperReloading = true;
          p.sniperReloadTime = p.sniperMaxReloadTime;
          return; // ì´ë²ˆ í”„ë ˆì„ì—ëŠ” ë°œì‚¬í•˜ì§€ ì•ŠìŒ
        }
        
        // íƒ„ì•½ ì†Œëª¨
        p.sniperAmmo--;
        
        // ë§ˆì§€ë§‰ ì´ì•Œì„ ìœ ê²½ìš° ìë™ìœ¼ë¡œ ì¬ì¥ì „ ì‹œì‘
        if(p.sniperAmmo <= 0) {
          p.sniperReloading = true;
          p.sniperReloadTime = p.sniperMaxReloadTime;
        }
        
        // ì¼ë°˜ ë°œì‚¬ ì†ë„ (íƒ„ì°½ ë‚´ ë°œì‚¬)
        p.fireCd = 1.8 / playerUp.rof; // ë¹ ë¥¸ ì—°ì‚¬ (1.8ì´ˆ ê°„ê²©ìœ¼ë¡œ ê°ì†Œ)
        const a = p.aim; // ì •í™•í•œ ì¡°ì¤€
        const spd = 1200 * playerUp.projSpeed; // ë§¤ìš° ë¹ ë¥¸ íƒ„ì†
        const dmg = 65 * playerUp.dmg; // 1.3ë°° ë²„í”„: 50->65
        const range = 2.5 * playerUp.range; // ê¸´ ì‚¬ì •ê±°ë¦¬
        
        spawnBullet({
          x: p.x + Math.cos(a) * 25,
          y: p.y + Math.sin(a) * 25,
          vx: Math.cos(a) * spd,
          vy: Math.sin(a) * spd,
          r: 4,
          dmg: dmg * 0.8, // ìµœì¢… ë°ë¯¸ì§€: 52 (65*0.8, 1.3ë°° ë²„í”„ ì ìš©)
          ttl: 1.5 * range, // ê¸´ ì‚¬ì •ê±°ë¦¬
          color: '#ff4444',
          hostile: false,
          penetration: 2 // ê´€í†µë ¥ ì¶”ê°€
        });
        
        // ì €ê²©ì´ ë°œì‚¬ ì´í™íŠ¸ (ê°•ë ¥í•¨)
        for(let i=0; i<15; i++) {
          spawnPart({
            x: p.x + Math.cos(p.aim + Math.PI) * 20 + rand(-5, 5),
            y: p.y + Math.sin(p.aim + Math.PI) * 20 + rand(-5, 5),
            ttl: 0.3,
            color: '#ff4444',
            sz: rand(4, 8)
          });
        }
      }
      else if(bw==='DEBUG_CANNON'){
        // ë””ë²„ê·¸ ìºë…¼ - ê·¹ë„ë¡œ ê°•ë ¥í•œ ë¬´ê¸°
        p.fireCd = 0.02 / playerUp.rof; // ê·¹ë„ë¡œ ë¹ ë¥¸ ì—°ì‚¬ (0.02ì´ˆ ê°„ê²©)
        const a = p.aim; // ì •í™•í•œ ì¡°ì¤€
        const spd = 2000 * playerUp.projSpeed; // ê·¹ë„ë¡œ ë¹ ë¥¸ íƒ„ì†
        const dmg = 20 * playerUp.dmg; // ê·¹ë„ë¡œ ë†’ì€ ë°ë¯¸ì§€ (ë³´ìŠ¤ ì›í‚¬ ìˆ˜ì¤€)
        const range = 5.0 * playerUp.range; // ê·¹ë„ë¡œ ê¸´ ì‚¬ì •ê±°ë¦¬
        
        // 3ë°œì˜ ê°•ë ¥í•œ ë ˆì´ì € ë™ì‹œ ë°œì‚¬
        for(let i = -1; i <= 1; i++) {
          const spread = i * 0.1; // ì•½ê°„ì˜ í™•ì‚°
          const adjustedAngle = a + spread;
          
          spawnBullet({
            x: p.x + Math.cos(adjustedAngle) * 30,
            y: p.y + Math.sin(adjustedAngle) * 30,
            vx: Math.cos(adjustedAngle) * spd,
            vy: Math.sin(adjustedAngle) * spd,
            r: 8, // í° íƒ„í™˜
            dmg: dmg * 2.0, // ê·¹ë„ë¡œ ë†’ì€ ë°ë¯¸ì§€ (500*2=1000)
            ttl: 3.0 * range, // ë§¤ìš° ê¸´ ì‚¬ì •ê±°ë¦¬
            color: '#ff0000', // ë¹¨ê°„ìƒ‰ (ìœ„í—˜í•œ ëŠë‚Œ)
            hostile: false,
            penetration: 999, // ë¬´í•œ ê´€í†µ
            debug: true // ë””ë²„ê·¸ íƒ„í™˜ í‘œì‹œ
          });
        }
        
        // ê°•ë ¥í•œ ë””ë²„ê·¸ ë°œì‚¬ ì´í™íŠ¸
        for(let i=0; i<25; i++) {
          spawnPart({
            x: p.x + Math.cos(p.aim) * 25 + rand(-10, 10),
            y: p.y + Math.sin(p.aim) * 25 + rand(-10, 10),
            vx: Math.cos(p.aim + rand(-0.3, 0.3)) * rand(100, 300),
            vy: Math.sin(p.aim + rand(-0.3, 0.3)) * rand(100, 300),
            ttl: rand(0.4, 0.8),
            color: '#ff0000',
            sz: rand(6, 12)
          });
        }
        
        // í›„ë°© í­ë°œ ì´í™íŠ¸
        for(let i=0; i<15; i++) {
          spawnPart({
            x: p.x + Math.cos(p.aim + Math.PI) * 30 + rand(-15, 15),
            y: p.y + Math.sin(p.aim + Math.PI) * 30 + rand(-15, 15),
            vx: Math.cos(p.aim + Math.PI + rand(-0.5, 0.5)) * rand(150, 400),
            vy: Math.sin(p.aim + Math.PI + rand(-0.5, 0.5)) * rand(150, 400),
            ttl: rand(0.5, 1.0),
            color: '#ffaa00',
            sz: rand(8, 16)
          });
        }
      }
    }
  }

  // ===== ê²Œì„ ë£¨í”„ =====
  let lastT=now();
  let accFps=0, fps=0, fpsTick=0;

  let boss=null;

  function startRun(){
    // ì´ˆê¸°í™”
    clearEntities();
    gameState=STATE.PLAY;
    stageIndex=0;
    totalTime=0;
    stageStartTime=0;
    cores=0;
    playerUp.dmg=1; playerUp.rof=1; playerUp.projSpeed=1; playerUp.range=1; playerUp.survivability=1; playerUp.special={};
    player = new Player();
    boss = new Boss(BOSSES[stageIndex]);
    stageStartTime=now();
    document.getElementById('bossHp').style.display='block';
    document.getElementById('playerHpLabel').textContent = Math.floor(player.hp);
    updateHpBar();
    hideStartMenu();
    loop();
  }

  function nextStage(){
    stageIndex++;
    if(stageIndex>=BOSSES.length){
      // ì „ ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´
      stageClearAll();
      return;
    }
    gameState = STATE.PLAY;
    portal = null;
    stageNote(`STAGE ${stageIndex+1}`);
    boss = new Boss(BOSSES[stageIndex]);
    updateHpBar();
  }

  function loop(){
    if(gameState===STATE.PLAY || gameState===STATE.STAGECLEAR){
      const t=now(); let dt=(t-lastT)/1000; lastT=t;
      dt=Math.min(0.033,dt);
      totalTime = (t-stageStartTime)/1000;

      update(dt);
      draw();

      requestAnimationFrame(loop);
    }else{
      // ì¼ì‹œì •ì§€ ë“± ìƒíƒœì—ì„œ íƒ€ì„ìŠ¤íƒ¬í”„ ì—…ë°ì´íŠ¸
      lastT=now();
    }
  }

  function update(dt){
    // ì…ë ¥ ì´ë™/ê³µê²©
    player?.update(dt);

    // ì íƒ„ ì—…ë°ì´íŠ¸/ì¶©ëŒ
    for(const b of bullets){
      if(!b.alive) continue;
      if(b.ring){ // ì¶©ê²©íŒŒí˜•
        b.r += b.vr*dt;
        b.ttl -= dt;
      }else if(b.boomerang && !b.hostile){ // ë¶€ë©”ë‘
        const elapsed = (now() - b.launched) / 1000;
        b.spinAngle += dt * 15; // íšŒì „ ì• ë‹ˆë©”ì´ì…˜
        
        if(elapsed < 1.5) {
          // ë‚˜ê°€ëŠ” ë‹¨ê³„
          b.x += b.vx * dt;
          b.y += b.vy * dt;
        } else {
          // ëŒì•„ì˜¤ëŠ” ë‹¨ê³„
          const returnAngle = angleTo(b.x, b.y, b.originX, b.originY);
          const returnSpeed = 300 + (elapsed - 1.5) * 200; // ì ì  ë¹¨ë¼ì§
          b.vx = Math.cos(returnAngle) * returnSpeed;
          b.vy = Math.sin(returnAngle) * returnSpeed;
          b.x += b.vx * dt;
          b.y += b.vy * dt;
          
          // í”Œë ˆì´ì–´ì—ê²Œ ë³µê·€í–ˆëŠ”ì§€ ì²´í¬
          if(player && dist2(b.x, b.y, player.x, player.y) < 900) { // 30í”½ì…€ ë°˜ê²½
            b.alive = false;
            // ë³µê·€ ì´í™íŠ¸
            for(let i=0; i<6; i++) {
              spawnPart({
                x: b.x,
                y: b.y,
                vx: rand(-80, 80),
                vy: rand(-80, 80),
                ttl: 0.3,
                color: '#00ff88',
                sz: rand(2, 4)
              });
            }
          }
        }
        b.ttl -= dt;
      }else if(b.homing){
        const distToPlayer = Math.hypot(b.x - player.x, b.y - player.y);
        // í”Œë ˆì´ì–´ì™€ 150í”½ì…€ ì´ë‚´ë¡œ ê°€ê¹Œì›Œì§€ê±°ë‚˜ ì´ë¯¸ ì§ì§„ëª¨ë“œë©´ ì§ì§„ ëª¨ë“œ ìœ ì§€
        if(!b.straightMode && distToPlayer <= 150) {
          b.straightMode = true; // ì§ì§„ëª¨ë“œ í”Œë˜ê·¸ ì„¤ì •
        }
        
        if(!b.straightMode) {
          const a = angleTo(b.x,b.y, player.x,player.y);
          const currentAngle = Math.atan2(b.vy, b.vx);
          const turnRate = b.turnRate || 3.5;
          let angleDiff = a - currentAngle;
          // ê°ë„ ì°¨ì´ë¥¼ -Ï€ ~ Ï€ ë²”ìœ„ë¡œ ì •ê·œí™”
          while(angleDiff > Math.PI) angleDiff -= 2*Math.PI;
          while(angleDiff < -Math.PI) angleDiff += 2*Math.PI;
          const newAngle = currentAngle + Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), turnRate * dt);
          b.vx = Math.cos(newAngle)*b.spd; 
          b.vy = Math.sin(newAngle)*b.spd;
        }
        // ì§ì§„ ëª¨ë“œê±°ë‚˜ ê°€ê¹Œìš°ë©´ í˜„ì¬ ë°©í–¥ ìœ ì§€
        b.x+=b.vx*dt; b.y+=b.vy*dt; b.ttl-=dt;
      }else{
        b.x+=b.vx*dt; b.y+=b.vy*dt; b.ttl-=dt;
      }
      // í”Œë ˆì´ì–´ì™€ ì¶©ëŒ(ì íƒ„)
      if(b.hostile && player?.alive){
        let hit=false;
        if(b.ring){
          // ì›í˜• ì‰˜ â€” í”Œë ˆì´ì–´ ì¤‘ì‹¬ ê±°ë¦¬ì™€ ë§ ë°˜ì§€ë¦„ ì°¨ì´
          const d = Math.hypot(player.x-b.x, player.y-b.y);
          if(Math.abs(d-b.r) < (b.thick + player.r)) hit=true;
        }else{
          if(dist2(player.x,player.y,b.x,b.y) <= (player.r + b.r)*(player.r + b.r)) hit=true;
        }
        if(hit){
          b.alive=false;
          player.hit(b.dmg||1);
        }
      }
      // ë³´ìŠ¤ì™€ í”Œë ˆì´ì–´íƒ„ ì¶©ëŒ
      if(!b.hostile && boss && boss.alive){
        if(b.laser){
          if(Math.hypot(boss.x-b.x,boss.y-b.y) <= b.r + boss.r) { boss.take(b.dmg||0.5); }
        }else{
          if(dist2(boss.x,boss.y,b.x,b.y) <= (boss.r + b.r)*(boss.r + b.r)){
            boss.take(b.dmg||1);
            
            // í”Œë¼ì¦ˆë§ˆëŠ” ê´€í†µ, ë¶€ë©”ë‘ì€ í†µê³¼
            if(!b.plasma && !b.boomerang) {
              b.alive=false;
            } else if(b.plasma && b.penetration !== undefined) {
              b.penetration--;
              if(b.penetration < 0) b.alive = false;
              // í”Œë¼ì¦ˆë§ˆ ê´€í†µ ì´í™íŠ¸
              for(let i=0; i<8; i++) {
                spawnPart({
                  x: b.x + rand(-10, 10),
                  y: b.y + rand(-10, 10),
                  ttl: rand(0.2, 0.4),
                  color: b.color,
                  sz: rand(3, 6)
                });
              }
            }
            
            if(b.explode){
              // í”½ì…€ ìŠ¤íƒ€ì¼ í­ë°œ ì´í™íŠ¸
              for(let i=0;i<50;i++){
                const aa=Math.random()*TAU, sp=rand(80,280);
                const size = rand(2,8);
                const colors = ['#ffd24a', '#ff9b3b', '#ff71ff', '#ff3b5c'];
                const color = colors[Math.floor(Math.random()*colors.length)];
                spawnPart({
                 
                  x:b.x+rand(-5,5),
                  y:b.y+rand(-5,5),
                  vx:Math.cos(aa)*sp*0.6,
                  vy:Math.sin(aa)*sp*0.6,
                  sz:size,
                  ttl:rand(0.3,0.9),
                  color:color
                });
              }
              
              // ì¤‘ì‹¬ í­ë°œ ì½”ì–´
              for(let i=0;i<8;i++){
                spawnPart({
                  x:b.x,
                  y:b.y,
                  vx:rand(-50,50),
                  vy:rand(-50,50),
                  sz:rand(6,12),
                  ttl:0.4,
                  color:'#ffffff'
                });
              }
              
              // í­ë°œ ë²”ìœ„ ë°ë¯¸ì§€
              if(dist2(b.x,b.y,boss.x,boss.y) < (100+boss.r)*(100+boss.r)){
                boss.take((b.dmg||1)*1.5);
              }
            }
          }
        }
      }
      // í™”ë©´ ë°–/ìˆ˜ëª… ì¢…ë£Œ
      if(b.ttl<=0 || b.x<-60||b.x>W+60||b.y<-60||b.y>H+60) { b.alive=false; }
    }
    // í’€ ì •ë¦¬
    for(let i=bullets.length-1;i>=0;i--) if(!bullets[i].alive) bulletPool.push(bullets.splice(i,1)[0]);

    // í”Œë ˆì´ì–´ ì´ì•Œê³¼ ì  ìœ ë„íƒ„ ì¶©ëŒ ì²˜ë¦¬
    for(let i=0; i<bullets.length; i++){
      const playerBullet = bullets[i];
      if(!playerBullet.alive || playerBullet.hostile) continue;
      
      for(let j=0; j<bullets.length; j++){
        const enemyBullet = bullets[j];
        if(!enemyBullet.alive || !enemyBullet.hostile || !enemyBullet.homing) continue;
        
        if(dist2(playerBullet.x, playerBullet.y, enemyBullet.x, enemyBullet.y) < (playerBullet.r + enemyBullet.r) * (playerBullet.r + enemyBullet.r)){
          // ë¶€ë©”ë‘ê³¼ í”Œë¼ì¦ˆë§ˆëŠ” ìœ ë„íƒ„ì„ íŒŒê´´í•˜ì§€ë§Œ ê³„ì† ì§„í–‰
          if(playerBullet.boomerang || playerBullet.plasma) {
            enemyBullet.alive = false;
            // ìœ ë„íƒ„ íŒŒê´´ ì´í™íŠ¸ë§Œ ìƒì„±
            for(let k=0; k<5; k++){
              spawnPart({
                x: enemyBullet.x + rand(-5, 5),
                y: enemyBullet.y + rand(-5, 5),
                ttl: rand(0.2, 0.4),
                color: enemyBullet.color,
                sz: rand(3, 6)
              });
            }
          } else {
            // ì¼ë°˜ ì´ì•Œì€ ì„œë¡œ íŒŒê´´
            playerBullet.alive = false;
            enemyBullet.alive = false;
            // íŒŒê´´ ì´í™íŠ¸
            for(let k=0; k<5; k++){
              spawnPart({
                x: enemyBullet.x + rand(-5, 5),
                y: enemyBullet.y + rand(-5, 5),
                ttl: rand(0.2, 0.4),
                color: enemyBullet.color,
                sz: rand(3, 6)
              });
            }
          }
          break;
        }
      }
    }

    // íŒŒí‹°í´
    for(const p of parts){
      p.ttl-=dt;
      if(p.vx) p.x += p.vx*dt;
      if(p.vy) p.y += p.vy*dt;
    }
    for(let i=parts.length-1;i>=0;i--) if(parts[i].ttl<=0){ partPool.push(parts.splice(i,1)[0]); }

    // ì½”ì–´(ê²½í—˜ì¹˜)
    for(const o of orbs){
      o.ttl-=dt;
      // í”Œë ˆì´ì–´ì—ê²Œ ëŒë¦¼
      const a=angleTo(o.x,o.y, player.x,player.y);
      const s= 80 + (200*(1 - Math.min(1,Math.hypot(o.x-player.x,o.y-player.y)/300)));
      o.vx += Math.cos(a)*s*dt*0.6;
      o.vy += Math.sin(a)*s*dt*0.6;
      o.vx*=0.96; o.vy*=0.96;
      o.x+=o.vx*dt; o.y+=o.vy*dt;
      if(dist2(o.x,o.y,player.x,player.y) < (o.r+player.r)*(o.r+player.r)){
        cores += o.amt;
        o.alive=false;
      }
    }
    for(let i=orbs.length-1;i>=0;i--) if(!orbs[i].alive || orbs[i].ttl<=0) orbs.splice(i,1);

    // ë³´ìŠ¤
    if(boss && boss.alive) boss.update(dt);
    updateHpBar();

    // í¬íƒˆ
    if (gameState === STATE.STAGECLEAR && portal) {
      portal.t += dt;
      if (player && dist2(player.x, player.y, portal.x, portal.y) < (player.r + portal.r) * (player.r + portal.r)) {
        nextStage();
      }
    }

    // UI ë¼ë²¨
    document.getElementById('coreLabel').textContent = cores|0;
    document.getElementById('stageLabel').textContent = (stageIndex+1);

    // FPS
    if(settings.showFps){
      accFps++; fpsTick+=dt;
      if(fpsTick>=1){ fps=accFps; accFps=0; fpsTick=0; }
    }
  }

  function draw(){
    // ë°°ê²½ ë„¤íŠ¸ì›Œí¬
    ctx.clearRect(0,0,W,H);
    drawGrid();

    // íŒŒí‹°í´/ì˜¤ë¸Œì íŠ¸/íƒ„
    for(const o of orbs){
      drawPixelOrb(o.x, o.y, o.r, settings.colorBlind?'#00e5ff':'#49f3ff');
    }
    
    // ë³´ìŠ¤
    boss?.draw(ctx);
    
    // VOID_REAPER íŠ¹ìˆ˜ ì´í™íŠ¸ ë Œë”ë§
    if(boss && boss.cfg.id === 'VOID_REAPER') {
      // ê·¸ë¦¼ì ë²½ ë Œë”ë§
      if(boss._sw && boss._sw.walls) {
        for(const wall of boss._sw.walls) {
          if(wall.phase === 'warning') {
            // ê²½ê³  ë‹¨ê³„ - ê¹œë¹¡ì´ëŠ” ë°˜íˆ¬ëª… ë²½
            ctx.save();
            ctx.globalAlpha = 0.3 + Math.sin(now() * 0.01) * 0.2;
            ctx.fillStyle = '#ff3b5c';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ff3b5c';
            ctx.fillRect(wall.x - wall.width/2, wall.y - wall.height/2, wall.width, wall.height);
            
            // í‹ˆ í‘œì‹œ (ì´ˆë¡ìƒ‰)
            ctx.fillStyle = '#00ff88';
            ctx.shadowColor = '#00ff88';
            for(const gap of wall.gaps) {
              ctx.fillRect(gap.x - gap.width/2, gap.y - gap.height/2, gap.width, gap.height);
            }
            ctx.restore();
          } else if(wall.phase === 'moving') {
            // ì´ë™ ë‹¨ê³„ - ë‹¨ë‹¨í•œ ë²½
            ctx.save();
            ctx.fillStyle = wall.color;
            ctx.shadowBlur = 10;
            ctx.shadowColor = wall.color;
            ctx.fillRect(wall.x - wall.width/2, wall.y - wall.height/2, wall.width, wall.height);
            
            // í‹ˆì€ íˆ¬ëª…í•˜ê²Œ (ê²€ì€ìƒ‰ìœ¼ë¡œ ëš«ë¦¼)
            ctx.globalCompositeOperation = 'destination-out';
            for(const gap of wall.gaps) {
              ctx.fillRect(gap.x - gap.width/2, gap.y - gap.height/2, gap.width, gap.height);
            }
            ctx.restore();
          }
        }
      }
      
      // ì™œê³¡ í•„ë“œ ë Œë”ë§
      if(boss._sd && boss._sd.distortionFields) {
        for(const field of boss._sd.distortionFields) {
          ctx.save();
          ctx.globalAlpha = field.intensity * 0.4;
          
          // ì™œê³¡ í•„ë“œ ì‹œê° íš¨ê³¼ (ë™ì‹¬ì›)
          for(let i = 3; i > 0; i--) {
            ctx.strokeStyle = '#8B00FF';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#8B00FF';
            ctx.beginPath();
            ctx.arc(field.x, field.y, field.radius * (i/3) * field.intensity, 0, TAU);
            ctx.stroke();
          }
          ctx.restore();
        }
      }
      
      // ë¸”ë™í™€ ë Œë”ë§ (ê·¸ë˜í”½ ëª¨ë“œì— ë”°ë¼ ì¡°ì ˆ)
      if(boss._dc && boss._dc.blackholes) {
        for(const bh of boss._dc.blackholes) {
          ctx.save();
          
          const intensity = getEffectIntensity();
          const time = now() * 0.001;
          const pulse = Math.sin(time * 3) * 0.5 + 0.5;
          const rotation = time * 2;
          
          if(settings.graphicsMode === 'performance') {
            // ì„±ëŠ¥ ëª¨ë“œ: ë‹¨ìˆœí•œ ë¸”ë™í™€
            ctx.fillStyle = getColorBlindSafeColor('#000000', 'blackhole');
            ctx.shadowBlur = 10;
            ctx.shadowColor = getColorBlindSafeColor('#8B00FF', 'blackhole');
            ctx.beginPath();
            ctx.arc(bh.x, bh.y, bh.radius * 0.4, 0, TAU);
            ctx.fill();
            
            // ë‹¨ìˆœí•œ ë§
            ctx.strokeStyle = getColorBlindSafeColor('#8B00FF', 'blackhole');
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(bh.x, bh.y, bh.radius * 0.7, 0, TAU);
            ctx.stroke();
            
          } else if(settings.graphicsMode === 'simple') {
            // ë‹¨ìˆœ ëª¨ë“œ: ê¸°ë³¸ì ì¸ ë¸”ë™í™€ + ëª‡ ê°œ ë§
            const ringCount = 4;
            ctx.globalAlpha = 0.4;
            for(let i = 1; i <= ringCount; i++) {
              const radiusMultiplier = 0.4 + i * 0.15;
              const alpha = (ringCount - i) / ringCount * 0.6;
              ctx.globalAlpha = alpha;
              
              ctx.strokeStyle = getColorBlindSafeColor('#8B00FF', 'blackhole');
              ctx.lineWidth = 2;
              ctx.shadowBlur = 8;
              ctx.shadowColor = ctx.strokeStyle;
              
              ctx.beginPath();
              ctx.arc(bh.x, bh.y, bh.radius * radiusMultiplier, 0, TAU);
              ctx.stroke();
            }
            
            // ì¤‘ì‹¬ë¶€
            const gradient = ctx.createRadialGradient(bh.x, bh.y, 0, bh.x, bh.y, bh.radius * 0.4);
            gradient.addColorStop(0, '#000000');
            gradient.addColorStop(1, getColorBlindSafeColor('#8B00FF', 'blackhole'));
            
            ctx.fillStyle = gradient;
            ctx.shadowBlur = 20;
            ctx.shadowColor = getColorBlindSafeColor('#8B00FF', 'blackhole');
            ctx.beginPath();
            ctx.arc(bh.x, bh.y, bh.radius * 0.4, 0, TAU);
            ctx.fill();
            
          } else {
            // í™”ë ¤í•¨ ëª¨ë“œ: ëª¨ë“  íš¨ê³¼ (ê¸°ì¡´ ì½”ë“œ ìœ ì§€í•˜ë˜ ìƒ‰ì•½ ë³´ì¡° ì ìš©)
            // ë°°ê²½ ì™œê³¡ ë§ë“¤ (ë” ë§ê³  í™”ë ¤í•˜ê²Œ)
            ctx.globalAlpha = 0.4;
            for(let i = 1; i <= 8; i++) {
              const radiusMultiplier = 0.4 + i * 0.15;
              const alpha = (8 - i) / 8 * 0.6;
              ctx.globalAlpha = alpha;
              
              // ë‹¤ì–‘í•œ ìƒ‰ìƒì˜ ë§ (ìƒ‰ì•½ ë³´ì¡° ì ìš©)
              const colors = [
                getColorBlindSafeColor('#8B00FF', 'blackhole'), 
                getColorBlindSafeColor('#4B0082', 'blackhole'), 
                getColorBlindSafeColor('#9400D3', 'blackhole'), 
                getColorBlindSafeColor('#FF00FF', 'blackhole'), 
                getColorBlindSafeColor('#DA70D6', 'blackhole')
              ];
              ctx.strokeStyle = colors[i % colors.length];
              ctx.lineWidth = 3 + pulse * 2;
              ctx.shadowBlur = 15 + pulse * 10;
              ctx.shadowColor = ctx.strokeStyle;
              ctx.setLineDash([5, 10]);
              ctx.lineDashOffset = rotation * (i % 2 === 0 ? 1 : -1) * 20;
              
              ctx.beginPath();
              ctx.arc(bh.x, bh.y, bh.radius * radiusMultiplier, 0, TAU);
              ctx.stroke();
            }
            
            // íšŒì „í•˜ëŠ” ë‚˜ì„  íš¨ê³¼
            ctx.setLineDash([]);
            ctx.globalAlpha = 0.7;
            ctx.lineWidth = 2;
            for(let spiral = 0; spiral < 3; spiral++) {
              const spiralColors = [
                getColorBlindSafeColor('#8B00FF', 'blackhole'), 
                getColorBlindSafeColor('#FF00FF', 'blackhole'), 
                getColorBlindSafeColor('#4B0082', 'blackhole')
              ];
              ctx.strokeStyle = spiralColors[spiral];
              ctx.shadowBlur = 20;
              ctx.shadowColor = ctx.strokeStyle;
              ctx.beginPath();
              
              const spiralOffset = spiral * TAU / 3 + rotation;
              for(let angle = 0; angle < TAU * 3; angle += 0.1) {
                const r = bh.radius * 0.3 + (angle / (TAU * 3)) * bh.radius * 0.4;
                const x = bh.x + Math.cos(angle + spiralOffset) * r;
                const y = bh.y + Math.sin(angle + spiralOffset) * r;
                
                if(angle === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
              }
              ctx.stroke();
            }
            
            // ë¸”ë™í™€ ì¤‘ì‹¬ë¶€ (ë” ê°•ë ¬í•˜ê²Œ)
            const gradient = ctx.createRadialGradient(bh.x, bh.y, 0, bh.x, bh.y, bh.radius * 0.4);
            gradient.addColorStop(0, '#000000');
            gradient.addColorStop(0.7, '#1a0033');
            gradient.addColorStop(1, getColorBlindSafeColor('#8B00FF', 'blackhole'));
            
            ctx.fillStyle = gradient;
            ctx.shadowBlur = 30 + pulse * 15;
            ctx.shadowColor = getColorBlindSafeColor('#8B00FF', 'blackhole');
            ctx.beginPath();
            ctx.arc(bh.x, bh.y, bh.radius * 0.4, 0, TAU);
            ctx.fill();
            
            // ì¤‘ì‹¬ í•µ (ë°ì€ ì )
            ctx.fillStyle = '#FFFFFF';
            ctx.shadowBlur = 40;
            ctx.shadowColor = getColorBlindSafeColor('#FF00FF', 'blackhole');
            ctx.beginPath();
            ctx.arc(bh.x, bh.y, 3 + pulse * 2, 0, TAU);
            ctx.fill();
            
            // ì£¼ë³€ íŒŒí‹°í´ íš¨ê³¼ (ë²ˆê°œê°™ì€ ì„ ë“¤)
            ctx.globalAlpha = 0.8;
            ctx.lineWidth = 1;
            for(let i = 0; i < 12; i++) {
              const angle = (i / 12) * TAU + rotation;
              const length = bh.radius * (0.5 + pulse * 0.3);
              
              const lightningColors = [
                getColorBlindSafeColor('#8B00FF', 'blackhole'), 
                getColorBlindSafeColor('#FF00FF', 'blackhole'), 
                getColorBlindSafeColor('#DA70D6', 'blackhole')
              ];
              ctx.strokeStyle = lightningColors[i % 3];
              ctx.shadowBlur = 15;
              ctx.shadowColor = ctx.strokeStyle;
              
              ctx.beginPath();
              ctx.moveTo(bh.x + Math.cos(angle) * bh.radius * 0.3, 
                        bh.y + Math.sin(angle) * bh.radius * 0.3);
              
              // ì§€ê·¸ì¬ê·¸ ë¼ì¸
              for(let j = 1; j <= 5; j++) {
                const progress = j / 5;
                const zigzag = Math.sin(progress * TAU * 2) * 15;
                const perpAngle = angle + Math.PI / 2;
                const x = bh.x + Math.cos(angle) * length * progress + 
                         Math.cos(perpAngle) * zigzag;
                const y = bh.y + Math.sin(angle) * length * progress + 
                         Math.sin(perpAngle) * zigzag;
                ctx.lineTo(x, y);
              }
              ctx.stroke();
            }
          } // í™”ë ¤í•¨ ëª¨ë“œ ë
          
          ctx.restore();
        }
      }
      
      // ì°¨ì› ê· ì—´ ë Œë”ë§
      if(boss._dc && boss._dc.rifts) {
        for(const rift of boss._dc.rifts) {
          ctx.save();
          
          // ê· ì—´ ë¼ì¸
          ctx.strokeStyle = '#4B0082';
          ctx.lineWidth = rift.width;
          ctx.shadowBlur = 12;
          ctx.shadowColor = '#4B0082';
          ctx.lineCap = 'round';
          
          const startX = rift.x - Math.cos(rift.angle) * rift.length/2;
          const startY = rift.y - Math.sin(rift.angle) * rift.length/2;
          const endX = rift.x + Math.cos(rift.angle) * rift.length/2;
          const endY = rift.y + Math.sin(rift.angle) * rift.length/2;
          
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(endX, endY);
          ctx.stroke();
          
          // ê· ì—´ ì¤‘ì‹¬ ë¹›
          ctx.strokeStyle = '#8B00FF';
          ctx.lineWidth = rift.width * 0.3;
          ctx.shadowBlur = 8;
          ctx.shadowColor = '#8B00FF';
          ctx.stroke();
          
          ctx.restore();
        }
      }
    }

    // í¬íƒˆ
    if (portal) {
      drawPixelPortal(portal.x, portal.y, portal.r, portal.t);
    }

    // ì íƒ„
    for(const b of bullets){
      if(!b.alive) continue;
      if(b.ring){
        ctx.save();
        ctx.strokeStyle=b.color||'#49f3ff';
        ctx.lineWidth=b.thick||6;
        ctx.shadowBlur = 8;
        ctx.shadowColor = b.color||'#49f3ff';
        ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,TAU); ctx.stroke();
        ctx.restore();
      }else if(b.boomerang){
        // ë¶€ë©”ë‘ íŠ¹ë³„ ë Œë”ë§
        ctx.save();
        ctx.translate(b.x, b.y);
        ctx.rotate(b.spinAngle || 0);
        ctx.fillStyle = b.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = b.color;
        // ë¶€ë©”ë‘ ëª¨ì–‘ (Vì)
        ctx.fillRect(-b.r, -2, b.r*2, 4);
        ctx.fillRect(-2, -b.r, 4, b.r*2);
        ctx.restore();
      }else if(b.plasma){
        // í”Œë¼ì¦ˆë§ˆ íŠ¹ë³„ ë Œë”ë§
        ctx.save();
        ctx.fillStyle = b.color;
        ctx.shadowBlur = 15;
        ctx.shadowColor = b.color;
        ctx.fillRect(b.x - b.r, b.y - b.r, b.r*2, b.r*2);
        // ë‚´ë¶€ ì½”ì–´
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(b.x - b.r*0.4, b.y - b.r*0.4, b.r*0.8, b.r*0.8);
        ctx.restore();
      }else if(b.debug){
        // ë””ë²„ê·¸ íƒ„í™˜ íŠ¹ë³„ ë Œë”ë§
        ctx.save();
        
        // ê°•ë ¥í•œ ê¸€ë¡œìš° ì´í™íŠ¸
        ctx.shadowBlur = 25;
        ctx.shadowColor = b.color;
        
        // ì™¸ë¶€ ë§
        ctx.strokeStyle = b.color;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r + 3, 0, TAU);
        ctx.stroke();
        
        // ë‚´ë¶€ ì½”ì–´
        ctx.fillStyle = b.color;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, TAU);
        ctx.fill();
        
        // ì¤‘ì‹¬ í•˜ì´ë¼ì´íŠ¸
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r * 0.4, 0, TAU);
        ctx.fill();
        
        // íšŒì „í•˜ëŠ” ì™¸ë¶€ ë§
        const time = now() * 0.01;
        ctx.strokeStyle = '#ffff00';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.lineDashOffset = time * 10;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r + 6, 0, TAU);
        ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.restore();
      }else{
        drawPixelBullet(b.x, b.y, b.r, b.color||'#49f3ff', !b.hostile);
      }
    }
    
    // í”Œë ˆì´ì–´
    player?.draw(ctx);

    // íŒŒí‹°í´
    for(const p of parts){
      drawPixelParticle(p.x, p.y, p.sz, p.color||'#fff', p.ttl);
    }

    // ëŒ€ì‰¬ ì¿¨ë‹¤ìš´ í‘œì‹œ
    if(player && gameState === STATE.PLAY) {
      const dashRatio = 1 - (player.dashCd / player.dashCooldown);
      const barWidth = 60;
      const barHeight = 6;
      const barX = W - barWidth - 20;
      const barY = 50;
      
      ctx.save();
      // ë°°ê²½
      ctx.fillStyle = '#333333';
      ctx.fillRect(barX, barY, barWidth, barHeight);
      // ì§„í–‰ë„
      ctx.fillStyle = dashRatio >= 1 ? '#00ff88' : '#666666';
      ctx.fillRect(barX, barY, barWidth * dashRatio, barHeight);
      // í…Œë‘ë¦¬
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 1;
      ctx.strokeRect(barX, barY, barWidth, barHeight);
      // ë¼ë²¨
      ctx.fillStyle = '#ffffff';
      ctx.font = '12px monospace';
      ctx.fillText('DASH', barX, barY - 2);
      ctx.restore();
    }

    // ë””ë²„ê·¸
    if(settings.showFps){
      ctx.fillStyle='#9ff'; ctx.fillText(`${fps} fps`, 10, 16);
    }
    
    // ë””ë²„ê·¸ ëª¨ë“œ í‘œì‹œ
    if(settings.debugMode){
      ctx.fillStyle='#ff0000'; 
      ctx.font='16px monospace';
      ctx.fillText('DEBUG MODE - INVINCIBLE', 10, 40);
      ctx.font='12px monospace'; // í°íŠ¸ ë³µì›
    }
    
    // ì €ê²©ì´ íƒ„ì•½/ì¬ì¥ì „ í‘œì‹œ
    if(player && player.weapon === 'SNIPER') {
      const dashBarX = W - 80; // ëŒ€ì‰¬ ë°” ìœ„ì¹˜ ê¸°ì¤€
      const dashBarY = 50;
      
      ctx.save();
      
      if(player.sniperReloading) {
        // ì¬ì¥ì „ ì¤‘ - ë¡œë”© ë°” í‘œì‹œ
        const reloadRatio = 1 - (player.sniperReloadTime / player.sniperMaxReloadTime);
        const barWidth = 60;
        const barHeight = 6;
        const barX = dashBarX - barWidth - 15;
        const barY = dashBarY;
        
        // ë°°ê²½
        ctx.fillStyle = '#333333';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        // ì§„í–‰ë„
        ctx.fillStyle = reloadRatio >= 1 ? '#ffaa00' : '#ff6666';
        ctx.fillRect(barX, barY, barWidth * reloadRatio, barHeight);
        // í…Œë‘ë¦¬
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, barWidth, barHeight);
        // ë¼ë²¨
        ctx.fillStyle = '#ffffff';
        ctx.font = '10px monospace';
        ctx.fillText('RELOAD', barX, barY - 2);
      } else {
        // ì¼ë°˜ ìƒíƒœ - íƒ„ì•½ ê°œìˆ˜ í‘œì‹œ
        const bulletSize = 6;
        const bulletSpacing = 10;
        const startX = dashBarX - (player.sniperMaxAmmo * bulletSpacing) - 15; // ëŒ€ì‰¬ ë°” ì™¼ìª½ì— ìœ„ì¹˜
        const startY = dashBarY + 3; // ëŒ€ì‰¬ ë°”ì™€ ê°™ì€ ë†’ì´
        
        for(let i = 0; i < player.sniperMaxAmmo; i++) {
          const x = startX + i * bulletSpacing;
          const y = startY;
          
          if(i < player.sniperAmmo) {
            // ë‚¨ì€ íƒ„ì•½ - ë°ì€ ìƒ‰
            ctx.fillStyle = '#ffaa00';
          } else {
            // ì‚¬ìš©ëœ íƒ„ì•½ - ì–´ë‘ìš´ ìƒ‰
            ctx.fillStyle = '#333333';
          }
          
          // ì´ì•Œ ëª¨ì–‘ ê·¸ë¦¬ê¸° (ì‘ì€ ì›í˜•)
          ctx.beginPath();
          ctx.arc(x, y, bulletSize/2, 0, Math.PI * 2);
          ctx.fill();
          
          // ì´ì•Œ í…Œë‘ë¦¬
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.stroke();
        }
        
        // ë¼ë²¨
        ctx.fillStyle = '#ffffff';
        ctx.font = '10px monospace';
        ctx.fillText('AMMO', startX - 5, dashBarY - 2);
      }
      ctx.restore();
    }
    
    // ë¡œì¼“ íƒ„ì•½/ì¬ì¥ì „ í‘œì‹œ
    if(player && player.weapon === 'ROCKET') {
      const dashBarX = W - 80; // ëŒ€ì‰¬ ë°” ìœ„ì¹˜ ê¸°ì¤€
      const dashBarY = 50;
      
      ctx.save();
      
      if(player.rocketReloading) {
        // ì¬ì¥ì „ ì¤‘ - ë¡œë”© ë°” í‘œì‹œ
        const reloadRatio = 1 - (player.rocketReloadTime / player.rocketMaxReloadTime);
        const barWidth = 60;
        const barHeight = 6;
        const barX = dashBarX - barWidth - 15;
        const barY = dashBarY;
        
        // ë°°ê²½
        ctx.fillStyle = '#333333';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        // ì§„í–‰ë„
        ctx.fillStyle = reloadRatio >= 1 ? '#ffd24a' : '#ff6666';
        ctx.fillRect(barX, barY, barWidth * reloadRatio, barHeight);
        // í…Œë‘ë¦¬
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, barWidth, barHeight);
        // ë¼ë²¨
        ctx.fillStyle = '#ffffff';
        ctx.font = '10px monospace';
        ctx.fillText('RELOAD', barX, barY - 2);
      } else {
        // ì¼ë°˜ ìƒíƒœ - íƒ„ì•½ ê°œìˆ˜ í‘œì‹œ
        const rocketSize = 8; // ë¡œì¼“ì€ ì¡°ê¸ˆ ë” í¬ê²Œ
        const rocketSpacing = 12;
        const startX = dashBarX - (player.rocketMaxAmmo * rocketSpacing) - 15; // ëŒ€ì‰¬ ë°” ì™¼ìª½ì— ìœ„ì¹˜
        const startY = dashBarY + 3; // ëŒ€ì‰¬ ë°”ì™€ ê°™ì€ ë†’ì´
        
        for(let i = 0; i < player.rocketMaxAmmo; i++) {
          const x = startX + i * rocketSpacing;
          const y = startY;
          
          if(i < player.rocketAmmo) {
            // ë‚¨ì€ íƒ„ì•½ - ë¡œì¼“ ìƒ‰ìƒ
            ctx.fillStyle = '#ffd24a';
          } else {
            // ì‚¬ìš©ëœ íƒ„ì•½ - ì–´ë‘ìš´ ìƒ‰
            ctx.fillStyle = '#333333';
          }
          
          // ë¡œì¼“ ëª¨ì–‘ ê·¸ë¦¬ê¸° (ë‘¥ê·¼ ì‚¬ê°í˜•)
          ctx.beginPath();
          ctx.roundRect(x - rocketSize/3, y - rocketSize/2, rocketSize/1.5, rocketSize, 2);
          ctx.fill();
          
          // ë¡œì¼“ í…Œë‘ë¦¬
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.stroke();
        }
        
        // ë¼ë²¨
        ctx.fillStyle = '#ffffff';
        ctx.font = '10px monospace';
        ctx.fillText('ROCKETS', startX - 8, dashBarY - 2);
      }
      ctx.restore();
    }
    
    // ë””ë²„ê·¸ ë¬´ê¸° í‘œì‹œ
    if(player && player.weapon === 'DEBUG_CANNON' && settings.debugMode) {
      const dashBarX = W - 80; // ëŒ€ì‰¬ ë°” ìœ„ì¹˜ ê¸°ì¤€
      const dashBarY = 50;
      
      ctx.save();
      
      // ë””ë²„ê·¸ ë¬´ê¸° ìƒíƒœ í‘œì‹œ
      const barWidth = 100;
      const barHeight = 8;
      const barX = dashBarX - barWidth - 15;
      const barY = dashBarY + 20; // ëŒ€ì‰¬ ë°” ì•„ë˜ì— ìœ„ì¹˜
      
      // ê¹œë¹¡ì´ëŠ” ë°°ê²½
      const flashIntensity = Math.sin(now() * 0.01) * 0.3 + 0.7;
      ctx.fillStyle = `rgba(255, 0, 0, ${flashIntensity * 0.3})`;
      ctx.fillRect(barX - 5, barY - 5, barWidth + 10, barHeight + 10);
      
      // ë©”ì¸ ë°”
      ctx.fillStyle = '#ff0000';
      ctx.fillRect(barX, barY, barWidth, barHeight);
      
      // ë‚´ë¶€ í„ìŠ¤ íš¨ê³¼
      const pulseIntensity = Math.sin(now() * 0.02) * 0.5 + 0.5;
      ctx.fillStyle = `rgba(255, 255, 0, ${pulseIntensity})`;
      ctx.fillRect(barX + 2, barY + 2, (barWidth - 4) * pulseIntensity, barHeight - 4);
      
      // í…Œë‘ë¦¬
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      ctx.strokeRect(barX, barY, barWidth, barHeight);
      
      // ê²½ê³  ë¼ë²¨
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 10px monospace';
      ctx.fillText('âš ï¸ DEBUG WEAPON âš ï¸', barX - 10, barY - 8);
      
      // í™”ë ¥ í‘œì‹œ
      ctx.fillStyle = '#ffff00';
      ctx.font = '8px monospace';
      ctx.fillText('POWER: âˆ', barX + barWidth + 5, barY + 6);
      
      ctx.restore();
    }
  }



 function drawGrid(){
    const t = now()*0.0005;
    ctx.save();
    
    // í”½ì…€ ìŠ¤íƒ€ì¼ ë„¤ì˜¨ ê·¸ë¦¬ë“œ
    ctx.strokeStyle='rgba(73,243,255,0.12)';
    ctx.lineWidth=1;
    ctx.shadowBlur = 3;
    ctx.shadowColor = 'rgba(73,243,255,0.3)';
    
    // ìˆ˜ì§ì„ ë“¤
    for(let x=40; x<W; x+=40){
      const offset = Math.sin((x*0.01)+t*4)*3;
      ctx.beginPath();
      ctx.moveTo(x + offset, 80);
      ctx.lineTo(x + offset, H);
      ctx.stroke();
    }
    
    // ìˆ˜í‰ì„ ë“¤
    for(let y=80; y<H; y+=40){
      const offset = Math.sin((y*0.01)+t*5)*2;
      ctx.beginPath();
      ctx.moveTo(40, y + offset);
      ctx.lineTo(W, y + offset);
      ctx.stroke();
    }
    
    // í”½ì…€ ë„íŠ¸ë“¤ (êµì°¨ì ì—)
    ctx.fillStyle='rgba(255,113,255,0.15)';
    ctx.shadowBlur = 2;
    ctx.shadowColor = 'rgba(255,113,255,0.5)';
    for(let x=40; x<W; x+=120){
      for(let y=80; y<H; y+=120){
        const dotOffset = Math.sin(t*6 + x*0.01 + y*0.01)*2;
        ctx.fillRect(x + dotOffset - 1, y + dotOffset - 1, 2, 2);
      }
    }
    
    ctx.restore();
  }
  function neonCircle(x,y,r,color){
    ctx.save();
    ctx.shadowBlur=12; ctx.shadowColor=color; ctx.fillStyle=color;
    ctx.beginPath(); ctx.arc(x,y,r,0,TAU); ctx.fill();
    ctx.shadowBlur=0; ctx.restore();
  }

  // ===== í”½ì…€ ì•„íŠ¸ ìŠ¤íƒ€ì¼ ê·¸ë˜í”½ í•¨ìˆ˜ë“¤ =====
  function drawPixelSquare(x, y, size, color) {
    ctx.fillStyle = color;
    ctx.fillRect(Math.floor(x - size/2), Math.floor(y - size/2), size, size);
  }

  function drawPixelPlayer(x, y, r, aim) {
    const pixelSize = 3;
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(aim);
    
    // í”Œë ˆì´ì–´ ëª¸ì²´ (ì‹­ì ëª¨ì–‘)
    ctx.fillStyle = '#49f3ff';
    ctx.shadowBlur = 8;
    ctx.shadowColor = '#49f3ff';
    
    // ì¤‘ì•™ ì½”ì–´
    ctx.fillRect(-6, -6, 12, 12);
    // íŒ” ë¶€ë¶„
    ctx.fillRect(-12, -3, 6, 6);
    ctx.fillRect(6, -3, 6, 6);
    ctx.fillRect(-3, -12, 6, 6);
    ctx.fillRect(-3, 6, 6, 6);
    
    // ë¬´ê¸° í‘œì‹œ
    ctx.fillStyle = '#ff71ff';
    ctx.fillRect(12, -2, 8, 4); // ë¬´ê¸°
    
    ctx.restore();
  }

  function drawPixelBoss(x, y, r, color, phase) {
    const pixelSize = 4;
    const time = now() * 0.001;
    ctx.save();
    ctx.translate(x, y);
    
    // ë³´ìŠ¤ ë°°ê²½ ê¸€ë¡œìš° - ìì—°ìŠ¤ëŸ¬ìš´ ì›í˜• ê·¸ë¼ë°ì´ì…˜
    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, r * 1.8);
    gradient.addColorStop(0, color + '44');
    gradient.addColorStop(0.3, color + '22');
    gradient.addColorStop(0.6, color + '11');
    gradient.addColorStop(1, color + '00');
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(0, 0, r * 1.8, 0, TAU);
    ctx.fill();
    
    // ì¶”ê°€ í„ìŠ¤ ê¸€ë¡œìš° íš¨ê³¼
    const pulseIntensity = Math.sin(time * 3) * 0.3 + 0.7;
    const pulseGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, r * 1.2 * pulseIntensity);
    pulseGradient.addColorStop(0, color + '33');
    pulseGradient.addColorStop(0.5, color + '11');
    pulseGradient.addColorStop(1, color + '00');
    
    ctx.fillStyle = pulseGradient;
    ctx.beginPath();
    ctx.arc(0, 0, r * 1.2 * pulseIntensity, 0, TAU);
    ctx.fill();
    
    // ë³´ìŠ¤ ì¤‘ì•™ ì½”ì–´ - ë” í¬ê³  í™”ë ¤í•˜ê²Œ
    ctx.fillStyle = color;
    ctx.shadowBlur = 20;
    ctx.shadowColor = color;
    
    const coreSize = 28;
    ctx.fillRect(-coreSize/2, -coreSize/2, coreSize, coreSize);
    
    // ì½”ì–´ ë‚´ë¶€ ë””í…Œì¼
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(-8, -8, 16, 16);
    ctx.fillStyle = color;
    ctx.fillRect(-4, -4, 8, 8);
    
    // í˜ì´ì¦ˆë³„ ë³µì¡í•œ ë””í…Œì¼
    if(phase === 0) { // ë§ íŒ¨í„´ - íšŒì „í•˜ëŠ” ë§ë“¤
      ctx.fillStyle = color;
      // ì™¸ë¶€ ë§
      for(let i = 0; i < 12; i++) {
        const angle = (i / 12) * TAU + time * 2;
        const px = Math.cos(angle) * 32;
        const py = Math.sin(angle) * 32;
        ctx.fillRect(px - 4, py - 4, 8, 8);
      }
      // ì¤‘ê°„ ë§ (ë°˜ëŒ€ ë°©í–¥)
      ctx.fillStyle = '#00e5ff';
      for(let i = 0; i < 8; i++) {
        const angle = (i / 8) * TAU - time * 1.5;
        const px = Math.cos(angle) * 22;
        const py = Math.sin(angle) * 22;
        ctx.fillRect(px - 3, py - 3, 6, 6);
      }
    } else if(phase === 1) { // ìŠ¤íŒŒì´ëŸ´ íŒ¨í„´ - íšŒì „ ì•”ë“¤
      // ì£¼ìš” ì•”ë“¤
      for(let arm = 0; arm < 4; arm++) {
        ctx.fillStyle = arm % 2 ? color : '#ff71ff';
        const baseAngle = (arm / 4) * TAU + time * 1.2;
        for(let seg = 1; seg <= 4; seg++) {
          const px = Math.cos(baseAngle) * (seg * 8);
          const py = Math.sin(baseAngle) * (seg * 8);
          const size = 7 - seg;
          ctx.fillRect(px - size/2, py - size/2, size, size);
        }
      }
      // ë³´ì¡° ì•”ë“¤
      ctx.fillStyle = '#ffd24a';
      for(let i = 0; i < 6; i++) {
        const angle = (i / 6) * TAU + time * 0.8;
        const px = Math.cos(angle) * 18;
        const py = Math.sin(angle) * 18;
        ctx.fillRect(px - 2, py - 2, 4, 4);
      }
    } else { // ë ˆì´ì € íŒ¨í„´ - ì¶©ì „ íš¨ê³¼
      // ë ˆì´ì € í¬íŠ¸ë“¤
      ctx.fillStyle = '#ff3b5c';
      const ports = [
        {x: 0, y: -38, w: 6, h: 18},
        {x: 0, y: 38, w: 6, h: 18},
        {x: -38, y: 0, w: 18, h: 6},
        {x: 38, y: 0, w: 18, h: 6}
      ];
      
      for(const port of ports) {
        ctx.fillRect(port.x - port.w/2, port.y - port.h/2, port.w, port.h);
        // ì¶©ì „ ì´í™íŠ¸
        ctx.fillStyle = '#ffffff';
        const charge = Math.sin(time * 8) * 0.5 + 0.5;
        const chargeSize = port.w * charge * 0.6;
        ctx.fillRect(port.x - chargeSize/2, port.y - chargeSize/2, chargeSize, chargeSize);
        ctx.fillStyle = '#ff3b5c';
      }
      
      // ì¤‘ì•™ì—ì„œ ë»—ì–´ë‚˜ê°€ëŠ” ì—ë„ˆì§€ ë¼ì¸
      ctx.strokeStyle = '#ff3b5c';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for(let i = 0; i < 8; i++) {
        const angle = (i / 8) * TAU;
        const len = 15 + Math.sin(time * 6 + i) * 8;
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(angle) * len, Math.sin(angle) * len);
      }
      ctx.stroke();
    }
    
    // ë³´ìŠ¤ í…Œë‘ë¦¬ ê°•ì¡°
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.shadowBlur = 15;
    ctx.shadowColor = color;
    ctx.strokeRect(-coreSize/2 - 2, -coreSize/2 - 2, coreSize + 4, coreSize + 4);
    
    ctx.restore();
  }

  function drawPixelBullet(x, y, r, color, isPlayer = false) {
    const pixelSize = Math.max(2, Math.floor(r * 0.8));
    ctx.save();
    
    if(isPlayer) {
      // í”Œë ˆì´ì–´ íƒ„í™˜ - ë” ë°ê³  ì„ ëª…
      ctx.fillStyle = color;
      ctx.shadowBlur = 6;
      ctx.shadowColor = color;
      ctx.fillRect(Math.floor(x - pixelSize/2), Math.floor(y - pixelSize/2), pixelSize, pixelSize);
      
      // ë‚´ë¶€ ì½”ì–´
      const coreSize = Math.max(1, pixelSize - 2);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(Math.floor(x - coreSize/2), Math.floor(y - coreSize/2), coreSize, coreSize);
    } else {
      // ì  íƒ„í™˜ - ìœ„í—˜í•˜ê³  ë‹¤ì–‘í•œ ëª¨ì–‘
      ctx.fillStyle = color;
      ctx.shadowBlur = 8;
      ctx.shadowColor = color;
      
      const halfSize = pixelSize / 2;
      
      // ìƒ‰ìƒì— ë”°ë¼ ë‹¤ë¥¸ ëª¨ì–‘
      if(color.includes('#ff3b5c') || color.includes('#ff71ff')) {
        // ë¹¨ê°•/ë§ˆì  íƒ€ ê³„ì—´ - ìŠ¤íŒŒì´í¬ ë‹¤ì´ì•„ëª¬ë“œ
        ctx.beginPath();
        ctx.moveTo(x, y - halfSize * 1.3);
        ctx.lineTo(x + halfSize * 0.7, y - halfSize * 0.3);
        ctx.lineTo(x + halfSize * 1.3, y);
        ctx.lineTo(x + halfSize * 0.7, y + halfSize * 0.3);
        ctx.lineTo(x, y + halfSize * 1.3);
        ctx.lineTo(x - halfSize * 0.7, y + halfSize * 0.3);
        ctx.lineTo(x - halfSize * 1.3, y);
        ctx.lineTo(x - halfSize * 0.7, y - halfSize * 0.3);
        ctx.closePath();
        ctx.fill();
      } else if(color.includes('#00e5ff') || color.includes('#49f3ff')) {
        // ì²­ë¡ ê³„ì—´ - ì‹­ì ëª¨ì–‘
        ctx.fillRect(x - halfSize * 1.2, y - halfSize * 0.4, halfSize * 2.4, halfSize * 0.8);
        ctx.fillRect(x - halfSize * 0.4, y - halfSize * 1.2, halfSize * 0.8, halfSize * 2.4);
      } else if(color.includes('#ffd24a')) {
        // ë…¸ë€ìƒ‰ - ë³„ ëª¨ì–‘
        ctx.beginPath();
        for(let i = 0; i < 8; i++) {
          const angle = (i * Math.PI) / 4;
          const radius = (i % 2 === 0) ? halfSize * 1.2 : halfSize * 0.6;
          const px = x + Math.cos(angle) * radius;
          const py = y + Math.sin(angle) * radius;
          if(i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
      } else {
        // ê¸°ë³¸ - ë‹¤ì´ì•„ëª¬ë“œ ëª¨ì–‘
        ctx.beginPath();
        ctx.moveTo(x, y - halfSize);
        ctx.lineTo(x + halfSize, y);
        ctx.lineTo(x, y + halfSize);
        ctx.lineTo(x - halfSize, y);
        ctx.closePath();
        ctx.fill();
      }
      
      // ë‚´ë¶€ ì–´ë‘ìš´ ì½”ì–´ ì¶”ê°€
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = '#000000';
      const coreSize = Math.max(1, pixelSize * 0.3);
      ctx.fillRect(Math.floor(x - coreSize/2), Math.floor(y - coreSize/2), coreSize, coreSize);
    }
    
    ctx.restore();
  }

  function drawPixelParticle(x, y, size, color, ttl) {
    const alpha = Math.min(1, ttl * 3);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = color;
    ctx.shadowBlur = 4;
    ctx.shadowColor = color;
    
    const pixelSize = Math.max(1, Math.floor(size));
    ctx.fillRect(Math.floor(x - pixelSize/2), Math.floor(y - pixelSize/2), pixelSize, pixelSize);
    
    ctx.restore();
  }

  function drawPixelPortal(x, y, r, t) {
    ctx.save();
    ctx.translate(x, y);
    
    const pulse = 1 + 0.1 * Math.sin(t * 5);
    const rotation = t * 2;
    
    ctx.rotate(rotation);
    ctx.scale(pulse, pulse);
    
    // í¬íƒˆ ë§ë“¤
    ctx.strokeStyle = '#ff71ff';
    ctx.shadowBlur = 15;
    ctx.shadowColor = '#ff71ff';
    ctx.lineWidth = 4;
    
    for(let ring = 0; ring < 3; ring++) {
      const ringR = r * (0.3 + ring * 0.3);
      ctx.beginPath();
      
      // í”½ì…€í™”ëœ ì› ê·¸ë¦¬ê¸°
      const segments = 16;
      for(let i = 0; i <= segments; i++) {
        const angle = (i / segments) * TAU;
        const px = Math.cos(angle) * ringR;
        const py = Math.sin(angle) * ringR;
        
        if(i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.stroke();
    }
    
    // ì¤‘ì•™ ì½”ì–´
    ctx.fillStyle = '#ff71ff';
    ctx.fillRect(-4, -4, 8, 8);
    
    ctx.restore();
  }

  function drawPixelOrb(x, y, r, color) {
    ctx.save();
    
    // ì™¸ë¶€ ê¸€ë¡œìš°
    ctx.fillStyle = color + '44';
    ctx.shadowBlur = 8;
    ctx.shadowColor = color;
    const outerSize = r * 2;
    ctx.fillRect(Math.floor(x - outerSize/2), Math.floor(y - outerSize/2), outerSize, outerSize);
    
    // ë©”ì¸ ì˜¤ë¸Œ
    ctx.fillStyle = color;
    ctx.shadowBlur = 4;
    const mainSize = r;
    ctx.fillRect(Math.floor(x - mainSize/2), Math.floor(y - mainSize/2), mainSize, mainSize);
    
    // ì½”ì–´
    ctx.fillStyle = '#ffffff';
    ctx.shadowBlur = 0;
    const coreSize = Math.max(2, r * 0.5);
    ctx.fillRect(Math.floor(x - coreSize/2), Math.floor(y - coreSize/2), coreSize, coreSize);
    
    ctx.restore();
  }

  // ===== ë ˆë²¨ì—… ì¹´ë“œ =====
  const LVL_CARDS = [
    {id:'DMG', text:'ê³µê²©ë ¥ +20%', apply:()=>playerUp.dmg*=1.2},
    {id:'ROF', text:'ì—°ì‚¬ì†ë„ +15%', apply:()=>playerUp.rof*=1.15},
    {id:'SPD', text:'íƒ„ì† +20%', apply:()=>playerUp.projSpeed*=1.2},
    {id:'RANGE', text:'ì‚¬ê±°ë¦¬ +15%', apply:()=>playerUp.range*=1.15},
    {id:'HEART', text:'ìµœëŒ€ ì²´ë ¥ +1 (ì¦‰ì‹œ íšŒë³µ)', apply:()=>{player.hpMax += 1; player.hp = Math.min(player.hp + 1, player.hpMax); playerUp.survivability*=1.05}},
    {id:'SPECIAL_LASER', text:'ë ˆì´ì € ê³¼ì—´ ë‚´ì„±â†‘(ì¿¨ -15%)', apply:()=>playerUp.special.laserCool = (playerUp.special.laserCool||1)*0.85},
    {id:'CORE_MAGNET', text:'ì½”ì–´ í¡ì… ê°•í™”', apply:()=>playerUp.special.magnet = (playerUp.special.magnet||0)+1}
  ];
  function presentUpgradeChoices(){
    // ì¹´ë“œ 3ê°œ
    const picks=[];
    while(picks.length<3){
      const c = LVL_CARDS[(Math.random()*LVL_CARDS.length)|0];
      if(!picks.includes(c)) picks.push(c);
    }
    const holder = document.getElementById('cardHolder');
    holder.innerHTML='';
    for(const c of picks){
      const div=document.createElement('div');
      div.className='cardOpt';
      div.innerHTML=`<b>${c.text}</b><div class="hint tiny">${c.id}</div>`;
      div.onclick=()=>{
        c.apply(); hideLvl();
      };
      holder.appendChild(div);
    }
    showLvl();
  }

  // ===== íˆíŠ¸ìŠ¤í†± =====
  let _hitstopUntil=0;
  function hitstop(ms){
    _hitstopUntil = Math.max(_hitstopUntil, now()+ms);
  }

  // ===== HPë°” =====
  function updateHpBar(){
    const bar = document.getElementById('bossHpFill');
    if(!boss||!boss.alive){ bar.style.width='0%'; return; }
    bar.style.width = (boss.hpRatio*100).toFixed(1)+'%';
  }

  // ===== ìƒíƒœ ì „í™˜ =====
  function stageClear(){
    document.getElementById('bossHp').style.display='none';
    setTimeout(()=>{
      nextStage();
      document.getElementById('bossHp').style.display='block';
    }, 900);
  }
  function stageClearAll(){
    gameState=STATE.STAGECLEAR;
    const timeSec = totalTime;
    // ê¸°ë¡ ì €ì¥
    if(!save.bestTimeSec || timeSec < save.bestTimeSec){
      save.bestTimeSec = timeSec;
      save.bestStage = BOSSES.length;
      saveNow();
    }
    showStartMenu();
  }
  function gameOver(){
    gameState=STATE.GAMEOVER;
    // ê¸°ë¡ ì—…ë°ì´íŠ¸(ìµœê³  ìŠ¤í…Œì´ì§€)
    if((stageIndex+1) > (save.bestStage||0)){
      save.bestStage = stageIndex+1;
      save.bestTimeSec = totalTime;
      saveNow();
    }
    showStartMenu('GAME OVER');
  }

  function showStartMenu(note){
    const menu=document.getElementById('menuStart');
    menu.style.display='flex';
    if(note) menu.querySelector('h1').textContent = `NEON BOSS HUNTER â€” ${note}`;
  }
  function hideStartMenu(){
    document.getElementById('menuStart').style.display='none';
  }

  function showLvl(){
    gameState=STATE.LEVELUP;
    document.getElementById('lvlup').style.display='flex';
  }
  function hideLvl(){
    document.getElementById('lvlup').style.display='none';
    
    // ë‹¤ìŒ ìŠ¤í…Œì´ì§€ë¡œ ì§„í–‰
    stageIndex++;
    if(stageIndex>=BOSSES.length){
      // ì „ ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´
      stageClearAll();
      return;
    }
    
    gameState = STATE.PLAY;
    stageNote(`STAGE ${stageIndex+1}`);
    boss = new Boss(BOSSES[stageIndex]);
    updateHpBar();
  }

  function togglePause(){
    if(gameState===STATE.PLAY){ gameState=STATE.PAUSE; }
    else if(gameState===STATE.PAUSE){ gameState=STATE.PLAY; loop(); }
  }

  // ===== ìŠ¤í…Œì´ì§€ ë…¸íŠ¸ =====
  let noteTimer=0;
  function stageNote(text){
    const el=document.getElementById('stageNote');
    el.textContent=text;
    el.style.display='block';
    noteTimer=1.6;
    const hide=()=>{ if(noteTimer<=0){ el.style.display='none'; } else { noteTimer-=0.1; setTimeout(hide,100); } };
    setTimeout(hide,1000);
  }

  // ===== UI ì„¸íŒ… =====
  function buildWeaponGrid(){
    const g=document.getElementById('weaponGrid');
    g.innerHTML='';
    for(const w of weapons){
      if(!save.unlockedWeapons[w.id]) continue; // í•´ê¸ˆ ì œí•œì´ ìˆë‹¤ë©´
      
      // ë””ë²„ê·¸ ë¬´ê¸°ëŠ” ë””ë²„ê·¸ ëª¨ë“œì¼ ë•Œë§Œ í‘œì‹œ
      if(w.debug && !settings.debugMode) continue;
      
      const d=document.createElement('div');
      d.className='weapon'; d.dataset.id=w.id;
      
      // ë””ë²„ê·¸ ë¬´ê¸°ì¸ ê²½ìš° íŠ¹ë³„í•œ ìŠ¤íƒ€ì¼ ì ìš©
      if(w.debug) {
        d.style.border = '2px solid #ff0000';
        d.style.backgroundColor = 'rgba(255, 0, 0, 0.1)';
      }
      
      d.innerHTML=`<b>${w.name}</b><div>${w.desc}</div><div class="tiny">ì´ë™ì†ë„ ê³„ìˆ˜: ${w.move}</div>`;
      d.onclick=()=>{
        chosenWeapon=w.id;
        [...g.children].forEach(c=>c.classList.remove('sel'));
        d.classList.add('sel');
      };
      if(w.id===chosenWeapon) d.classList.add('sel');
      g.appendChild(d);
    }
  }
  function buildKeyList(){
    const list=document.getElementById('keyList');
    list.innerHTML='';
    const items = [
      ['up','ìœ„'],['down','ì•„ë˜'],['left','ì™¼ìª½'],['right','ì˜¤ë¥¸ìª½'],
      ['fire','ì‚¬ê²©'],['melee','ê·¼ì ‘'],['dash','ëŒ€ì‹œ'],['pause','ì¼ì‹œì •ì§€']
    ];
    for(const [id,label] of items){
      const row=document.createElement('div');
      row.className='row'; row.style.margin='6px 0';
      const btn=document.createElement('div');
      btn.className='btn pill';
      btn.textContent=settings.keys[id];
      btn.onclick=()=>{
        btn.textContent='ëˆŒëŸ¬ì„œ ì„¤ì •...';
        const onKey=(e)=>{
          e.preventDefault();
          settings.keys[id]= e.code || 'MouseLeft';
          btn.textContent=settings.keys[id];
          save.settings=settings; saveNow();
          removeEventListener('keydown', onKey);
          removeEventListener('mousedown', onMouse);
        };
        const onMouse=(e)=>{
          settings.keys[id]='MouseLeft';
          btn.textContent='MouseLeft';
          save.settings=settings; saveNow();
          removeEventListener('keydown', onKey);
          removeEventListener('mousedown', onMouse);
        };
        addEventListener('keydown', onKey, {once:true});
        addEventListener('mousedown', onMouse, {once:true});
      }
      row.innerHTML=`<div style="width:80px">${label}</div>`;
      row.appendChild(btn);
      list.appendChild(row);
    }
  }

  // ì´ë²¤íŠ¸ ë°”ì¸ë”©
  document.getElementById('btnStart').onclick=()=>startRun();
  document.getElementById('btnSettings').onclick=()=>{ document.getElementById('modalSettings').style.display='flex'; buildKeyList(); }
  document.getElementById('btnCloseSettings').onclick=()=>{ document.getElementById('modalSettings').style.display='none'; }
  document.getElementById('btnResetSave').onclick=()=>{ localStorage.removeItem(SAVE_KEY); save=loadSave(); settings=save.settings; saveNow(); buildWeaponGrid(); buildKeyList(); };
  document.getElementById('btnDebug').onclick=()=>{ settings.showHitbox = !settings.showHitbox; save.settings=settings; saveNow(); };
  document.getElementById('btnPause').onclick=()=>togglePause();

  // ì˜µì…˜
  document.getElementById('optGraphicsMode').onchange=(e)=>{ settings.graphicsMode=e.target.value; save.settings=settings; saveNow(); }
  document.getElementById('optColorBlindMode').onchange=(e)=>{ settings.colorBlindMode=e.target.value; save.settings=settings; saveNow(); }
  document.getElementById('optShowHitbox').onchange=(e)=>{ settings.showHitbox=e.target.checked; save.settings=settings; saveNow(); }
  document.getElementById('optShowFps').onchange=(e)=>{ settings.showFps=e.target.checked; save.settings=settings; saveNow(); }
  document.getElementById('optVibrate').onchange=(e)=>{ settings.vibrate=e.target.checked; save.settings=settings; saveNow(); }

  buildWeaponGrid(); buildKeyList(); refreshUIFromSave();

  // ì‹œì‘ ì‹œ ë©”ë‰´ í‘œì‹œ
  showStartMenu();
})();
</script>
</body>
</html>
